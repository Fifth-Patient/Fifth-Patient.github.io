{"meta":{"title":"巫术师","subtitle":"双手充满魔力","description":null,"author":"Chris Chen","url":"https://fifth-patient.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-04-02T09:17:10.000Z","updated":"2020-01-26T14:54:29.906Z","comments":false,"path":"categories/index.html","permalink":"https://fifth-patient.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-04-02T09:48:17.000Z","updated":"2020-01-24T15:57:36.375Z","comments":true,"path":"about/index.html","permalink":"https://fifth-patient.github.io/about/index.html","excerpt":"","text":"个人简介hi，很高兴您来到了这里，首先自我介绍一下，我叫陈钦武（Chris Chen），97年，是一名前端工程师。技术栈以vue全家桶为主，基本功H5+CSS3+ES6；开发环境是git+node+vscode等，除此之外。其他的主流技术：小程序、typescript、hybrid app也有玩过一些啦~ 一些工程化的东西：gulp grunt webpack, 还有一些css预处理语言html模板引擎: less, sass/scss, stylus jade 也很好玩~一个合格的前端工程师肯定也是需要“糟蹋”到后端的啦,比如node我就“糟蹋”过：express、mongodb.. 接下来打算好好学学小程序、typescript和react框架。 个人照片 长相一般，不帅不丑 关于头像我长什么样你也看到啦，所以我没把自己的弄成博客的头像。我觉得程序员是靠算双手打代码的，所以双手充满魔力。所以头像就设置成了一双手咯，这也是博客的title设置为“巫术师”的原因。 关于小站小站使用node的一个博客框架hexo搭建，使用NexT主题，部署在github上。目前有一些功能还没开放，比如评论点赞搜索；以后再会慢慢开放的，也会写一篇教程告诉读者这个博客是怎么做的。 为什么要写博客现在的文章写的并不多，这也只是个开始而已，博客系统还不是很完善，功能呀，介绍之类的。所以在这里简单说说在下为什么要写博客。 主要有以下几个原因 记录（追求深度，长阅读） 博文（写技术） 交流（issue） 入口项目（介绍个人的其他demo） 用途（项目维护） 选择github（git项目，开源情怀） 其实在下从学习编程开始就一直使用印象笔记写笔记，写博客之前也在问自己真的有没有必要（这里考虑内容重复还有多了一个需要整理的地方..）。权衡利弊下，在下的结论是非常有必要！下面可以分析一下，若无兴趣可跳阅。 虽然有印象笔记，可印象笔记是写给自己看的，偏碎片化；写文章很锻炼自己的表达能力，也能复习之前的笔记，在下追求深度阅读，不求数量，力求质量 博文的评论系统，能打开和世界交流的窗口（虽然在下也有逛其他的技术论坛啦，哈哈），给自己和其他同行一个交朋友的机会 这个网站不只是一个博客，更是一个项目，毕竟是自己的一刀一刀削的作品不是么，虽然用了轮子，但在下用心制作，用爱发电，以后自己做的demo也可以在博客写博文介绍，作为其他demo的所有入口导航，何乐不为呢？ 同时，作为一个入口项目，它更是一个网站，自己的技能可以用上了，以后不是一个个小小的demo了，以后可以慢慢维护，为其添加各种自定义的功能，也能让自己有更多的收获 选择自己搭建而不用博客园,csdn思否等平台是方便,作为一个喜欢折腾自己的人，既然要搭，那就要定制性强,自由度高的，这是在下选择hexo的原因 托管在github上，那自己的github又多了一个仓库，hexo生成的又是静态文件，而且又有gh-pages这个功能，所以不需要云服务器也不要购置域名，多好啊，hahahahah… 总结：巫术师 = 博客 + 个人网站 + demo入口 + github仓库 内心OS：简直物超所值有木有，还不动手更待何时？于是这个网站就出现了。 推荐文章HTTP：目前博客的文章不多，这篇是自己写的第一篇，很长很长。 左侧导航的归档可以看到小站所有的文章，有些是转载的，有些是直接从印象笔记搬运过来，还未“润色”。 转载：转载的文章都有特定分类过，也有标注转载标签，这是在下推荐阅读的文章。 原创：除开转载外，剩余的都是自己写的了，目前很多都是直接搬运，只是简单处理了格式而已。 结语最后感谢您能浏览本站，若需要和在下联系，请致邮：1923407743@qq.com"},{"title":"标签","date":"2019-04-02T09:09:29.000Z","updated":"2020-01-26T14:54:29.922Z","comments":false,"path":"tags/index.html","permalink":"https://fifth-patient.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"git笔记","slug":"git-note","date":"2020-01-27T15:04:27.000Z","updated":"2020-01-27T15:14:17.550Z","comments":true,"path":"/post/git-note/","link":"","permalink":"https://fifth-patient.github.io/post/git-note/","excerpt":"简介部分重要概念。 HEAD Working Directory / Repository / Stage branch remote tag","text":"简介部分重要概念。 HEAD Working Directory / Repository / Stage branch remote tag 配置 打开Git Bash，配置用户名字和邮件地址 12$ git config --global user.name \"Your Name\"$ git config --global user.email \"email@example.com\" 本机创建SSH，Github配置SSH 一路回车 1$ ssh-keygen -t rsa -C \"youremail@example.com\" win+r输入%USERPROFILE%/.ssh,成功打开且有以下文件则成功. id_ras：私钥，不能泄露 id_ras.pub：公钥，可以告诉任何人 以下操作需要Github账号，若无需注册。 添加SSH密钥 传送门 测试配置 Github新建仓库，初始化 本地clone下来，修改后提交，查看提交者信息是否正确 推送至远端仓库，输入密码 再次修改后提交，若SHH配置成功，无须输入密码 操作省略.. 文件状态 简写 英文 翻译 M modified 修改 R renamed 重命名 C both modified 冲突 R Untracked 未跟踪 命令分析一些常用的命令分析，我很喜欢命令行，不过source tree也挺方便的。 git status输出信息 当前分支 远端分支状态（是否拉取/更新） 暂存区 工作区 实例分析 1234567891011121314151617181920212223242526272829303132333435On branch masterYour branch is ahead of 'origin/master' by 1 commit. (use \"git push\" to publish your local commits)Changes to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) modified: src/main.jsChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: src/components/person-filed/index.vue modified: src/router.js modified: src/views/loop-action/index.vue# ===== 翻译分割线 =====位于master分支您的分支超前“origin / master”一次提交。 （使用“git push”发布您的本地提交）要提交的更改： （使用“git reset HEAD &lt;file&gt; ...”取消暂存） 修改：src / main.js未提交更改的更改： （使用“git add &lt;file&gt; ...”来更新将要提交的内容） （使用“git checkout - &lt;file&gt; ...”来丢弃工作目录中的更改） 修改：src / components / person-filed / index.vue 修改：src / router.js 修改：src / views / loop-action / index.vue git commit输出信息 提交分支 commit hash值 修改文件数量 增删行数 实例分析 1234567[master 2918d65] 1 1 file changed, 1 insertion(+) # ===== 翻译分割线 ===== [master 2918d65] 1 1个文件已更改，1行插入（+） git checkout自修改后还没有被放到暂存区–回到版本库的状态；已经添加到暂存区后，又作了修改–就回到添加到暂存区后的状态。 git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# 清除工作区指定路径(&lt;paths&gt;)下的所有文件修改$ git checkout -- &lt;paths&gt;# 清空暂存区指定路径(&lt;paths&gt;)文件（不重置修改）$ git reset -- &lt;paths&gt;# 清空工作和暂存区的所有更改（重置本次提交）$ git reset HEAD --hard# 删除 untracked files(-f) 包括目录-d$ git clean -fd# 比对指定路径（&lt;path&gt;）文件$ git diff &lt;commit&gt; -- &lt;path&gt;# 查看已经暂存起来的文件(staged)和上次提交时的快照之间(HEAD)的差异$ git diff --cached$ git diff --staged# 比对两次提交$ git diff &lt;hash1&gt; hash2 -- &lt;path&gt;# 比对行改动，不显示具体内容$ git diff --stat# 全部提交$ git commit -am \"commit log\"# 多行插入空行提交$ git commit -m '1.line-1' - m '2.line-2'# 多行提交$ git commit -m '1. line-12. line-2'# 简化工作日志$ git log --pretty=oneline# 查看分支合并图$ git log --graph# 查看分支的合并情况，简化提交信息、hash简写$ git log --graph --pretty=oneline --abbrev-commit#命令历史$ git reflog# 重命令分支$ git branch -m &lt;old_name&gt; &lt;new_name&gt;# 切换分支$ git checkout &lt;branch&gt;# 合并分支$ git merge &lt;branch&gt;# 远端版本信息$ git remote -v# 添加git远端仓库$ git remote add &lt;url&gt;# 拉取远端分支提交$ git pull origin master# 推送远端分支提交$ git push origin master# 拉取远端分支到本地新分支$ git checkout -b &lt;new_branch&gt; &lt;remote&gt; &lt;branch&gt; skill一些简简单单的小技巧。 忽略文件/目录根目录创建.gitignore文件。 windows系统需使用命令行创建，打开cmd，定位。 1&gt; type nul &gt; .gitignore .gitignore文件添加需要忽略的文件/目录即可。 一般不需要自己编辑，github官方也提供了不同语言的.gitignore 传送门 提交空目录创建 .gitkeep 文件，内容如下 123# Ignore everything in this directory * # Except this file !.gitkeep","categories":[{"name":"git","slug":"git","permalink":"https://fifth-patient.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://fifth-patient.github.io/tags/git/"}]},{"title":"vue技巧篇：生命周期","slug":"lifecycle","date":"2020-01-25T14:17:01.000Z","updated":"2020-01-26T14:54:18.009Z","comments":true,"path":"/post/lifecycle/","link":"","permalink":"https://fifth-patient.github.io/post/lifecycle/","excerpt":"前言 每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 其实对生命周期而言，我们要搞懂的是。 什么阶段初始化数据 什么阶段初始化事件 什么阶段渲染DOM 什么阶段挂载数据","text":"前言 每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 其实对生命周期而言，我们要搞懂的是。 什么阶段初始化数据 什么阶段初始化事件 什么阶段渲染DOM 什么阶段挂载数据 生命周期图示 生命周期钩子函数可以分成6个类型，除了一个最少用的子孙组件错误钩子函数。每个类型都有 “beforeXX” “XXed”，总共有11个生命周期钩子函数。 序 类型 钩子函数名 - 1 钩子函数名 - 2 1 创建 beforeCreate created 2 挂载 beforeMount mounted 3 更新 beforeUpdate updated 4 销毁 beforeDestroy destroyed 5 激活 activated deactivated 6 错误 errorCaptured \\ 生命周期钩子官方api 传送门 别看有11个钩子函数，看似一时间难以掌握。其实也不是很需要全部掌握，常用的就那么几个。这几个钩子函数会一一介绍，也会先大家演示一遍完整的生命周期。且实际开发中我们更在意的是，这些钩子函数对组件实例数据/事件的影响。 完整的生命周期这一章基本是在翻译生命周期图示的内容。不过很多开发者都对完整的生命周期流程一知半解。虽然提供源码，还是建议每个人按照自己的理解写一下实例。 新建lifecycle目录，定义lifecycle.vue，导入process.vue 1234567891011121314&lt;!-- lifecycle.vue --&gt;&lt;template&gt; &lt;lifecycle-process&gt;&lt;/lifecycle-process&gt;&lt;/template&gt;&lt;script&gt;import LifecycleProcess from './process'export default &#123; components: &#123; LifecycleProcess &#125;&#125;&lt;/script&gt; 我们在process.vue体现完整的生命周期。 虽然官网的示例都是new Vue() 初始化vue实例。单文件组件(*.vue)使用export default也同样是初始化vue实例。 这里有几个概念： 数据观测 (data observer) : prop， data， computed 事件机制 (event / watcher)： methods 函数， watch侦听器 我们只简单搞清楚每个阶段发生了什么事情。其他还没有开始做的事情不想提及。毕竟未开始也未完成，默认就是还没初始化嘛，有什么好说的呢？ create本小节标题是create，是指vue实例的create阶段。不是生命周期钩子函数 beforeCreate / created。 我们不打算从生命周期的钩子函数作为切入点。只要搞清楚了vue实例xx阶段做了什么事情，那beforeXX / XXed 的区别自然知晓。 我们也根据官方api的资料来表述，实例阶段做了什么事情。 实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。 那我们应该定义 prop， data， computed methods watch，然后使用beforeCreate， created前后对比一下。 123456789101112131415161718192021222324252627282930// process.vueexport default &#123; // prop， data， computed methods watch // 自行定义，这里不浪费篇幅 props: &#123;&#125;, data () &#123; return &#123; msg: 'Hey Jude!' &#125; &#125;, methods: &#123;&#125;, watch: &#123;&#125;, beforeCreate () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'beforeCreate--实例创建前状态') console.log(\"%c%s\", \"color:skyblue\", \"$props :\" + this.$props) console.log(\"%c%s\", \"color:skyblue\", \"$data :\" + this.$data) console.log(\"%c%s\", \"color:skyblue\", \"computed :\" + this.reverseMsg) console.log(\"%c%s\", \"color:skyblue\", \"methods :\" + this.reversedMsg) // this.msg = 'msg1' &#125;, created () &#123; console.log(\"%c%s\", \"color:red\", 'created--实例创建完成状态') console.log(\"%c%s\", \"color:skyblue\", \"$props :\" + this.$props) console.log(\"%c%s\", \"color:skyblue\", \"$data :\" + this.$data) console.log(\"%c%s\", \"color:skyblue\", \"computed :\" + this.reverseMsg) console.log(\"%c%s\", \"color:skyblue\", \"methods :\" + this.reversedMsg()) // this.msg = 'msg2' &#125;&#125; prop， data， computed， methods， watch。除了watch比较特殊，其他都得到了验证效果。要验证也很简单，取消 beforeCreate， created 对 this.msg赋值的注释。watch msg 看看控制台会打印msg1还是msg2，或者两者皆可。聪明的你肯定知道控制台只打印msg2的，所以我就不取消注释了。 mount el 被新创建的 vm.$el 替换。 如果根实例挂载到了一个文档内的元素上，当mounted被调用时vm.$el也在文档内。 12345&lt;template&gt; &lt;div class=\"skill-lifecycle-process\"&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt;&lt;/template&gt; 12345678910export default &#123; beforeMount () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'beforeMount--挂载之前的状态') console.log(\"%c%s\", \"color:skyblue\", \"$el :\",this.$el) &#125;, mounted () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'mounted--已经挂载的状态') console.log(\"%c%s\", \"color:skyblue\", \"$el :\", this.$el) &#125;&#125; mount阶段，由于vue支持多种方式挂载DOM。而vue实例在created之后，beforeMounted之前这一阶段，对挂载DOM的方式有判断机制，这里的流程稍微复杂也比较重要。 多种挂载DOM的方式。 el / $mout template render 这里打算分别使用n个组件对着这几种挂载方式。你可以选择暂时跳过，先走完整个周期流程再回来。 create mount是每个组件都必须经历的生命周期，但接下来的生命周期就比较有选择性了。 下一实例阶段 update 这里会按照判断机制的顺序介绍不同的挂载方式。 el / $mount首先会判断有无el选项声明实例要挂载的DOM。 el选项：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。 如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译。 el选项需要使用显示使用new创建的实例才生效。为了方便，这里新建了skill-lifecycle-el.html放在publi（静态资源目录）下。 本来想用俄罗斯套娃的方式在vue组件套一个new Vue()，结果行不通。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- skill-lifecycle-el.html --&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;p v-text=\"msg\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://cdn.bootcss.com/vue/2.6.10/vue.min.js\"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function() &#123; var vm = new Vue(&#123; el: '#app', props: &#123;&#125;, data () &#123; return &#123; msg: 'Hey Jude!' &#125; &#125;, computed: &#123;&#125;, methods: &#123;&#125;, watch: &#123;&#125;, beforeMount () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'beforeMount--挂载之前的状态') console.log(\"%c%s\", \"color:skyblue\", \"$el :\",this.$el) console.log(\"%c%s\", \"color:skyblue\", \"el :\" + this.$el.innerHTML) // debugger &#125;, mounted () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'mounted--已经挂载的状态') console.log(\"%c%s\", \"color:skyblue\", \"$el :\", this.$el) console.log(\"%c%s\", \"color:skyblue\", \"el :\" + this.$el.innerHTML) &#125; &#125;) // vm.$mount('#app') &#125; &lt;/script&gt; &lt;/bdoy&gt; el 还有 vm.$mount 必须要有一个，不然vue的声明周期就停止，beforeMount不触发。 vm.$mount 手动地挂载一个未挂载的实例。 两种挂载方式的效果是一样的。 值得注意的是，beforeMount真实的DOM确实是会渲染双花括号还有指定的，mounted之后会被替换成真正的数据。 template判断完el选项，接下来会判断有无template选项 一个字符串模板作为 Vue 实例的标识使用。模板将会替换挂载的元素。 如此说来，作用跟el选项差不多，都是挂载元素的。 那我们声明template选项，写上html tag string，然后把#app DOM里面的内容注释掉。（DOM保留） 1234567891011121314151617181920212223242526&lt;!-- skill-lifecycle-template.html --&gt; &lt;!-- 这个就叫 \"#app\" DOM --&gt; &lt;div id=\"app\"&gt; &lt;!-- &lt;p v-text=\"msg\"&gt;&lt;/p&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; --&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: '#app', template: '&lt;b&gt; &#123;&#123; msg &#125;&#125;&lt;/b&gt;', // 这个就叫 template 选项 beforeMount () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'beforeMount--挂载之前的状态') console.log(\"%c%s\", \"color:skyblue\", \"$el :\",this.$el) // debugger &#125;, mounted () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'mounted--已经挂载的状态') console.log(\"%c%s\", \"color:skyblue\", \"$el :\", this.$el) console.log(\"%c%s\", \"color:skyblue\", \"#app :\", document.querySelector('#app')) &#125; &#125;) &lt;/script&gt; 我们在挂载后找一下#app还在不在。 从这图，我们可以知道： vm.$el在beforeMount反应的是el选项的#app DOM（此时#app DOM还是模板状态） 很明显，template选项把el选择的#app给替换掉了，故template选项的优先级比el选项/vm.$mount()高。 el选项：比较温和，只是霸占人家的屋子自己住在里面。template选项：直接端掉人家的老窝，自己筑新巢。 renderrender选项是一个渲染函数，返回虚拟节点 (virtual node），又名VNode。 render函数的用法稍微复杂，又牵扯到虚拟DOM、JSX等技术点，之后会另写一篇详细讲解。 假设我们现在并不明白render的用法，只知道它会返回虚拟节点，就够了。 12345678910&lt;!-- skill-lifecycle-template.html --&gt; &lt;script&gt; new Vue(&#123; el: '#app', template: '&lt;b&gt; &#123;&#123; msg &#125;&#125;&lt;/b&gt;', // 这个就叫 template 选项 render: function (createElement, context) &#123; return createElement('b', this.msg + ' from render') &#125;, // render函数 &#125;) &lt;/script&gt; 可以看到这里template选项我们不注释，就算我们把注释掉template选项， 输出结果也还是一样。 可以粗暴理解为：render是template的升级版，template字符串模板，render返回的是由函数创建生成的VNode。 所以通过判断机制的流程，我们也很清楚了这几种方式挂载DOM的区别。 判断有无挂载DOM：el选项或者 vm.mount()， 无则停止。 判断有无template选项，有则替换掉挂载DOM元素。 判断有无render函数，有则替换掉挂载DOM元素/template选项。 这几种挂载方式是有优先级的，不过因为按照顺序分析，也不用特意去记，后面的会覆盖前面的。 vue不同构建版本的区别（编译器、运行时）vuejs有不同的构建版本，他们按照两个维度来分类，模块化及完整性。 模块化容易理解，这取决于使用环境的模块化机制决定。 完整性的话，引用官网资料。 完整版：同时包含编译器和运行时的版本。 编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。 运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。 什么时候必须使用完整版(编译器+运行时)？ template 选项、挂载DOM（el选项/vm.$mount)，需要依赖编译器编译，这时必须使用完整版。 当使用 vue-loader 或 vueify 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。 可以看看三个html文件的源码引用的vue版本。 skill-lifecycle-el.html skill-lifecycle-template.html skill-lifecycle-render.html update 数据更改导致的虚拟 DOM 重新渲染和打补丁。 实例data属性更新将会触发update阶段，数据的值改变，才会触发，并不是每次赋值都会触发。 123456&lt;template&gt; &lt;div class=\"skill-lifecycle-process\"&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125; &lt;/p&gt; &lt;p&gt;&lt;button @click=\"handleClick\"&gt;update&lt;/button&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516171819202122232425262728293031export default &#123; data () &#123; return &#123; msg: 'Hey Jude!' &#125; &#125;, methods: &#123; handleClick () &#123; this.msg = 'Hello World!' &#125; &#125;, watch: &#123; msg () &#123; console.log(this.msg) &#125; &#125;, beforeUpdate () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'beforeUpdate--数据更新前的状态') console.log(\"%c%s\", \"color:skyblue\", \"el :\" + this.$el.innerHTML) console.log(this.$el) console.log(\"%c%s\", \"color:skyblue\", \"message :\" + this.msg) console.log(\"%c%s\", \"color:green\", \"真实的 DOM 结构:\" + document.querySelector('.skill-lifecycle-process').innerHTML) &#125;, updated () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'updated--数据更新完成时状态') console.log(\"%c%s\", \"color:skyblue\", \"el :\" + this.$el.innerHTML) console.log(this.$el); console.log(\"%c%s\", \"color:skyblue\", \"message :\" + this.msg) console.log(\"%c%s\", \"color:green\", \"真实的 DOM 结构:\" + document.querySelector('.skill-lifecycle-process').innerHTML) &#125;&#125; 不难看出，vue的响应式机制是先改变实例数据。此时新的实例数据并还没有挂载到DOM，只是存在于虚拟DOM(el);再通过虚拟DOM重新渲染DOM元素。 如果这个更新的数据有侦听器，侦听器会在update阶段前触发。 destroy 对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。 销毁指的是销毁vue的响应式系统，事件还有子实例。都是针对vue层面的，并非销毁DOM之意。 调用vm.$destroy()触发 传送门 调用这个实例方法后，DOM并没有什么变化。vue实例也还是存在的，只是vue的响应式被销毁。DOM与vue切断了联系。 active 被 keep-alive 缓存的组件激活/停用时调用 这里需要在lifecycle.vue引用process.vue的地方包裹一层keepa-alive 12345&lt;!-- lifecycle.vue --&gt;&lt;p&gt;&lt;button @click=\"handleClick\"&gt;toggle show&lt;/button&gt;&lt;/p&gt;&lt;keep-alive&gt; &lt;lifecycle-process v-if=\"isShow\"&gt;&lt;/lifecycle-process&gt;&lt;/keep-alive&gt; v-if指令切换组件挂载/移除触发；v-show指令切换组件显示/隐藏不触发。 12345678910// lifecycle-process.vueexport default &#123; // ... activated () &#123; console.log('activated') &#125;, deactivated () &#123; console.log('deactivated') &#125;&#125; 有意思的是，页面初始化的时候，activated会在mounted之后触发。 单纯的切换组件的挂载/移除状态，activated / deactivated 会触发；组件不会重新实例化走一遍生命周期，尽管这里用是的v-if。 而当我们destroy组件，之后的每一次切换挂载/移除，组件都会重新实例化，我们只是第一次destroy而已。 errorCapture* 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。 这个钩子函数是用来捕获错误的，而且只应用于子孙组件，实际开发中并不常用。 传送门 那么整个周期流程已经介绍完毕了，同样的提供了process.vue源码。也可以选择重新回头深入了解mount机制了。 常用生命周期函数11个钩子函数就这样介绍完了，常用的钩子函数并不多。 created此时数据/事件可用，可以在此动态创建数据或者定义自定义事件。 12345678export default &#123; created () &#123; this.$data.staticString = 'static' // 定义变量 this.$on('on-created', () =&gt; &#123; // 定义自定义事件 console.log(this.$data.staticString) &#125;) &#125;&#125; 注意：created创建的变量，更新不会被vue所监听。 在此处定义变量数据，是为了提升性能，如果这个变量更新与view层无关的话。 mountedDOM渲染完毕，可以执行页面的初始化操作（移除遮罩），获取DOM（如果有必要的话）。 123456export default &#123; mounted () &#123; this.init() console.log(this.$refs.controlPanel.$options.name) &#125;&#125; vue 并不推荐直接操作DOM，不过还是提供了$ref作为应急解决方案。 useful.vue写的比较简单。 结语然而， 本篇的内容仅仅讨论的是vue组件的生命周期相关钩子函数。路由守卫，自定义指令，多个组件引用的钩子函数这些并未提及，推荐几篇文章。看完相信能收获得更多。 vue 生命周期深入 针对多个组件引用情况（父子、兄弟组件）等情况生命周期的执行顺序 vue生命周期探究（一） 包括组件、路由、自定义指令等共计28个的生命周期 vue生命周期探究（二） 路由导航守卫的钩子函数执行顺序","categories":[{"name":"vue","slug":"vue","permalink":"https://fifth-patient.github.io/categories/vue/"}],"tags":[{"name":"vue-skill","slug":"vue-skill","permalink":"https://fifth-patient.github.io/tags/vue-skill/"}]},{"title":"vue技巧篇：组件通讯","slug":"component-communication","date":"2020-01-24T12:05:19.000Z","updated":"2020-01-24T15:57:36.246Z","comments":true,"path":"/post/component-communication/","link":"","permalink":"https://fifth-patient.github.io/post/component-communication/","excerpt":"前言组件化也是vue的一大特点之一，组件是组成vue项目的基本单位。一个组件可以做什么？ 这取决于组件的设计，组件一般由以下几点组成： 选项 实例属性/方法 生命周期 全局API 指令 导入的其他组件 组件是可复用的vue实例，可以复用，导入导出，组成组件化系统。 vue的组件都是保持相对独立的关系，可是又可以进行相互依赖（导入导出机制）；这种规范下，实际开发又难免会出现组件之间传递数据、转发事件的场景。而vue又对组件间的数据、事件做了一定的限制；正因如此，我们需要好好探讨vue的组件通讯。","text":"前言组件化也是vue的一大特点之一，组件是组成vue项目的基本单位。一个组件可以做什么？ 这取决于组件的设计，组件一般由以下几点组成： 选项 实例属性/方法 生命周期 全局API 指令 导入的其他组件 组件是可复用的vue实例，可以复用，导入导出，组成组件化系统。 vue的组件都是保持相对独立的关系，可是又可以进行相互依赖（导入导出机制）；这种规范下，实际开发又难免会出现组件之间传递数据、转发事件的场景。而vue又对组件间的数据、事件做了一定的限制；正因如此，我们需要好好探讨vue的组件通讯。 父子组件通讯由于组件通讯，有时候是为了传递数据，而有时候是为了转发事件；这里不对这两种场景做区分，统一要解决的场景为“组件通讯”。 其实vue组件通讯并不复杂，官方文档提供了几个方法。 props 向子组件传递数据 传松门 emit 向父组件抛出事件 传送门 v-model 父子组件数据同步（带有一定的抛出事件机制） 传送门 props+sync修饰符 传松门 slot-scope 作用域插槽 传送门 由于官方文档介绍得很详细，也提供了传送门，具体实现并不详细介绍。不过vue组件有一个设计概念还是有大家了解下的——单向数据流 传送门 单向数据流 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。 而如果需要改变父组件的数据，则子组件抛出事件；父组件定义自定义事件，在自定义事件中改变自己的数据。 这些方法有所缺点，不同的业务场景需要开发者自行衡量；不过适应的业务场景都局限于父子组件的通讯。 其实父子组件通讯的是最好解决的，毕竟有直接联系。 非父子组件通讯由于非父子组件没有直接联系，只能使用间接联系。两个组件使用相同的“代理“，由”代理“转发数据或者事件的交互。 ”代理“各式各样，也有不同的实现方式。 备注：这里的“代理”是中转站的意思，为了方便理解，表述为：“代理”。 官方也提供几种解决方案： $root.data 传送门 vuex 传送门 vue-router 传送门 $root.data我们知晓：一个vue项目由组件为单位组成。但是，一个vue项目只有一个根组件。且所有组件实例均可访问根组件实例this.$root。官方文档也提供了相应的实现方式传送门。 实际开发中，并不使用这种方式进行组件通讯。我们并不希望$root.data 挂载庞大的数据变量。我们仅希望他只负责渲染HTML DOM元素。 vuexvuex专用于vue项目，作为状态管理模式插件。（理解为集中存储全局变量的地方就好了。） 前面说到“单向数据流”理念，并不适用多个组件共享状态场景。 因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。 vuex的核心是store（仓库），”store”是一个容器，包含应用中大部分的状态(state)，与单纯的全局对象有两点不同： Vuex 的状态存储是响应式的。 不能直接改变 store 中的状态，若想改变，唯一途径就是显式地提交 (commit) mutation。 一个store可以包含state：储存状态 单一状态树action： 提交mutation方法，可执行异步操作mutation：更改store状态，必须是同步操作getter：从state派生状态，返回值会根据依赖缓存modules：将store分割成模块 简单分析下这张图： State 直接渲染在vue组件 组件可以可以通过Dispatch触发 Actions Actions可以Commit触发Mutations Mutations可以Mutate更改State vue组件计算属性更新State的值 还有几个注意点： vuex的范围：组件外部的 State =&gt; Actions =&gt; Mutations =&gt; State Actions、Mutations： Actions可以执行异步（一般用于后端Api交互）、Commit Mutations；Mutations必须是同步，（一般用于更改State状态） 执行顺序：组件也可以跳过Actions 直接 Commit Mutations， 不过执行顺序是不可逆的。 Actions是可以Dispatch 其他Actions的，同理一个Actions也可以Commit 多个Mutations vue-routervue-router也可以拥有组件通讯的能力，不过这些组件针对的是直接挂载在路由的页面组件。 路由元信息 传送门 路由组件参数 传送门 导航守卫 传送门 $route.query 传送门 总线模式（bus）总线模式需要实例化一个空Vue实例，我们把非父子组件的事件统一集中到这个空Vue实例，让这个实例监听，触发这些自定事件就可以。 Vue 其实是一个构造函数，既然是构造函数，那就可以多次实例化。而构造函数又有原型对象prototype，原型就是为了共享。 那第一步我们可以在Vue的原型对象上实例化一个空Vue实例。 1Vue.prototype.bus = new Vue() 备注：如果是大规模使用，可以在main.js直接定义原型bus属性。局部使用可以包装成一个js模块，需要时引入即可。 再看实例事件 vm.$on vm.$emit 我们可以知晓：$emit 会触发 $on 就可以了。 准备一个文件夹 bus，定义三个组件: bus.vue bus-child1.vue bus-child2.vue 我们要做的是让child1触发child2事件。 123&lt;!-- bus.vue 引入 child1, child2· --&gt;&lt;bus-child1 content=\"skill-bus-child1\"&gt;&lt;/bus-child1&gt;&lt;bus-child2 content=\"skill-bus-child2\"&gt;&lt;/bus-child2&gt; 123456789// bus-child1.vueexport default &#123; // ... methods: &#123; handleClick () &#123; this.bus.$emit('on-change', this.selfContent) &#125; &#125; &#125; 1234567891011// bus-child2.vueexport default &#123; methods: &#123; handleChange ($event) &#123; this.selfContent = $event &#125; &#125;, mounted () &#123; this.bus.$on('on-change', this.handleChange) &#125;&#125; bus.vue 源码 然而总线模式还是有带来一定的作用域问题，由于非父子组件的事件统一集中到空Vue实例，这导致了这些被空vue实例监听的自定义事件，在所有的组件是共享的，这种情况下，很容易产生副作用。 若再增加一个bus-child3.vue，它也监听了this.bus.$on(&#39;on-change&#39;, this.handleChange)。而其实我们并不想bus-child3.vue响应 bus-child1.vue事件。 说白了就是作用域太广，bus是全局作用域；又或者说没有命令空间，相同的事件名不能在两个组件定义。 其实这种解决方案之于$root.dat是换汤不换药的，都是把不同组件的数据/事件集中到一个vue实例。 emitter (dispatch / broadcast)如果两个组件，有相同的父组件，可以使用事件派发与广播机制处理非父子组件通讯。其实都会有相同的父组件的，再不济最顶层就是vue的根实例了，不过一般不需要到根实例。 派发/广播机制很依赖组件层级关系。派发(dispatch):由本组件向上派发事件，供上层组件监听处理。广播(broadcast)：由本组件向下广播事件，供下层组件监听处理。 Element UI 框架源码的emitter.js就是基于派发广播机制处理非父子组件的通讯。源码的emitter.js把其机制封装成了一个独立的mixin，以便在各个组件方便使用。这里就以emitter.js为例子，简单讲解是如何实现的，还有如何使用这个mixin。 123456789101112131415161718192021// 简化emitter.js, 只提取出结构function broadcast (componentName, eventName, params) &#123; // ...&#125;// 标准mixins结构export default &#123; methods: &#123; // 定义dispatch方法，需要三个参数 // @params componentName 派发给哪个上层组件 // @params eventName 派发的事件名 // @params params 事件携带参数 dispatch (componentName, eventName, params) &#123;&#125;, // 定义broadcast方法，需要三个参数 // @params broadcast 广播给哪个下层组件 // @params eventName 广播的事件名 // @params params 事件携带参数 broadcast (componentName, eventName, params) &#123;&#125; &#125;&#125; componentName 指的是定义组件时，组件的选项name 传送门 123export default &#123; name: 'component-name'&#125; 跟总线模式一样，我们也要定义一个文件夹——emitter，三个组件 emitter.vue child1.vue child2.vue 同样让child1触发child2事件。 123&lt;!-- emitter.vue 引入 child1 child2 --&gt;&lt;emitter-child1 content=\"emitter-child1\"&gt;&lt;/emitter-child1&gt;&lt;emitter-child2 content=\"emitter-child2\"&gt;&lt;/emitter-child2&gt; 这里child1,child2是兄弟组件，他们共同拥有父组件emitter.vue。所以child1要触发child2事件，需要emitter.vue的帮助。 child1派发事件到emitter.vue emitter定义监听事件，广播到child2 child2定义监听，接收emitter的广播事件 1234567891011// child1.vue 派发事件到 emitter.vueimport Emitter from '@/mixins/Emitter'export default &#123; mixins: [ Emitter ], methods: &#123; handleClick () &#123; this.dispatch('skill-emitter', 'on-child1-change', this.selfContent) &#125; &#125;&#125; 1234567891011121314// emitter.vue 定义监听事件，广播到 child2.vueimport Emitter from '@/mixins/emitter'export default &#123; mixins: [ Emitter ], created () &#123; // 代理child1派发的on-child1-change事件 // 该事件不在此组件处理 // 广播给child2的on-change事件处理 this.$on('on-child1-change', e =&gt; &#123; this.broadcast('skill-emitter-child2', 'on-change', e) &#125;) &#125;&#125; 1234567891011// child2.vue 定义监听，接收 emitter.vue 的广播事件export default &#123; methods: &#123; handleChange ($event) &#123; this.selfContent = $event &#125; &#125;, created () &#123; this.$on('on-change', this.handleChange) &#125;&#125; emitter.vue 源码 派发/广播机制对比总线模式，限制了事件必须是具体的某个组件的，使得事件的传递更加精确可控。 emitter.vue 是兄弟组件实例，如果是上下层的组件。不需要经过如emitter.vue的代理，直接在目标组件监听自定义事件。 不管是dispatch还是broadcast方法，都很依赖componentName，还有eventName，所以良好的命名规范是非常重要的，dispatch/broadcast到指定的组件的xx事件。该指定的组件this.$on监听自定义事件就可以触发。 结语今天我们从组件通讯的解决方式出发，介绍到了多种组件通讯的解决方案。以前觉得组件通讯无非就是这几种。 prop &lt;=&gt; emit vuex bus dispatch / broadcast 好好的梳理出来才发现其实在很多场景我们都需要用到组件通讯。只是我们太过习以为常，反而有点忽略了也是其解决方案之一。 在实例开发中，我们也需要结合实际场景思考，是否以上的解决方案是否适用。 一般情况下，我是支持使用dispatch/broadcast模式去处理大多数的非父子组件通讯的。可有时候要一个组件触发各自触发n个组件的事件，这种模式可能编写起来比较繁琐。这个时候可以考虑总线模式，又或者，为了一处比较特殊的处理，是否考虑要引入一个mixins。这些问题都是需要开发者是在实际开发的时候好好去估量利弊的，并没有一种万能的解决方案。（对我来讲，dispatch/broadcast 就已经很万能了。） 还有这里想吐槽一下。 Flux 架构就像眼镜：您自会知道什么时候需要它 。–Dan Abramov (Redux 的作者) 说真的，直到现在我完全不能理解这句充满诗意的话，以及为什么偏偏是像眼镜而不是心灵的窗户？！","categories":[{"name":"vue","slug":"vue","permalink":"https://fifth-patient.github.io/categories/vue/"}],"tags":[{"name":"vue-skill","slug":"vue-skill","permalink":"https://fifth-patient.github.io/tags/vue-skill/"}]},{"title":"vue技巧篇：自定义双向绑定","slug":"two-way-binding","date":"2020-01-20T09:57:01.000Z","updated":"2020-01-27T12:18:06.130Z","comments":true,"path":"/post/two-way-binding/","link":"","permalink":"https://fifth-patient.github.io/post/two-way-binding/","excerpt":"前言双向绑定 是 vue 的一大特点之一，使用也非常方便。在需要双向绑定的表单控件元素使用指令 v-model即可。 官方文档教程 —— 表单输入绑定（传送门）官方文档api —— v-model 指令（传送门） 注意了：到目前为止，双向绑定只是针对表单控件元素，并没有说明其他DOM元素，或者是自定义组件。 那我们要如何实现在组件（或者说其他DOM元素）的双向绑定呢？ 1&lt;base-components v-model=\"fieldValue\"&gt;&lt;/base-components&gt;","text":"前言双向绑定 是 vue 的一大特点之一，使用也非常方便。在需要双向绑定的表单控件元素使用指令 v-model即可。 官方文档教程 —— 表单输入绑定（传送门）官方文档api —— v-model 指令（传送门） 注意了：到目前为止，双向绑定只是针对表单控件元素，并没有说明其他DOM元素，或者是自定义组件。 那我们要如何实现在组件（或者说其他DOM元素）的双向绑定呢？ 1&lt;base-components v-model=\"fieldValue\"&gt;&lt;/base-components&gt; v-model 浅析 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 节选几段官方文档的资料，不难察觉v-model 会占用一个 prop 属性和一个 $emit 事件。如果有冲突，也是可以更改的。 如果还是好奇 v-model的实现原理，我可以告诉你大概是这样。 双向绑定基于getter/setter 结合观察者模式实现getter/setter指Object.defineProperty遍历vue实例的data选项观察者模式是js的一种设计模型，可以实现发布订阅功能 组件使用双向绑定（基本类型版） 有了相应的资料，我们可以开工了。准备一个组件 base-input.vue 12345678910111213141516171819202122export default &#123; name: 'base-input', props: &#123; value: &#123; type: String, default: '' &#125; &#125;, data () &#123; return &#123; fieldValue: this.value // 初始化赋值 &#125; &#125;, watch: &#123; value (newVal) &#123; this.fieldValue = newVal // 监听props（外部）更新，赋值给data（内部） &#125;, fieldValue () &#123; this.$emit('input', this.fieldValue) // data（内部）更新，抛出到外部 &#125; &#125;&#125; 1&lt;input type=\"text\" v-model=\"fieldValue\"&gt; 有几个注意点要说明下： fieldValue 必须初始化赋值为 props 的 value 初始化页面时 watch 并不执行 内部更新，触发 fieldValue 监听函数 外部更新，触发 value监听函数 base-input 源码 传送门 示例 传送门 :value 与v-model因为之前被这两个搞混过，不明白之间的联系和区别，这里单独拿出来讲一下。 :value 是绑定一个prop value 给组件，实现外部数据传入内部， 单向绑定 v-model 是双向绑定，默认占用prop value 属性和一个 $emit input 事件;在:value 的基础上$emit input实现内部数据抛出外部，从而外部、内部数据达成同步且外内均可更改。 把 base-input v-model=&quot;inputValue&quot;&gt;&lt;/base-input&gt; 换成 :value=&quot;inputValue&quot;试试？ 我们也将在下一节更改指令默认使用的prop 属性 和$emit 事件 可其实这种方式只支持js的基本类型，像对象或者数组的引用类型，这样处理是不够的，所以我们需要对现有的双向绑定方式进行升级。 组件使用双向绑定（引用类型版）准备另一个组件：base-div.vue 把base-input.vue 的代码复制过来，组件名，类名什么的这些标识信息该改的就改一改。 然后可能有的朋友到这里会把 prop value 的 type 改成 Object，这只是第一步而已。 因为引用类型的特性，我们手动给内部变量赋值，会更改其引用地址，故相当于重新初始化了一个变量。这里会触发另一个watch函数，而另一个watch也具备给内部变量赋值的能力； 如果不特殊处理，这两个watch 函数触发其中一个，就会不断调用另一条，造曾死循环。所以我们需要判断当内外部变量相等的时候，就不赋值了。嗯，判断两个对象相等。 判断两个对象相等可能有点尴尬， 那我们把两个对象序列化为JSON 字符串就可以了。 1JSON.stringify(obj1) === JSON.stringify(obj2); 技术点已经准备够了，我们足够实现用v-model绑定一个对象了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849export default &#123; props: &#123; value: &#123; type: [ Object, Array] &#125; &#125;, data () &#123; return &#123; fieldValue: this.value, fieldValueStringify: JSON.stringify(this.value) // 保存外部传入的变量快照，将在监听器中做比较使用 &#125; &#125;, watch: &#123; value: &#123; deep: true, // 深度监听 handler (newVal) &#123; const currentValue = JSON.stringify(newVal) // 外部传入的变量与内部变量比较 // 不相等，内部变量方可赋值为this.value // * 内部变量赋值，将会触发fieldValue监听函数 // 且此时应更新fieldValue 对象字符串快照 if (currentValue !== this.fieldValue) &#123; this.fieldValue = JSON.parse(currentValue) this.fieldValueStringify = currentValue &#125; &#125; &#125;, fieldValue: &#123; deep: true, // 为什么要使用深度监听呢？ handler (newVal) &#123; // 自己改变内部变量，或者因外部变量更新手动赋值内部变量 // 这个函数都会被触发 // 要实现的是内部与外部变量同步，所以快照才是保存外部变量 // 1.当外部变量改动，会先调用 watch value，此时内外部变量同步 // 这时不需要抛出事件，否则出现死循环 // 2.当内部变量改动，会先调用 watch fieldValue // 抛出事件，外部的v-model又会自动更新内部的value // 从而触发 watch value // （这里触发watch value了，可以回去看看1） // 如果你不会兜兜转，那我想你应该feel到了整个更新流程 // **如果被兜住了，先理解外部变量的改动，再理解内部变量的改动 const currentValue = JSON.stringify(newVal) if (currentValue !== this.fieldValueStringify) &#123; this.$emit('input', JSON.parse(currentValue)) &#125; &#125; &#125; &#125;&#125; base-div 源码 传送门 示例 传送门 接下来我们不使用 prop value $emit input了，我们使用 prop insert $emit output。 直接在base-div 改动吧，其实也不复杂。 1234567891011121314151617181920212223242526export default &#123; model: &#123; prop: 'insert', event: 'output' &#125;, props: &#123; insert: &#123; type: [Object, Array] &#125; &#125;, data () &#123; return &#123; fieldValue: this.insert, fieldValueStringify: JSON.stringify(this.insert) // 保存外部传入的变量快照，将在监听器中做比较使用 &#125; &#125;, watch: &#123; insert: &#123; // ... &#125;, fieldValue: &#123; // ... this.$emit('output', JSON.parse(currentValue)) &#125; &#125;&#125; 然后在外部使用 @output 的时候，会发现外部更新不触发 output 事件。刚开始以为组件实现还是有问题，后面想想不对，外部更新没必要抛出事件。外部更新，可以在外部使用 watch 函数，这里确实不管内部组件的事情了。 1&lt;base-div v-model=\"formValue\" @output=\"handleOutput\"&gt;&lt;/base-div&gt; 最后今天我们重新了解了 v-model 只针对于表单控件数据的双向绑定，并且会默认占用一个属性和一个事事件。也通过v-model，我们得以在自己的组件实现双向绑定，基本类型和引用类型的处理机制也不太一样。 工作中也经常用到这种需要自定义双向绑定的场景，有时候写得次数太多，就想着能不能抽象出来复用。想想 mixins ， extend 都不太适合，因为会固定占用prop data 事件， 容易起冲突。目前觉得指令可以一试，不过还需要好好研究一下，希望下次的更新能定义一条全局指令——base-model。","categories":[{"name":"vue","slug":"vue","permalink":"https://fifth-patient.github.io/categories/vue/"}],"tags":[{"name":"vue-skill","slug":"vue-skill","permalink":"https://fifth-patient.github.io/tags/vue-skill/"}]},{"title":"vue技巧篇：我的浏览器也是“控制台”","slug":"control-pane","date":"2020-01-17T05:39:38.000Z","updated":"2020-01-27T12:18:06.128Z","comments":true,"path":"/post/control-pane/","link":"","permalink":"https://fifth-patient.github.io/post/control-pane/","excerpt":"前言写代码少不了，调试最简单方便的方法是控制台输出信息，如js的 control.log。可有时候我们要监听的变量是改动频繁，可能要多次使用control.log，控制台信息太多看得也容易乱。有一次查阅资料的时候，看到其他开发者使用pre标签直接在页面上打印变量，突然受到了一点感悟。 pre 和 $datahtml的pre标签并不常用，它可以保留原格式（空格和换行符），常用于表示源代码。有了pre我们很容易在页面上输出源码。此外，还需要vue的声明式渲染 —— ｛｛ x ｝｝ 或者是 v-text 指令。以及 vue 的 $data 实例属性，其实引用的是data对象属性的访问。 附：博客系统，不支持双括号，这里用 v-text代替，大部分情况下两者可以互换 说了那么多，其实只需要&lt;pre v-text=&quot;$data&quot;&gt;&lt;/pre&gt;,这一行就够了。好的，今天就到这里，大家再见。 …","text":"前言写代码少不了，调试最简单方便的方法是控制台输出信息，如js的 control.log。可有时候我们要监听的变量是改动频繁，可能要多次使用control.log，控制台信息太多看得也容易乱。有一次查阅资料的时候，看到其他开发者使用pre标签直接在页面上打印变量，突然受到了一点感悟。 pre 和 $datahtml的pre标签并不常用，它可以保留原格式（空格和换行符），常用于表示源代码。有了pre我们很容易在页面上输出源码。此外，还需要vue的声明式渲染 —— ｛｛ x ｝｝ 或者是 v-text 指令。以及 vue 的 $data 实例属性，其实引用的是data对象属性的访问。 附：博客系统，不支持双括号，这里用 v-text代替，大部分情况下两者可以互换 说了那么多，其实只需要&lt;pre v-text=&quot;$data&quot;&gt;&lt;/pre&gt;,这一行就够了。好的，今天就到这里，大家再见。 … 编写样式如果只是简单的方便调试，确实只需要上面一行代码就够了。只是本着折腾的命，觉得可以设计成一个组件，进行复用。就算设计成一个组件，实用性的不大，趣味性要多过实用性吧。 如果在实际开发中，直接单纯只写一行，调试使用的pre可能会被其他DOM元素的样式所铺盖。所以在编写组件前可以给这个pre写一点样式，先开头说的代码吧。 12345678910111213141516171819&lt;template&gt; &lt;pre v-text=\"$data\"&gt;&lt;/pre&gt;&lt;/template&gt;&lt;script&gt;import Package from '@/../package.json'export default &#123; name: 'views-skill-control-panel', data () &#123; return &#123; strong: '&lt;strong&gt;I \\'m strong&lt;/strong&gt;', debugger: true, arr: [1,2,3,4,5], package: Package &#125; &#125;&#125;&lt;/script&gt; 可能比官网入门实例还要简单，唯一有疑问的可能也就是 import 一个 json 文件进来， 这在es6 Modules中是允许的，相关资料请自行查阅。 ok，先看html部分，再看css。 html中，把data的属性都渲染到DOM上，并且html实体不会被转义，（v-text的功劳）。数组、对象也全被展开，不像在浏览器控制台是默认闭合的，而且key值也被加上双引号，这是JSON的格式。 内容上看非常友好，样式因为没写，非常朴素，但我们也不追求美感，能看就行，这里有几个因素影响了观看。 内容过长，高度容易溢出 默认定位，容易被其他元素遮挡 透明背景，深色背景观看费劲 字体样式会被通用样式影响 其实以上问题都是其他DOM元素影响pre的阅读观看，我们要固定，或者说通配一下pre的样式。让其在不同色彩表现、不同布局的页面降低其他DOM元素对自身的影响。 12&lt;!-- 模拟pre真实使用场景 --&gt;&lt;pre v-text=\"$data\" class=\"pre-panel\"&gt;&lt;/pre&gt; 123456789101112131415.pre-panel &#123; position: absolute; z-index: 999999; left: 20px; top: 20px; bottom: 20px; width: 380px; overflow: auto; background: rgba(0, 0, 0, .7); /* 建议半透明背景 */ color: #34ecff; /* 亮色的颜色即可 */ font-size: 16px; font-weight: normal; line-height: 20px; text-indent: 0;&#125; 以上css样式都是在多次实践中一行行增加，现已能适应大多数页面。 模拟pre真实使用场景，完整代码：传送门 即使在色彩强烈，内容纷乱的布局上，pre-panel仍然不影响阅读。 组件设计这个组件也非常简单，还是把一行代码还有样式抽象成一个组件，就基本完成了。不过考虑到扩展性，我们也可以考虑下给组件一些常用的配置选项。 第一步我们就是新建一个 control-panel.vue 文件，然后把刚才写的代码先复制过去。接下来复用就会发现 v-text=&quot;$data&quot; 使得每次复用绑定的都是自身组件的变量。我们这里应该使用插槽slot，然而每次插槽每次都要复用都要传值，我们更喜欢默认显示$data。然后再给指定插槽内容；当然这个 $data 是 control-panel 的父组件（引用control-panel的那个组件）而不是自己。 1234567&lt;template&gt; &lt;pre class=\"control-panel\"&gt; &lt;slot&gt; &#123;&#123; defaultProps &#125;&#125; &lt;/slot&gt; &lt;/pre&gt;&lt;/template&gt; 123456789101112export default &#123; computed: &#123; defaultProps () &#123; const parent = this.$parent if (parent &amp;&amp; parent.$data) &#123; return parent.$data &#125; else &#123; return this.$data &#125; &#125; &#125;&#125; 这是最小化的可配置使用组件，然后这样还不够。虽然 control-panel 不会被其他组件遮住了，可是他遮住了其他组件。所以在某些情况，我们希望它“挪一挪”自己的位置，增加几个props即可解决这个问题。 12345678910111213141516171819202122export default &#123; props: &#123; width: &#123; type: [String, Number], default: '380px' &#125;, position: &#123; type: String, validator: (val) =&gt; ['left', 'right'].indexOf(val) !== -1, default: 'left' &#125; &#125;, computed: &#123; currentWidth () &#123; if (typeof this.width === 'string') &#123; return this.width &#125; else &#123; return `$&#123;this.width&#125;px` &#125; &#125; &#125;&#125; 1234567/* 记得删除.control-panel的 left 属性！！ */.position-left &#123; left: 20px;&#125;.position-right &#123; right: 20px;&#125; 1234567891011&lt;template&gt; &lt;pre class=\"control-panel\" :style=\"&#123; width: currentWidth &#125;\" :class=\"[ &#123; 'position-left': position === 'left' &#125;, &#123; 'position-right': position === 'right' &#125; ]\"&gt;&lt;slot&gt;&#123;&#123; defaultProps &#125;&#125;&lt;/slot&gt; &lt;!-- 这里不换行是为了消除首行缩进 --&gt; &lt;/pre&gt;&lt;/template&gt; props只定义了3个，也有插槽，可以自定义，使用起来也不繁琐，方便了很多，不是吗？ 组件源码：传送门 复用-1：传送门 复用-2：传送门 当然还可以再进行扩展，只是没什么必要，如：随机color，交互设置样式和插槽内容；最好可以跟程序窗口一样可以最小化最大化关闭拖曳改变宽高.. 彩蛋设计一个组件，还要在实际项目中使用，可能因为各种现实因素影响，如果不喜欢组件的方式。（不想写，或者是嫌弃麻烦的）这里可以提供一个代码片段，需要的使用的直接复制粘贴即可。 123&lt;pre style=\"position: fixed; top: 20px; left: 20px; bottom: 20px; width: 200px; overflow: auto; z-index: 9999; font-size: 16px; line-height: 20px; color: skyblue; background: rgba(0, 0, 0, .7)\"&gt; &#123;&#123; formData &#125;&#125;&lt;/pre&gt; 什么？不想每次都复制一遍？想编辑器代码提示的功能一样打几个单词就帮你打一整段？好伐，我也是一个嫌弃麻烦的人，如果你跟我一样是用vs code 的话，那我们可以用 vs code 增加用户自定义的代码提示。 vs code 菜单： 文件 =&gt; 首选项 =&gt; 用户代码片段 =&gt; vue-html.json vue-html.json中增加这一段 12345678\"Print to pre dom\": &#123; \"prefix\": \"vuepre\", \"body\": [ \"&lt;pre style=\\\"position: fixed; top: 20px; left: 20px; bottom: 20px; width: 300px; overflow: auto; z-index: 9999; font-size: 16px; line-height: 20px; color: skyblue; background: rgba(0, 0, 0, .7)\\\"&gt;\", \" &#123;&#123; $1 $2 &#125;&#125;\", \"&lt;/pre&gt;\" ]&#125; 这样在*.vue的文件格式中，vs code 就支持对vuepre的代码提示了。 也直接直接拿我的 vue-html.json（传送门），使用任何文本编辑器打开，另存为：%APPData%\\Code\\User\\snippets\\vue-html.json 最后此本到这里就结束了，定义了一个可以监测变量的组件，相当于把控制台搬运到了网页，只是这个控制台是简化版的。只是很多开发者都很讨厌调试，因为只有自己的代码出现问题才会去调试。其实调试本来就是一件苦中作乐的事情，平时写的代码，都是为了满足各种需求，有时候写得并不自由。那么，我们在调试的时候，为何不使用一种更有趣味的方式去调试呢？起码这个时候自由度很高很高..","categories":[{"name":"vue","slug":"vue","permalink":"https://fifth-patient.github.io/categories/vue/"}],"tags":[{"name":"vue-skill","slug":"vue-skill","permalink":"https://fifth-patient.github.io/tags/vue-skill/"},{"name":"debugger","slug":"debugger","permalink":"https://fifth-patient.github.io/tags/debugger/"}]},{"title":"项目部署","slug":"deploy","date":"2020-01-16T16:30:34.000Z","updated":"2020-01-24T15:57:36.287Z","comments":true,"path":"/post/deploy/","link":"","permalink":"https://fifth-patient.github.io/post/deploy/","excerpt":"工作中实操过的项目部署记录，使用的是Ubuntu系统，nignx 和 C# 的运行环境均已安装。 前期配置文件准备12345678910111213141516# 以acs.HOST.cn举例 （HOST）为主域名# 项目路径/home/wwwroot/acs.xxx.cn# 从服务器下载文件配置文件（需要本机使用pscp或其他支持ftp协议的程序）pscp USERNAME@IP:/home/wwwroot/acs.HOST.cn/appsettings.json E:\\PATH# nginx 配置acs 所有项目(HOSTboss.conf)usr/local/nginx/conf/HOSTboss.conf# nginx 配置路径usr/local/nginx/conf/nginx.conf# 守护进程/etc/systemd/system/apps.acs.serive","text":"工作中实操过的项目部署记录，使用的是Ubuntu系统，nignx 和 C# 的运行环境均已安装。 前期配置文件准备12345678910111213141516# 以acs.HOST.cn举例 （HOST）为主域名# 项目路径/home/wwwroot/acs.xxx.cn# 从服务器下载文件配置文件（需要本机使用pscp或其他支持ftp协议的程序）pscp USERNAME@IP:/home/wwwroot/acs.HOST.cn/appsettings.json E:\\PATH# nginx 配置acs 所有项目(HOSTboss.conf)usr/local/nginx/conf/HOSTboss.conf# nginx 配置路径usr/local/nginx/conf/nginx.conf# 守护进程/etc/systemd/system/apps.acs.serive 配置nginx12345678910111213141516171819202122232425262728# 创建项目目录sudo mkdir /home/wwwroot/acs.HOST.cn# 设置文件夹权限为完全访问sudo chmod 777 acs.HOST.cn# 切换到nginx目录cd /usr/local/nginxcd ./conf# 上传项目配置# C:\\Users\\Admin\\Downloads\\pscp.exe.\\pscp.exe E:\\PATH\\HOSTboss.conf USERNAME@acs.HOST.cn:/home/wwwroot/acs.HOST.cn# 移动文件sudo mv HOSTboss.conf /usr/local/nginx/conf# 检查includesudo vim /usr/local/nginx/conf/nginx.conf# 检查证书 HOST.cn.key HOST.cn.pemls /usr/local/nginx/conf/cert# 测试 重载nginxcd /usr/local/nginxcd ./sbinsudo ./nginx -t # 测试sudo ./nginx -s reload # 重载 项目部署、守护进程123456789101112131415161718192021# 上传已打包的项目到服务器.\\pscp.exe E:\\PATH\\acs.HOST.cn\\FILENAME.zip USERNAME@acs.HOST.cn:/home/wwwroot/acs.HOST.cn# 解压cd /home/wwwroot/acs.HOST.cnsudo unzip -o FILENAME.zip# 检查证书 HOST.pfxls /home/wwwroot/acs.HOST.cn/# 移动守护进程配置文件到指定目录sudo mv ./apps.acs.service /etc/systemd/system# 定义守护进程sudo systemctl enable apps.acs.service# 开启进程sudo systemctl start apps.acs.service# 查看状态sudo systemctl status apps.acs.service 备注web服务器只需部署nginx sso boss mgt 部署成功，对外开放三个地址 https://sso.HOST.cn 单点登录 https://boss.HOST.cn 门户网站 https://mgt.HOST.cn 一体化管理中心","categories":[],"tags":[]},{"title":"vue的一些技巧","slug":"vue-skill","date":"2019-12-20T14:49:04.000Z","updated":"2020-01-24T15:57:36.351Z","comments":true,"path":"/post/vue-skill/","link":"","permalink":"https://fifth-patient.github.io/post/vue-skill/","excerpt":"v-if 获取 refs 问题先简单介绍下这两个指令： v-if 条件渲染 ref 返回组件实例或DOM元素 有时候我们需要在条件渲染的DOM节点上返回一个DOM对象或组件实例，可this.$refs.child 返回的是undefined。通过查阅文档得知: v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条块。$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。 如此可得： v-if 条件渲染： 惰性渲染，DOM、事件、组件会被销毁重建 ref 返回组件实例或DOM元素，非相应式","text":"v-if 获取 refs 问题先简单介绍下这两个指令： v-if 条件渲染 ref 返回组件实例或DOM元素 有时候我们需要在条件渲染的DOM节点上返回一个DOM对象或组件实例，可this.$refs.child 返回的是undefined。通过查阅文档得知: v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条块。$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。 如此可得： v-if 条件渲染： 惰性渲染，DOM、事件、组件会被销毁重建 ref 返回组件实例或DOM元素，非相应式 那么可推论得知v-if和ref的实现有冲突，v-show也是条件渲染，而它只是单纯切换元素css display属性值隐藏。如此可以使用v-show替代v-if。 总结：工作中常用的是v-if，可v-show也有v-if替代不了的时候，比如用于ref的DOM或组件；而v-if又可使用v-else、v-else-if，这两个指令也比较特殊，必须和v-if相邻，阅读代码时逻辑性更强。 $event —— 隐藏的函数参数vue的官方api文档，里详细地介绍了实例属性/方法，这些属性和方法都以美元符号$为前缀， $event并没有介绍；但在教程中， $event的定义是获取原生dom事件，实践中有时候其值并非是原生dom对象，而$event 又是可以隐性调用的，这使得$event的机制不那么直观。 基本使用使用v-on或@指令可以为dom元素绑定事件,函数没有参数时，$event被自动当作实参传入;函数带有参数时，最后一个参数必须显式传入$event 请自行准备一个组件：dollar-event.vue 1234567891011121314151617181920212223/* dollar-event.vue */// eg: 无参数&lt;button @click=\"handleClick\"&gt;$event empty param&lt;/button&gt;&lt;script&gt;handleClick ($event) &#123; console.log('dom事件：本组件事件') console.log($event) // 原生dom对象&#125;&lt;/script&gt;// eg：带有参数&lt;!-- 调换$event位置，爹妈不疼哦，不信你试试？ --&gt;&lt;button @click=\"handleParamClick('click', $event)\"&gt;$event with param&lt;/button&gt;&lt;script&gt;handleParamClick (value, $event) &#123; console.log(&#123; value, // 'click' $event // 原生dom对象 &#125;)&#125;&lt;/script&gt; 非常简单，就是有无参数的区别，可自定义事件($emit)机制就有两个含义了。 自定义事件($emit)$emit实例方法可以触发父组件的自定义事件，同时还可以传递一个参数给自定义事件接受；这个参数也可以是子组件的$event 请再准备一个组件：emit-event.vue 1234567891011121314151617181920212223242526272829/* emit-event.vue */&lt;button class=\"skill-emit-event\" @click=\"handleEmit\"&gt; &lt;slot&gt;emit-event&lt;/slot&gt;&lt;/button&gt;&lt;script&gt;handleEmit ($event) &#123; // 这里的$event同\"基本使用\"的第一段实例一样都是原生dom对象 this.$emit('dispatch', &#123; emitParams: $event, emitValue: 'dispatch emit-event' &#125;)&#125;&lt;/script&gt;/* dollar-event.vue */&lt;emit-event @dispatch=\"emitClick\"&gt;emit click&lt;/emit-event&gt;&lt;script&gt;import emitEvent from './emit-event'emitClick (emitEvent, $event) &#123; console.log(&#123; emitEvent, // &#123; emitParams: '子组件的$event', emitValue: 'dispatch emit-event' &#125; $event // emitEvent才是形参$event, 因此自己没有$event了，这里是undefined &#125;) console.log(emitEvent.emitParams.target) // &lt;button class=\"skill-emit-event\"&gt;&#125;&lt;/script&gt; 父组件的自定义事件有参数时也可结合$event一起使用，机制跟“基本使用”是一样的。 1234567891011/* dollar-event.vue */&lt;emit-event @dispatch=\"emitParamClick('val', $event)\"&gt;emit param click&lt;/emit-event&gt;&lt;script&gt;emitParamClick (val, $event) &#123; console.log(&#123; val, // 'val' $event // &#123; emitParams: '子组件的$event', emitValue: 'dispatch emit-event' &#125; &#125;)&#125;&lt;/script&gt; 示例代码：dollar-event 总结： 基本使用时函数无其他实参，可以不用传$event实参，有其他实参的时候，$event必须作为最后一个参数传入 自定义事件时使用，$event作为$emit的实参，若$emit不带参数，$event的值为undefined","categories":[],"tags":[{"name":"vue-skill","slug":"vue-skill","permalink":"https://fifth-patient.github.io/tags/vue-skill/"}]},{"title":"原型链是如何贯穿js的","slug":"prototype","date":"2019-04-28T06:32:00.000Z","updated":"2020-01-24T15:57:36.326Z","comments":true,"path":"/post/prototype/","link":"","permalink":"https://fifth-patient.github.io/post/prototype/","excerpt":"原型链是js的大动脉。 导读js的原型链难以避免要牵扯到面向对象，这里我们先简单说说原型还有原型链。之后我们说到面向对象的演变过程，会再次涉及到原型链，还有更多的东西。相信看完的读者会对JavaScript会有更深的认识。 原型对象本小节意在介绍js中几位朋友，读者只需要记住有它们的存在就行了，毕竟这几位朋友性格有点隐匿。 首先，我们要明白，声明一个对象，哪怕是空属性，js也生成一些内置的属性和方法。 12345678910111213141516171819/* 两种方法声明对象 */// 对象直接量var obj_1 = &#123;&#125;;// new关键字声明对象var obj_2 = new Object();// 在Object的原型对象添加属性Object.prototype.attr = 'myarr'console.log(obj_1); // &#123;&#125;console.log(obj_2); // &#123;&#125;// js中的恒等符号对函数来说只比较引用// obj_1.valuOf函数来源于Object.valueOf// 更准确来说是Object.protoype.valueOfconsole.log(obj_1.valueOf === Object.valueOf); // true// obj_1并未声明attr属性，通过Object.prototype继承得到attr属性console.log(obj_1.attr); // myarr","text":"原型链是js的大动脉。 导读js的原型链难以避免要牵扯到面向对象，这里我们先简单说说原型还有原型链。之后我们说到面向对象的演变过程，会再次涉及到原型链，还有更多的东西。相信看完的读者会对JavaScript会有更深的认识。 原型对象本小节意在介绍js中几位朋友，读者只需要记住有它们的存在就行了，毕竟这几位朋友性格有点隐匿。 首先，我们要明白，声明一个对象，哪怕是空属性，js也生成一些内置的属性和方法。 12345678910111213141516171819/* 两种方法声明对象 */// 对象直接量var obj_1 = &#123;&#125;;// new关键字声明对象var obj_2 = new Object();// 在Object的原型对象添加属性Object.prototype.attr = 'myarr'console.log(obj_1); // &#123;&#125;console.log(obj_2); // &#123;&#125;// js中的恒等符号对函数来说只比较引用// obj_1.valuOf函数来源于Object.valueOf// 更准确来说是Object.protoype.valueOfconsole.log(obj_1.valueOf === Object.valueOf); // true// obj_1并未声明attr属性，通过Object.prototype继承得到attr属性console.log(obj_1.attr); // myarr firefox控制台中空对象仍然有prototype属性 误区：每个浏览器的控制台输出都不太一样，Chrome和Edge并不显示prototype属性，因为我们并没有给obj_1的prototype属性定义任何属性和方法。 由于历代浏览器的更新和ECMAScript的修正，有时难以体现prototype和__proto__的存在，但我们的js代码能体现出它们的确是真实存在的。 prototype在这里称之为obj_1的原型对象，通过对象直接量和new关键字声明的对象都具有原型对象，继承自Object.prototype；几乎每个对象都有其原型对象，null是特例。 双对象实现原型继承需要原型对象是为了实现继承，但有了原型对象我们还无法把obj_1与Object.prototype链接起来。我们还需要另一个对象：__proto__，该属性能指向构造函数的原形属性constructor。一些老版本浏览器不识别，有些无法识别其内部信息，但不影响程序的正常运行。 obj_1的__proto__对象, 该属性下又有__proto__和constructor属性 12obj_1.__proto__ === Object.prototype // trueobj_1.__proto__.constructor === Object // true 这里有三个概念先行抛出 继承：继承使子类（超类）可拥有父类的属性和方法，子类也可添加属性和方法 父类：提供属性和方法被子类继承 子类：被父类继承的对象，可调用父类的属性和方法，也能定义属性和方法（父类无法调用） 通过Object.prototype.attr与obj_1.attr，我们可以看出 obj_1 (子类) 继承了 Object (父类)的原型对象的attr属性。正是因为obj_1的__proto__指向Object.prototype，obj_1继承了父类原型对象，使之拥有了attr属性。而子类的__proto__.constructor直接指向父类。 原型继承：每声明一个对象，其本身拥有用两个对象：原型对象(prototype)，与__proto__对象，原型对象即可供自身使用，子类继承后也可调用；自身的__proto__对象指向父类的原型对象，其constructor属性指向父类的构造函数。通过原型对象的方法实现继承，叫原型继承。 双对象与原型链综合以上，我们知道了使用原型对象prototype和__proto__对象可以实现继承的功能。那么我们是不是可以一直继承下去呢？ 1234567891011121314151617181920212223function People(name) &#123; this.name = name;&#125;function Engineer(type) &#123; this.type = type;&#125;Engineer.prototype = new People('Chris Chen'); // Engineer (子类)继承 People (父类)function Programmer(skill) &#123; this.skill = skill; this.showMsg = function () &#123; return 'Hi, my name is ' + this.name + ', I am a ' + this.type + ' engineer, I can write ' + this.skill + ' code!'; &#125;&#125;Programmer.prototype = new Engineer('front-end'); // Programmer (子类) 继承 Engineer (父类)var me = new Programmer('js');console.log(me); // Object &#123; skill: \"js\", showMsg: showMsg() &#125;console.log(me.showMsg()); // Hi, my name is Chris Chen, I am a front-end engineer, I can write js code! 代码看完，我们从子类开始解释，也就是从下往上的顺序： me是Programmer的实例化对象 Programmer的原型指向Engineer的实例对象 Engineer的原型指向People的实例对象 我们再来一张图说明其关系 这个.. 一盘煎蛋？？ 好伐，煎蛋就煎蛋，来，我们继续。 请注意重点：Programmer并无定义type, name属性，Programmer的showMsg中能显示this.name this.type分别来源于Engineer和Programmer的原型对象。很巧妙的一种属性搜索机制，自身的构造函数没有该属性，就从自身的原型对象中找，如果父类的原型对象没有，那么继续往父类的父类原型对象找，找到了就赋值；或直到没有父类，返回undefined；属性如此，方法也是同样的赋值机制。 说到底属性搜索机制就是原型链的一种具体体现，我们再上一张图。 所以原型链的关键字是继承和原型对象！！ 原型链：使用prototype和_proto_两个对象实现继承，由于是基于原型对象实现调用链，又称之为原型链。 关于原型链的第一步介绍就到这里，接下来我们从头开始，说说面向对象。 面向对象首先我们先来概述面向过程编程（opp）与面向对象（oop）。这是JS的两种编程范式，也可以理解为编程思想。顾名思义，两者的重心不同。下面我们使用两种方法创建dom并挂载于页面。 1234567891011121314151617181920212223242526272829303132/* 面向过程 */// 1. 定义domvar dom = document.createElement('div');// 2. 设置dom属性dom.innerHTML = '面向过程';dom.id = 'opp';dom.style = 'color: skyblue';// 3. 挂载dmovar container = document.getElementById('container');container.appendChild(dom);/* 面向对象 */// 1. 定义构造函数function CreateElement(tagName, id, innerText, style) &#123; var dom = document.createElement(tagName); dom.innerHTML = innerText; dom.id = id; dom.style = style; this.dom = dom;&#125;// 2. 定义原型对象上的方法CreateElement.prototype = &#123; render: function (dom) &#123; var container = document.getElementById(dom); container.appendChild(this.dom); &#125;&#125;// 实例化对象var innerBox = new CreateElement('div', 'oop', '面向对象', 'color: pink;');// 调用原型方法innerBox.render('container'); 面向过程比较流水线，更注重程序的实现过程，面向对象的程序由一个又一个的单位————对象组成，不关心对象的内部属性和方法，只需实例化，调用方法即可使用。 或许上面的例子，还不是很有力得体现出两者的区别，那么如果现在，需要挂载多个元素呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 面向过程 */// var dom_1 = document.createElement('div');// dom_1.innerHTML = '面向过程_1';// dom_1.id = 'opp-1';// dom_1.style = 'color: skyblue';// var dom_2 = document.createElement('div');// dom_2.innerHTML = '面向过程_2';// dom_2.id = 'opp-2';// dom_2.style = 'color: skyblue;';// var container = document.getElementById('container');// container.appendChild(dom_1);// container.appendChild(dom_2);/* 这种方法傻的可爱，我们包装成函数吧 */function createElement(tagName, id, innerText, style) &#123; var dom = document.createElement(tagName); dom.innerHTML = innerText; dom.id = id; dom.style = style; return dom;&#125;var container = document.getElementById('container');var box_1 = createElement('div', 'oop-1', '面向过程_1', 'color: skyblue;');var box_2 = createElement('div', 'oop-2', '面向过程_2', 'color: skyblue;');container.appendChild(box_1);container.appendChild(box_2);/* 面向对象 */function CreateElement(tagName, id, innerText, style) &#123; var dom = document.createElement(tagName); dom.innerHTML = innerText; dom.id = id; dom.style = style; this.dom = dom;&#125;CreateElement.prototype = &#123; render: function (dom) &#123; var container = document.getElementById(dom); container.appendChild(this.dom); &#125;&#125;var innerBox_1 = new CreateElement('div', 'oop-1', '面向对象_1', 'color: pink;');innerBox_1.render('container');// 这里只需再实例化一个对象调用render方法即可var innerBox_2 = new CreateElement('div', 'oop-2', '面向对象_2', 'color: pink;');innerBox_2.render('container'); 重复调用同样的方法，面向过程如果不包装一个函数，显得代码很冗余且愚蠢，而面向对象只需再次实例化即可。这里也提醒我们平时写代码的时候要考虑复用性。 好的，那我们现在需要给dom元素添加一些交互功能，又要怎么做？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 面向过程 */function createElement(tagName, id, innerText, style, event, fn) &#123; var dom = document.createElement(tagName); dom.innerHTML = innerText; dom.id = id; dom.style = style; // 直接修改内部函数 dom.addEventListener(event, fn); return dom;&#125;var container = document.getElementById('container');var box_1 = createElement('div', 'oop-1', '面向过程_1', 'color: skyblue;', 'click', function (e) &#123; alert(e.target.innerHTML);&#125;);// 过于死板，就算没有传参dom.addEventListener也会调用两次var box_2 = createElement('div', 'oop-2', '面向过程_2', 'color: skyblue;');container.appendChild(box_1);container.appendChild(box_2);/* 面向对象 */function CreateElement(tagName, id, innerText, style) &#123; var dom = document.createElement(tagName); dom.innerHTML = innerText; dom.id = id; dom.style = style; this.dom = dom;&#125;CreateElement.prototype = &#123; render: function (dom) &#123; var container = document.getElementById(dom); container.appendChild(this.dom); &#125;, // 在原型对象上添加方法 addMethod: function (event, fn) &#123; this.dom.addEventListener(event, fn); &#125;&#125;var innerBox_1 = new CreateElement('div', 'oop-1', '面向对象_1', 'color: pink;', 'click');innerBox_1.render('container');var innerBox_2 = new CreateElement('div', 'oop-2', '面向对象_2', 'color: pink;', 'click');innerBox_2.render('container');// 根据场景需求决定是否调用addMethod方法innerBox_2.addMethod('click', function (e) &#123; alert(e.target.innerHTML);&#125;) 从这里可以我们看出两者的扩展方法截然不同，面向过程模式需要直接在函数中修改，而面向对像在原型对象上直接追加方法。 面向对象比面向过程有更高的复用性和扩展性。 PS：面向过程也并非一无是处，比面向对象更直观化，也更理解。若不需要考虑太多的因素，使用面向过程开发反而效率会更快。 创建对象把大象关进冰箱需要几步在下并不清楚。不过要想进行面向对象开发，第一步是先创建一个对象，js中有6种方法可创建对象： new 操作符 字面量 工厂模式 构造函数 原型模式 混合模式（构造+原型） 工厂模式前两种方法在开头已使用，这里不再复述。如果要创建多个相同的对象，使用前两种方法，会产生大量重复的代码，而工厂模式解决了这个问题.. 123456789101112131415161718function factoryMode(name, age) &#123; var obj = new Object(); obj.name = name; obj.age = age; obj.say = function () &#123; return this.name + ' has ' + this.age + ' years old!'; &#125; return obj;&#125;var guest = factoryMode('Gentleman', 25);var Chris = factoryMode('Chris', 20);console.log(guest.say()) // Gentleman has 25 years old!console.log(Chris.say()) // Chris has 20 years old!console.log(guest instanceof Object); // trueconsole.log(Chris instanceof Object); // ture... 有点赞哦，这样重复实例化多个对象也不怕了，对象识别问题仍然没解决 PS:new Object()已决定了工厂模式的实例是由Object实例化而来的，其对象类型是Object，Date Array有对应的对象类型，这里读者可以试试new Array instanceof Array等原生数据类型。 工厂模式是面向对象中常见的一种设计模式，是一个可以重复实例化多个对象的函数，但识别对象无能为力。 构造函数我们可以把工厂模式修改一下，就可以写出一个构造函数.. 12345678910111213141516function ConstructorMode(name, age) &#123; this.name = name; this.age = age; this.say = function () &#123; return this.name + ' has ' + this.age + ' years old!'; &#125;&#125;var guest = new ConstructorMode('Gentleman', 25);var Chris = new ConstructorMode('Chris', 20);console.log(guest.say()) // Gentleman has 25 years old!console.log(Chris.say()) // Chris has 20 years old!console.log(guest instanceof Object); // trueconsole.log(guest instanceof ConstructorMode); // trueconsole.log(ConstructorMode instanceof Object); // true 有几个地方不太一样： 没有显示创建对象 属性/方法赋值给this 使用new关键字调用 无return 可以看出实现了跟工厂模式一样的功能，那么什么是构造函数呢？ 构造函数也是一个函数，跟工厂模式一样可重复实例化对象。为了跟普通函数区分，函数名首字母一般是大写的。 使用该函数时需要使用new关键字实例化；不使用new实例化，该构造函数表现如同普通的函数。 虽然没有显示创建对象，但在new实例化时，后台执行了new Object() 使用this是因为，构造函数的作用域指向实例化对象，即：两次实例化，ConstructorMode中的this分别指向Guest, Chris。 通过上面的instanceof判断，我们能识别出guest是由ConstructoreMode实例化的，与此同时 guest 也是 Object 的实例对象。构造函数也有其弊端，声明在构造函数内的属性叫“构造属性”，问题就在于：构造属性若是引用类型（以函数为例），实例化后的函数执行的动作虽然是相同的，但引用地址不同，我们并不需要两份同样的函数。 1console.log(Chris.say == guest.say); // false 构造函数模式：构造函数是一个需要实例化调用的函数，内部作用域指向实例对象，无须return。构造函数模式，也可实例化大量重复对象，也可识别实例化后的对象是由哪个构造函数实例化而来。其缺点是：若在构造属性中声明函数，实例化后的各个对象引用地址保持独立。 原型模式原型模式靠原型对象发挥作用，原型对象开头已有介绍。 123456789101112131415161718function PrototypeMdoe() &#123;&#125;// 直接在原型对象声明，直面量形式PrototypeMdoe.prototype.mode = 'prototype';PrototypeMdoe.prototype.do = function (name) &#123; return 'we do the something same, ' + name + '.';&#125;var guest = new PrototypeMdoe();var Chris = new PrototypeMdoe();console.log(guest.do('guest')) // we do the something same, guest.console.log(Chris.do('Chris')) // we do the something same, Chris.console.log(guest.do === Chris.do) // true，相同的引用指针console.log(guest.do('guest') === Chris.do('Chirs')) // false， 返回值不相等console.log(guest.prototype === Chris.prototype) // 指向相同的原型对象 实例化对象do方法引用指针是相同的，所以如果是需要给所有实例化对象共享的方法，可在原型上直接声明。guest和Chris都由同一个构造函数的实例化，原型对象的指针地址相同。 也可以使用对象字面量的方法，两者有点的区别：对象字面量声明的原型constructor会指向Object，我们也可以手动设置。 12345678910111213141516171819function PrototypeMdoe() &#123;&#125;// 对象字面量，原型赋值为对象PrototypeMdoe.prototype = &#123; // 手动设置构造函数指针 // constructor: PrototypeMdoe, run: function () &#123; return 'I;m running!' &#125;&#125;var proto = new PrototypeMdoe()// 打开constructor的注释对比运行结果console.log( proto.constructor === PrototypeMdoe, proto.constructor === Object ) 原型模式：共享是原型对象的特点，所有声明在原型上的属性和方法都会被所有实例化对象继承，且指向同一个引用地址。 原型属性是基本类型的数据，共享很方便；如果是引用类型的数据，共享将带来麻烦。由于引用地址相同，更改其中一个实例的原型属性，其他实例的原型也随之改变。 1234567891011function PrototypeMdoe() &#123;&#125;PrototypeMdoe.prototype.arr = [1, 2, 3, 4, 5];var proto_1 = new PrototypeMdoe();var proto_2 = new PrototypeMdoe();console.log(proto_1.arr) // [1,2,3,4,5]proto_1.arr.splice(1, 2) // [2,3,4]console.log(proto_2.arr) // [1,5] Object.definedPeroperty：ES5语法，可定义新属性或修改现有属性并返回改对象；第三个参数为属性描述符，能精确添加或修改对象的属性：枚举性、属性值、可写性、存取设置。 12345678910111213141516171819var Obj = &#123; attr: 'obj'&#125;Obj.prototype = &#123; run: function (name) &#123; return name + ' run!'; &#125;&#125;// 使用Object.definedPeroperty设置constructor的特性Object.defineProperty(Obj.prototype, 'constructor', &#123; configurable: true, // 设置为ture下面的设置才能生效 // enumerable: false, // 枚举性 // writable: false, // 可写性 // get: undefined, // 取值器 // set: undefined, // 设置器 value: Obj // 属性值&#125;) isPrototypeOf函数可以判断原型对象是否为某个实例的原型对象。 1234console.log( PrototypeMdoe.prototype.isPrototypeOf(proto_1), // true Array.prototype.isPrototypeOf(proto_1) // false) 混合模式混合模式是组合构造函数和原型模式使用，这是最常用的一种设计模式了。 构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。所以每个实例都会有自己的一份实例属性的副本，但同时共享着对方法的引用。最大限度的节省了内存。同时支持向构造函数传递参数。 12345678910111213function CreateObject (name, age) &#123; this.name = name; this.age = age;&#125;CreateObject.prototype.say = function () &#123; return this.name + ' has ' + this.age + ' years old!';&#125;var guest = new CreateObject('Gentleman', 25);var Chris = new CreateObject('Chris', 20);console.log(guest.say()) // Gentleman has 25 years old!console.log(Chris.say()) // Chris has 20 years old! hasOwnProperty可检测一个属性是否为实例属性。而in可判断属性是否存在本对象中，包括实例属性或者原型属性。 123456789101112131415console.log(guest.hasOwnProperty('name')) // trueconsole.log(guest.hasOwnProperty('say')) // falseconsole.log('name' in guest) // trueconsole.log('say' in guest) // true// 判断是否为原型属性function isProperty(object, property) &#123; debugger return !object.hasOwnProperty(property) &amp;&amp; property in object;&#125;console.log(isProperty(guest, 'name'))console.log(isProperty(guest, 'say')) 创建对象的六种方法就到这里了，另外还有动态原型、寄生构造、稳妥构造函数。 这三种模式都是基于混合模式的改良，感兴趣的可以随便看看：点我查看 动态原型 原型模式中，不管我们是否调用原型的方法，都会初始化原型中的方法，并且声明一个构造函数时，构造函数和原型对象是分开声明的，略显怪异。我们可以使用动态原型模式，把构造函数和原型对象封装到一起。 12345678910111213141516function CreateObject (name,age) &#123; this.name = name; this.age = age; // 动态创建原型属性，仅在第一次调用时初始化 if (typeof this.say !== 'function') &#123; CreateObject.prototype.say = function () &#123; return this.name + ' has ' + this.age + ' years old!'; &#125; &#125;&#125;var guest = new CreateObject('Gentleman', 25);var Chris = new CreateObject('Chris', 20);console.log(guest)console.log(guest.say()) // Gentleman has 25 years old!console.log(Chris.say()) // Chris has 20 years old! 寄生构造 稳妥构造函数 #other-create { border: 5px solid #aaa; } ;(function() { var showOtherCreate = true; var creatObject = document.getElementById('create-object'); creatObject.addEventListener('click', function() { var otherCreate = document.getElementById('other-create'); if (showOtherCreate) { otherCreate.style.display = 'block'; creatObject.innerText = '不想看了'; } else { otherCreate.style.display = 'none'; creatObject.innerText = '点我查看'; } showOtherCreate = !showOtherCreate; }) })(); 动态原型寄生构造未完待续","categories":[],"tags":[]},{"title":"es6主要特性小结","slug":"es6-main","date":"2019-04-11T06:58:51.000Z","updated":"2020-01-24T15:57:36.295Z","comments":true,"path":"/post/es6-main/","link":"","permalink":"https://fifth-patient.github.io/post/es6-main/","excerpt":"ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。 Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。 let：let实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块（花括号）内有效；与var的区别是，var用来做循环的计数变量，会泄露成全局变量，在外部调用的值是循环完成后的值。 const：声明变量，但声明的是常量，一旦声明，常量的值不能改变。","text":"ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。 Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。 let：let实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块（花括号）内有效；与var的区别是，var用来做循环的计数变量，会泄露成全局变量，在外部调用的值是循环完成后的值。 const：声明变量，但声明的是常量，一旦声明，常量的值不能改变。 class：定义一个类，可定义构造方法在其中，构造方式this关键字指向实例。constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 extends：class之间可用extends关键字实现继承 super：指代父类的实例（即父类的this对象）。子类必须在constructor中调用·方法，否则新建实例就会报错，因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 arrow function：箭头函数 (i)=&gt; i+1;箭头函数体内的this对象指向定义时所在的对象（箭头函数内无自己的this，其this继承外面的作用域） template string：用反引号（ &#96; ）来标识起始，用${}来引用变量，所有的空格和缩进都会被保留在输出之中 destructuring：从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 12345678910// 解构let cat = 'ken'let dog = 'lili'let zoo = &#123;cat, dog&#125;console.log(zoo) //Object &#123;cat: \"ken\", dog: \"lili\"&#125;// 赋值let dog = &#123;type: 'animal', many: 2&#125;let &#123; type, many&#125; = dogconsole.log(type, many) //animal 2 default：变量未赋值时给该变量一个默认值 1234function animal(type = 'cat') &#123; console.log(type)&#125;animal() //cat rest：过滤变量 1234function animals(once, ...types)&#123; console.log(types)&#125;animals('cat', 'dog', 'fish') //[ \"dog\", \"fish\"] import export：es6的模块化机制， import用于导入模块，可以选择性导入模块中的一部戏属性/方法，也可给导入的模块重命名；export用于导出模块，也多次导出，任何数据类型都可导出（变量、函数、类等..）。 基本使用123456//index.jsimport animal from './content'console.log(animal) // A cat//content.jsexport default 'A cat' 多次导出，导入模块时使用 as 重命名 type 为 animalType123456789101112//content.jsexport default 'A cat'export function say()&#123; return 'Hello!'&#125;export const type = 'dog';//index.jsimport animal, &#123; say, type as animalType &#125; from './content'let says = say()console.log(`The $&#123;animalType&#125; says $&#123;says&#125; to $&#123;animal&#125;`)//The dog says Hello to A cat","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"https://fifth-patient.github.io/tags/es6/"}]},{"title":"web安全基础","slug":"web-safe","date":"2019-04-08T14:02:34.000Z","updated":"2020-01-24T15:57:36.361Z","comments":true,"path":"/post/web-safe/","link":"","permalink":"https://fifth-patient.github.io/post/web-safe/","excerpt":"SQL注入通过把SQL命令插入到web表单提交或者页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令 防范SQL注入1.校验用户输入的参数，限制其长度或转义单引号或双连字符2.使用参数化SQL或直接使用存储过程进行数据查询存取3.每个应用使用单独的权限有限的数据库连接，不使用管理器权限连接数据库4.机密信息不明文存放，加密或hash掉密码和敏感信息 XSS跨站脚本攻击(Cross Site Scripting)，缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。","text":"SQL注入通过把SQL命令插入到web表单提交或者页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令 防范SQL注入1.校验用户输入的参数，限制其长度或转义单引号或双连字符2.使用参数化SQL或直接使用存储过程进行数据查询存取3.每个应用使用单独的权限有限的数据库连接，不使用管理器权限连接数据库4.机密信息不明文存放，加密或hash掉密码和敏感信息 XSS跨站脚本攻击(Cross Site Scripting)，缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 原理攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）。诱使受害者打开受到攻击的服务器URL。受害者在Web浏览器中打开URL，恶意脚本执行。 攻击方式 反射型：发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS随响应内容一起返回给浏览器，最后浏览器解析执行XSS代码，这个过程就像一次发射，所以叫反射型XSS。 存储型：存储型XSS和反射型的XSS差别就在于，存储型的XSS提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。 防御措施 编码：对用户输入的HTML实体进行编码 过滤：移除用户上的DOM属性，如onerror等，移除用户上传的style、script、iframe节点 校正：避免直接对HTML实体编码，使用DOM Prase转换，校对不配对的DOM标签 cookie：避免直接在cookie 中泄露用户隐私，例如email、密码等等。通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。 如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie 。 CSRFCSRF跨站点请求伪造(Cross—Site Request Forgery) 跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。 完成一次CSRF攻击，受害者必须依次完成以下两个步骤： 登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。 看到这里，你也许会问：“如果我不满足以上两个条件中的一个，我就不会受到CSRF攻击”。是滴，确实如此，但是你不能保证以下情况不会发生： 你不能保证你登录了一个网站之后，不再打开一个tab页面并访问其它的网站（黄网）。 你不能保证你关闭浏览器之后，你本地的Cookie立刻过期，你上次的会话已经结束。 上述中所谓的攻击网站，可能就是一个钓鱼网站或者黄色网站。 防御CSRF攻击： 通过 referer、token 或者 验证码 来检测用户提交。 尽量不要在页面的链接中暴露用户隐私信息。 对于用户修改删除等操作最好都使用post 操作 。 避免全站通用的cookie，严格设置cookie的域。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://fifth-patient.github.io/tags/web/"}]},{"title":"浏览器结构","slug":"browser","date":"2019-03-28T18:02:01.000Z","updated":"2020-01-24T15:57:36.245Z","comments":true,"path":"/post/browser/","link":"","permalink":"https://fifth-patient.github.io/post/browser/","excerpt":"简单来说浏览器可以分为两个部分，shell+内核，其中shell的种类比较多，内核的种类则比较少。 Shell是指浏览器外壳：菜单、工具栏等；主要提供给用户操作，参数设置等，调用内核实现各种功能。 内核是浏览器的核心，基于标记语言显示内容的程序或模块。可分两部分，渲染引擎和JS引擎，负责渲染网页内容，计算网页的显示方式，不同内核的渲染效果不同。JS引擎则执行javascript实现网页的动态效果。","text":"简单来说浏览器可以分为两个部分，shell+内核，其中shell的种类比较多，内核的种类则比较少。 Shell是指浏览器外壳：菜单、工具栏等；主要提供给用户操作，参数设置等，调用内核实现各种功能。 内核是浏览器的核心，基于标记语言显示内容的程序或模块。可分两部分，渲染引擎和JS引擎，负责渲染网页内容，计算网页的显示方式，不同内核的渲染效果不同。JS引擎则执行javascript实现网页的动态效果。 组件浏览器一般由以下组件构成：1.用户界面：包括地址栏、前进/后退按钮、书签菜单等。2.浏览器引擎：在用户界面和呈现引擎之间传送指令。3.呈现引擎：负责显示请求的内容，解析html和css内容，显示在屏幕上、4.网络：用于网络调用，比如HTTP请求，其接口与平台无关，并为所有平台提供底层实现。5.用户界面后端：绘制基本的窗口小部件，比如组合框和窗口。 其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。6.JavaScript解析器：解析执行JavaScript代码。7.数据存储：持久层。实现了Cookie，web Stroage、indexDB的功能支持。 Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://fifth-patient.github.io/tags/浏览器/"}]},{"title":"跨域","slug":"cross-domain","date":"2019-03-28T18:00:33.000Z","updated":"2020-01-24T15:57:36.275Z","comments":true,"path":"/post/cross-domain/","link":"","permalink":"https://fifth-patient.github.io/post/cross-domain/","excerpt":"同源策略源：源由协议，域名和端口号组成，若url地址的协议、域名和端口号均相同则属于同源。 同源策略：浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对象自资源。其阻止的是数据的接受而不是请求的发送 不受同源策略限制：页面中的链接，重定向以及表单提交；可以引入跨域资源，但js不能读写加载内容。 如嵌入到页面中的&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;等。 跨域：受同源策略的限制，不同源的脚本不能操作其他源下面的对象，想操作另一个源下面的对象就是跨域。","text":"同源策略源：源由协议，域名和端口号组成，若url地址的协议、域名和端口号均相同则属于同源。 同源策略：浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对象自资源。其阻止的是数据的接受而不是请求的发送 不受同源策略限制：页面中的链接，重定向以及表单提交；可以引入跨域资源，但js不能读写加载内容。 如嵌入到页面中的&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;等。 跨域：受同源策略的限制，不同源的脚本不能操作其他源下面的对象，想操作另一个源下面的对象就是跨域。 实现方式： document.domain JSONP CORS window.name postMessage H5 需要跨域的场景： 上传图片、文件 富文本编辑器 页面请求第三方接口 降域 document.domain 将两个不同源的域名document.domain设置为同一个即可；存在安全性问题，一个网站被攻击，另一个也有安全漏洞，只适用于cookie和iframe窗口。 跨域资源共享 CORS 设置服务器响应头 Access-Control-Allow-Origin 指定允许跨域的源，实现浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 JSON with Padding JSONP 动态插入script标签，通过script标签引入一个js文件， 在服务端输出JSON数据，客户端执行回调函数，从而解决了跨域的数据请求。 jsonp+padding–将json填充到一个盒子里，（使用回调函数获取json数据）；兼容性好，简单易用，支持浏览器与服务器双向通信。当然也有一些缺点：权限漏洞，只能发送GET请求，需要防止XSS。 window.name 一个窗口的声明周期内，窗口载入的所有页面都是共享一个name属性的，每个页面都对window.name有读写权限，其属性持久存在，不因新页面载入而进行充值。 在原页面中使用一个隐藏的iframe充当中间人角色，由iframe去获取数据，src设为目标页面，再把src设置跟原页面同一个域，否则受到同源策略的限制。原页面再去得到iframe获取到的数据，iframe的window.name。 postMessage H5提供的一个API","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://fifth-patient.github.io/tags/web/"}]},{"title":"从HTTP到互联网协议，浏览器与服务器之间不得不说的故事","slug":"http","date":"2019-03-28T09:19:26.000Z","updated":"2020-01-24T15:57:36.296Z","comments":true,"path":"/post/http/","link":"","permalink":"https://fifth-patient.github.io/post/http/","excerpt":"浏览器与服务器之间美好约定 过桥米线的传说相传，清朝时滇南蒙自市城外有一湖心小岛，一个秀才到岛上读书，秀才贤慧勤劳的娘子常常弄了他爱吃的米线送去给他当饭，但等出门到了岛上时，米线已不热了。后来一次偶然送鸡汤的时候，秀才娘子发现鸡汤上覆盖着厚厚的那层鸡油有如锅盖一样，可以让汤保持温度，如果把佐料和米线等吃时再放，还能更加爽口。于是她先把肥鸡、筒子骨等熟好清汤，上覆厚厚鸡油;米线在家烫好，而不少配料切得薄薄的到岛上后用滚油烫熟，之后加入米线，鲜香滑爽。此法一经传开，人们纷纷仿效，因为到岛上要过一座桥，也为纪念这位贤妻，后世就把它叫做”过桥米线”。","text":"浏览器与服务器之间美好约定 过桥米线的传说相传，清朝时滇南蒙自市城外有一湖心小岛，一个秀才到岛上读书，秀才贤慧勤劳的娘子常常弄了他爱吃的米线送去给他当饭，但等出门到了岛上时，米线已不热了。后来一次偶然送鸡汤的时候，秀才娘子发现鸡汤上覆盖着厚厚的那层鸡油有如锅盖一样，可以让汤保持温度，如果把佐料和米线等吃时再放，还能更加爽口。于是她先把肥鸡、筒子骨等熟好清汤，上覆厚厚鸡油;米线在家烫好，而不少配料切得薄薄的到岛上后用滚油烫熟，之后加入米线，鲜香滑爽。此法一经传开，人们纷纷仿效，因为到岛上要过一座桥，也为纪念这位贤妻，后世就把它叫做”过桥米线”。 好的，故事就这里。 HTTP..协议？首先我们先来简单了解下什么是HTTP协议。 浏览器，大家都不陌生。地址栏输入一个网址，对应的网页就会跳出来，那么，这个网页是怎么来的呢？是浏览器自己弄出来的吗？显然不是，网站的所有资源都源于服务器；浏览器只是拿到服务器的资源，“翻译”一下给呈现给用户。那么，浏览器是通过什么方式告诉服务器我需要这个网页，而服务器又怎么知道浏览器需要的是哪个页面？浏览器与服务器的交互有很多种，最常见的一种是HTTP请求，即—–HTTP协议。 HTTP协议约定了两者之间的沟通方式，才不会牛头马嘴。协议由请求（requset）与响应（reponse）触发。 HTTP是因特网上一种常见的数据传输协议 服务器：说起来你可能不信，是它先动手的！ 事务，URL，报文接下来我们来了解下HTTP协议的体现过程。 浏览器的地址栏输入网址，将会发送一个HTTP请求；服务器收到浏览器的请求，响应数据给浏览器；浏览器解析资源渲染到界面。这种通信方式使用HTTP报文的格式化数据块进行。至此，一条完整的请求和响应命令，整个过程称之为HTTP事务。 浏览器凭借着URL，准确地请求资源，服务器响应并传输回数据。每个web服务器资源都有一个名字——统一资源标识符（url）。有了这个名字，浏览器才能找到对应的资源，url有特定的标准格式。一个url分为3个部分：协议代码，装由所需文件的计算机地址和主机资源的具体位置。scheme://host[:post]/path/filename scheme - 协议名称 host - IP地址或计算机名称 post - 服务器端口 path - 文件路径 filename - 文件名 例：http://www.4399.com/ PS：我们说的“网址”、“域名”都属于url的范畴。 以HTTP的角度讲，浏览器（Browser）是客户端（Client），服务器（Server）是服务端（Server）；也就是说浏览器和服务器模式是B/S结构，即：Browser/Server(浏览器/服务器)结构。 客户端发送请求报文，服务器回复响应报文；请求报文和响应报文的格式都由以下三个部分组成 起始行：由方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔 首部字段：由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔，关于请求/响应的信息 主体：要发送给服务器的请求数据，或是服务器回复的响应数据 一个简单的HTTP实例 图源于《HTTP权威指南》 详解请求报文和响应报文请求报文和响应报文的差异不大，可以对比了解。 请求报文 响应报文 说明 起始行 请求行：请求url、HTTP版本、请求方法 响应行：HTTP版本，状态码， 状态码短语 用空格分隔 首部字段 请求头：数量不定，关于客户端的请求信息 请求行：关于服务器的响应信息 特定的分类用于请求头或用于响应头 主体 请求主体：一般是POST方法的请求数据 响应主体：HTTP响应请求的真正数据 HTTP所传输的内容 方法与状态码即使是同一个url，如果使用了其他的请求方法，服务器没有为url设置相对应的响应方法，那浏览器也不会拿到正确的资源，可能会出现的是几个数字（状态吗）和一句短语（原因短语）； https://fifth-patient.github.io/_ 404代表了什么？ 因此最后小节我们有必要学习HTTP的请求方法和状态码。 根据HTTP标准，HTTP请求定义了多种请求方法，在不同场景下执行不同的动作，常见的有…GET：向服务器请求资源（最常用的HTTP方法）POST：输入数据（一般用于用户登录，付款等）PUT：写入文档（更新数据，发表文章，评论等）DELETE：删除请求资源（删除资源，但服务器不一定会删除） 为了便于理解，我们拿两个使用频率最高的方法比较一下。 GET与POST的区别 便利：浏览器后退对GET请求无影响，浏览器主动缓存GET请求，而POST不缓存且后退历史再次提交请求 参数：GET请求参数记录在原url后且有长度限制，而POST中的参数记录在请求主体中 安全：GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息 编码：GET请求只能进行url编码，而POST支持多种编码方式 状态码：三位数字组成，第一个数字定义了响应的类别，且有五种可能取值 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 短语：对状态码的描述，帮助用户理解状态码原因 以下是常见的响应状态码和短语 200 OK //客户端请求成功 304 Not Modified //请求资源的缓存可以使用，响应缓存的文件 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 以该url - https://fifth-patient.github.io/_ 为例，这个地址是没有任何资源的，故服务器返回了404提示我们Not Found，原因可能是：之前的资源被删除了，所以这里没有资源了亦或者根本就没有资源。这里我们只是单纯网址最后打多了一个_而已。 唧唧歪歪了那么多，我们再结合开头的故事小结一下。 《过桥米线》中，娘子送米线给丈夫，丈夫食用完娘子回家；类似浏览器与服务器之间使用请求和响应完成一个HTTP事务 米线是娘子送给丈夫的午餐；而则浏览器使用HTTP报文这种格式发送数据供服务器响应，报文只是格式，为的是发送数据 娘子曾尝试赶马车送餐，不过米线还是凉了；正如HTTP有多种请求方法，合理使用请求方法服务器方可正确响应资源 恭喜读者了解了HTTP协议的一些基本概念，想深入探索的的朋友请往下看… HTTP背后的组织很高兴读者继续下划，那么现在我们已经认识了HTTP这位朋友，（从读者学会网上冲浪的那一刻，它就一直在你身边），接下来我们来认识一下这位朋友所在的组织互联网协议。 《名侦探柯南》中的琴酒，黑衣组织（酒厂）的高级成员，可以得到“那位先生”的直接命令。 HTTP也并非单枪作战，背后也犹如琴酒背后的酒厂，那么我们来介绍下“酒厂”。 互联网协议，五层模型什么是互联网？ 互联网（英语：Internet），是21世纪之始网络与网络之间所串连成的庞大网络，这些网络以一组标准的网络TCP/IP协议族相连，连接全世界几十亿个设备，形成逻辑上的单一巨大国际网络。 ——wiki百科 ……这，也太概念化了吧？？ 简单一句话：世界上所有的网络组成起来就是互联网。 PS：互联网、因特网、万维网的概念之后再讨论，本篇文章的重要在于HTTP。 五层模型所有的网络环境组成了互联网，所以互联网很庞大，从模型上有3种分层方式： OSI分层 （7层） TCP/IP分层（4层） 五层协议 （5层） 就像“酒厂”一样，一个优秀的暗杀组织，肯定结构清晰，分工明确；伏特加跟着琴酒清除卧底，然后其他人不是卧底就是渣渣，是的，结构清晰，谁是大反派谁是卧底谁是渣一下子就看出来了；分工明确，琴酒一个人为组织拼死拼活，伏特加给琴酒开车，其他人，其他人.. 不知道琴酒先生会怎么想？ 琴酒：酒厂都是假酒，这活没法干了!(摔酒瓶) 这里我们主要说说五层模型。 五层模型将互联网分成了5个层，每一个层都定应了很多协议，所有的协议都是互联网协议。 应用层(Application Layer): 规定应用程序的数据格式。 应用程序协议传输层(Transport Layer): 建立”端口到端口”的通信 UDP协议 TCP协议网络层(Network Layer)： 建立”主机到主机”的通信 IP协议 ARP协议链接层(Link Layer)：在“实体层”上方，确定了0和1的分组方式 以太网协议实体层(Physical layer)：把电脑连接起来的物理手段。负责传送0和1的电信号 顺序从下到上看，越下面的层，越靠近硬件；越上面的层，越靠近用户。 HTTP连接方式HTTP属于应用层的一种互联网协议，基于TCP/IP协议，是两者的一种具体运用。五层模型中的应用层除了HTTP还有其他的协议。 http：超文本传输协议 https：安全超文本传输协议 IP：TCP/IP协议 ftp：文件传输协议 SMTP：邮件传输协议 HTTP协议位于TCP/IP上层，HTTP使用TCP/IP传输报文数据。 看到这里，应该理解了浏览器发送HTTP请求，是通过TCP/IP的方式与服务器链接的。 如何建立TCP连接？ 三次握手：建立一个TCP连接时，需要客户端和服务器总共发送3个包 首先，请求新的TCP 连接，客户端向服务器发送一个小的 TCP 分组这个分组中，包含的SYN标记说明这是一个连接请求。（a ）。 接着，如果服务器接受了连接，会向客户端回送一个 TCP 分组，这个分组中的 SYN 和 ACK 标记都被置位，说明连接请求已被接受（b ）。 最后，客户端向服务器回送一条确认信息，通知它连接已成功建立 （c ）。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据；三次握手为了是连接服务器指定端口，建立TCP连接，并同步连接交换TCP信息。 断开TCP连接客户端需要和服务器发送四个包，最终确认断开。因此称为四次挥手，这里并不详细说明具体过程。 关于“酒厂”的介绍就到这里，读者到这里能对互联网有一个大概的了解就行了，我们继续探索HTTP。 回到http保时捷356-A是琴酒的爱车，黑色风格是他的穿衣风格，不记住死人的名字，每次只执行一次任务，但使命必达（柯南是个例外），必要时穷追不舍。 “不好意思啊伏特加，已经杀掉的人的脸和名字，我是从来不去记的。” HTTP在某方面也跟琴酒有点类似，每次连接只能处理一个请求（但可以使用持久连接），不关心处理了多少条事务，可以传输多种类型数据：文本，图片，网页，音频等.. PS：事务结束连接后，TCP可使连接保持打开状态，这种技术叫持久性连接 正式给HTTP一个简介： 超文本传输协议 (Hyper Text Transport Protocol, HTTP)最为广泛的一种网络传输协议 基于TCP/IP通信协议来传递数据 连接所有的WWW文件都必须遵守这个标准 无连接：限制每次连接只处理一个请求 任何类型的数据都可以通过HTTP发送 无状态协议：对于事务处理没有记忆能力 HTTPS虽说浏览器发送请求给服务器，但HTTP传输数据并不是直达目的服务器的。且HTTP是使用明文（不加密）传输数据的。这意味者请求在发送过程中，可能数据会被抓到导致泄露纂改，或经过某个网关/代理被拦截下来自己的身份被冒充，因此HTTP并不安全，为了确保请求能准确加密送达服务器，HTTPS出现了。 还记得之前一笔带过的TCP/IP分层（4层）吗？ 如何加密？ HTTPS在安全的传输层上发送HTTP，在这里先加密后发送报文给TCP。同样遵循一层有一个或多个协议，安全层通过SSL或TLS协议实现（SSL采用公开密钥加密），安全层使得即使请求被第三方获取，也无法识别数据内容。 这里涉及到密码学的一些基本知识 SSL的加密方式是公开密钥加密 密钥是一套对明文进行编码/转码的算法 公开密钥即公开编码密钥 每个人拥有不同的解码密钥 非对称加密的编码和解码密钥不同 密码学上，没有绝对安全的密码，如果暴力破解，是可以破解出来的，只是时间长短问题，有些密码可能需要好几百年才能破解，详情了解MD5加密。 “锄头凿得好，没有挖不到的墙角。” 签名与证书 服务器远在他乡，有时候网页打不开都得先看下wifi信号是不是不好，再检测下站点的服务器是不是问题；那正常情况下，又有谁能保证请求一定送达服务器？ 我们可以考虑给HTTP的报文签名，以备注报文的编写作者。同时，我们需要一个公正的、值得信赖的组织，保证这个连接是安全的。 数字签名技术使用加密系统给报文签名，说明是谁编写的报文，同时也能证明报文没有被篡改过，这可以保证报文的准确传输。 服务器证书，SSL数字证书的一种形式，是因特网上的“ID卡”，由官方的“证书颁发机构”签发。记录了服务器名称，过期时间，证书发布者和发布者的数字签名等。 SSL不检测站点服务器的证书，现代浏览器会自行检查，若没有证书，浏览器会警告用户连接并不安全。 浏览器检测证书 一个未正确配置SSL的网址，打开看看自己的浏览器有没有对SSL检测？https://self-signed.badssl.com/ 相信比我更敏慧的你早已发现：”S”代表safe(安全)，safe是SSL/TLS。 基本概念已经知晓，是时候来一波SSL连接了。 SSL握手 SSL握手发生在HTTP传输加密报文前，它们会完成以下工作： 交换协议版本号 选择一个两端都了解的密码（公钥） 对两端身份进行认证 生成临时密钥，加密通道 由于多了一次SSL握手过程，相同的网络环境下，HTTPS比HTTP要费时。 兼容HTTP 如果自己的网站从HTTP升级到了HTTPS，那么需要考虑用户可能会按照之前的习惯http://fifth-patient.github.io/，而不是输入https://fifth-patient.github.io/，这导致用户并不能使用该网站的HTTPS协议。所幸，http和https使用的默认端口(port)不同。http的默认端口是80或者8080，https默认端口是443。我们可以在http的默认端口设置代理使之跳转到https的443。 http://fifth-patient.github.io/ = http://fifth-patient.github.io:80/ https://fifth-patient.github.io/ = http://fifth-patient.github.io:443/ 以上四个超链接都可正确打开此博客主页。 PS：上文提及的URL格式中port参数出现了 对比HTTP 按照惯例，接下来是小结的时间。 HTTPS：超文本安全传输协议(Hypertext Transfer Protocol Secure) 以安全为目标的HTTP通道，简单讲是HTTP的安全版 在HTTP下加入SSL层，提供加密传输和身份验证功能 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443 HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50% HTTPS是现行架构下最安全的解决方案，并非绝对安全 不止浏览器再次把话题的范围放大。HTTP也并不是浏览器特有使用的协议，更运行上在其他的客户端(Client)上，如印象笔记，微信，音乐播放器等，甚至自己写的一个网络爬虫程序，也是HTTP客户端。只要可以发送HTTP报文的，都是HTTP的客户端。浏览器是最经典的HTTP客户端，且浏览器支持HTTP协议的同时，更支持ftp， file协议。 C/S结构：客户机/服务器模式，是基于企业内部网络的应用系统。由于Web浏览器的兴起，B/S模式逐步取代了C/S模式，被更广泛地应用。 B/S结构基于C/S结构，是其本身的一种改良。 web控件而客户端到服务器之间并不是直连的。也就是说，报文在传输的过程，需要经过好几个结构组件，如代理、缓存、网关、隧道、Agent代理。举个例子，我们浏览一个美国的网站，如果网站配置了CDN，而在国内正好有某个节点有缓存；且缓存未过期。这时候我们的请求被国内的节点处理，返回的结果是其缓存，从物理角度看，这远比直接跑到美国拿数据要快得过。 尾声这是在下写的第一篇博文，本意是简单写写HTTP协议的。网上冲浪离不开这位老朋友，因此我觉得第一篇博文以HTTP为话题多少有点起点性的意义。技术型的文章如果太多术语，逼格是高了，但是会隐晦难懂。因此在保证文章质量的前提下，插入了两个小故事，使得趣味性高一点。更深层的技术也没怎么提及，所以这篇文章的定位是科普文章。 未完待续那么，关于HTTP就到此为止了吗？不不不，HTTP的话题太过庞大，文章简述了一些比较主要的知识点而已，更衍生出了很多相关的话题。 互联网、因特网、万维网是什么？ 浏览器访问网页的详细过程？ 五层模型中的其他协议 web控件的功能？ https与web安全 如何设置缓存 用户认证机制 在这之前也有很多优秀的前辈的写过相关的文章，这些话题以后再慢慢提及。还有HTTP的历史需要读者自行探索，这里介绍两本书：《HTTP权威指南》、 《图解HTTP》。 相信看完整篇文章，读者再去看书也会有更深层次的收获。 结语《过桥米线》中，妻子送米线表达对夫君的爱意和仕途的支持；浏览器与服务器之间使用HTTP协议交互；所以我想：HTTP协议应该是浏览器和服务器之间的美好约定吧。 琴酒纵使能力再强，也属于“酒厂”组织的其中一个成员；HTTP固然如此，名气再大，也希望读者不要忘记在背后支持它的互联网协议。 最后，希望朋友吃米粉的时候能想起HTTP；喝酒的时候能想起互联网协议；喝酒吃米粉的时候能想到我。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://fifth-patient.github.io/tags/web/"}]},{"title":"前端常见缓存机制","slug":"web-cache","date":"2019-03-28T09:11:11.000Z","updated":"2020-01-24T15:57:36.353Z","comments":true,"path":"/post/web-cache/","link":"","permalink":"https://fifth-patient.github.io/post/web-cache/","excerpt":"缓存是捷径，使http抄近道 cookieCookie 是服务器保存在浏览器的一小段文本信息。浏览器每次向服务器发出请求，就会自动附上这段信息，是前端的一种常见而又传统的缓存机制。 作用 用于保存页面信息：如自动登录，记住用户名 以域名为单位，数量大小有4k-10k，有过期时间 js中通过doucment.cookie调用 cookie的传递从服务器端，发送cookie给客户端，是对应的Set-Cookie头信息。包括了对应的cookie的名称，值，以及各个属性。从客户端发送cookie给服务器，对应Cookie头信息，不发送cookie的各个属性，只发送对应的名称和值。","text":"缓存是捷径，使http抄近道 cookieCookie 是服务器保存在浏览器的一小段文本信息。浏览器每次向服务器发出请求，就会自动附上这段信息，是前端的一种常见而又传统的缓存机制。 作用 用于保存页面信息：如自动登录，记住用户名 以域名为单位，数量大小有4k-10k，有过期时间 js中通过doucment.cookie调用 cookie的传递从服务器端，发送cookie给客户端，是对应的Set-Cookie头信息。包括了对应的cookie的名称，值，以及各个属性。从客户端发送cookie给服务器，对应Cookie头信息，不发送cookie的各个属性，只发送对应的名称和值。 使用方式 设置：doucument.cookie=&quot;name=value;max-age=seconds;Path=path;HttpOnly;&quot;等；一次设置一个值，同名参数会进行覆盖 指定过期时间的cookie会存储在本地，没有指定时为session Cookie，会话结束后cookie删除，设置domain和paath可指定cookie的作用域。httponly指定cookie必须用http或https传输，该属性可限制js访问操作此cookie。secure可指定cookie只能使用https传输。 读取：document.cookie会返回cookie的名和值，其他参数不会返回，如：a=1;b=2; 每个cookie的名值通过分号分割。 删除：将max-age设置为-1 cookie优点可配置性和可扩展性 可以在客户端上保存用户数据，起到简单的缓存和用户身份识别等作用 保存用户的偏好，比如网页的字体大小、背景色等等。 记录用户的行为 cookie的缺陷数据数量：每个cookie的大小限制在4k，不同的浏览器对同一个域下的cookie的数量有限制，IE6 20，IE7+ 50，Firefox 50，Safari ∞，Chrome 53。数量超出时， IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。保险起见cookie的数量应控制在20个，单个cookie大小应小于4KB。 安全性问题：HTTP请求中的cookie是明文传递（HTTPS不是），故敏感信息不能使用cookie存储，如用户密码等。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。 网络负担：cookie会被附加在每个HTTP请求中，在请求和响应时都会被传输，所以增加了流量的损失。 seesion存储会话机制，保存在服务器上。客户端访问服务器时，服务器把客户端信息以某种形式记录在服务器上。再次访问时只需要从该Session中查找该客户的状态就可以了。 标识用户身份： 用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId，cookie把SessiondId自动带到服务器。 session创建：当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了sessionId，如果已包含则说明以前已经为此客户端创建过session，服务器就按照sessionId把这个session检索出来使用（检索不到，会新建一个）。如果客户端请求不包含sessionId，则为此客户端创建一个session并且生成一个与此session相关联的sessionId，sessionId的值是一个既不会重复，又不容易被找到规律以仿造的字符串，这个sessionId将被在本次响应中返回给客户端保存。 禁用cookie：如果客户端禁用了cookie，通常有两种方法实现session而不依赖cookie。1）URL重写，就是把sessionId直接附加在URL路径的后面。2）表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器 Session共享：对于多网站(同一父域不同子域)单服务器，我们需要解决的就是来自不同网站之间SessionId的共享。由于域名不同(aaa.test.com和bbb.test.com)，而SessionId又分别储存在各自的cookie中，因此服务器会认为对于两个子站的访问,是来自不同的会话。解决的方法是通过修改cookies的域名为父域名达到cookie共享的目的,从而实现SessionId的共享。带来的弊端就是，子站间的cookie信息也同时被共享了。 cookie与session的区别1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5、可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。 web Storageweb 本地存储对浏览器来说，使用 Web Storage 存储键值对比存储 Cookie 方式更直观，而且容量更大，它包含两种：localStorage 和 sessionStorage sessionStorage（临时存储） ：为每一个数据源维持一个存储区域，在浏览器打开期间存在，包括页面重新加载localStorage（长期存储） ： 一直存储在本地，数据存储是永久的，除非用户或程序对其进行删除操作；localStorage 对象存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 sessionStorage 和 localStorage 的用法基本一致，引用类型的值要转换成JSON 特点：域内安全、永久保存。即客户端或浏览器中来自同一域名的所有页面都可访问localStorage数据且数据除了删除否则永久保存，但客户端或浏览器之间的数据相互独立。数据不会随着Http请求发送到后台服务器；存储数据的大小至少4MB。 存储方式：以键值对(Key-Value)的方式存储字符串。主要应用：购物车、客户登录、游戏存档。。。可储存的数据类型：数组，图片，json，样式，脚本。。。（只要是能序列化成字符串的内容都可以存储） JS APIlocalStorage.setItem(键名，键值) 在本地客户端存储一个字符串类型的数据localStorage.getItem(键名) 读取已存储在本地的数据localStorage.removeItem(键名) 移除已存储在本地的数据localStorage.clear() 移除本地存储所有数据 sessionStorage中的四个函数与以上localStorage类的函数用法基本一致 cookie与web Storage的区别1、cookie数据始终在同源的http请求中携带2、cookie可设置路径，限制其作用域3、存储大小，cookie不能超过4k，web Storage可达5M4、cookie有数据有效期，web Storage无5、作用域不同，sessionStroage不在不同浏览器窗口共享， localStorage与cookie在所有同源窗口共享 cookie与webStorage的使用方法1、兼容性：IE9+支持web Storage，cookie作为远古时期产物，无兼容性问题2、交互性：web Storage不与服务器交互，需要与服务器交互时使用cookie3、数据大小：cookie不能超过4k，web Storage可达5M","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://fifth-patient.github.io/tags/web/"}]},{"title":"嗜夜","slug":"killing-night","date":"2019-03-27T13:32:10.000Z","updated":"2020-01-24T15:57:36.313Z","comments":true,"path":"/post/killing-night/","link":"","permalink":"https://fifth-patient.github.io/post/killing-night/","excerpt":"","text":"夜晚的钟声慢慢敲起。原始丛林狼群双眸诡异的光芒。无处安放的灵魂也回归平静。 教徒合诵古老冗长的咒语。祭坛的封印一步步被封开。古墓冰尸发出阵阵哀嚎。锁链断裂，癫狂抑制不住。屠杀活动的序幕早已开始。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://fifth-patient.github.io/tags/随笔/"}]},{"title":"用信鸽来解释 HTTPS","slug":"https","date":"2019-03-02T16:00:00.000Z","updated":"2020-01-24T15:57:36.313Z","comments":true,"path":"/post/https/","link":"","permalink":"https://fifth-patient.github.io/post/https/","excerpt":"2019/01/09 | 分类： 基础技术 | 2 条评论 | 标签： https 译文出处： oschina | 原文出处：freecodecamp 密码学是一门难以理解的学科，因为它充满了数学定理。但是除非你要实际开发出一套加密算法系统，否则你是没必要强制理解那些深奥的数学定理的。 如果你阅读本文的目的是想设计下一套 HTTPS 协议，那我只能抱歉的说本文的知识还远远不够；如果不是的话，那么就煮杯咖啡，轻松愉悦的阅读本文吧。 爱丽丝、鲍伯和 … 信鸽？你在互联网上从事的任何活动（阅读这篇文章、在亚马逊上购物、上传图片等）归结到底都是从某台服务器上发送和接收信息。 这个说起来可能有点抽象，不如让我们假设这些消息都是由信鸽来传递的。我知道这个假设有些太过随意，但相信我 HTTPS 就是这样工作的，尽管它的速度快的多。 我们先不谈服务器、客户端或者黑客攻击，先来聊一下爱丽丝、鲍伯和马洛里。如果这已不是你第一次接触密码学理论，你应该会认识这些名字，因为他们经常在各种密码学文献中被提及。 一个简单的通信方式如果爱丽丝想给鲍伯发个消息，她会把消息绑在信鸽的腿上寄给鲍伯。然后鲍伯收到了消息，并阅读了它。这一切都是美好的。 但如果马洛里拦截了爱丽丝飞翔中的信鸽并且修改消息内容呢？鲍伯将无法知道爱丽丝发来的消息已经在传输过程中被修改了。 这就是 HTTP 的工作方式，很可怕吧？我绝不会通过 HTTP 发送我的银行凭证，希望你也不会。","text":"2019/01/09 | 分类： 基础技术 | 2 条评论 | 标签： https 译文出处： oschina | 原文出处：freecodecamp 密码学是一门难以理解的学科，因为它充满了数学定理。但是除非你要实际开发出一套加密算法系统，否则你是没必要强制理解那些深奥的数学定理的。 如果你阅读本文的目的是想设计下一套 HTTPS 协议，那我只能抱歉的说本文的知识还远远不够；如果不是的话，那么就煮杯咖啡，轻松愉悦的阅读本文吧。 爱丽丝、鲍伯和 … 信鸽？你在互联网上从事的任何活动（阅读这篇文章、在亚马逊上购物、上传图片等）归结到底都是从某台服务器上发送和接收信息。 这个说起来可能有点抽象，不如让我们假设这些消息都是由信鸽来传递的。我知道这个假设有些太过随意，但相信我 HTTPS 就是这样工作的，尽管它的速度快的多。 我们先不谈服务器、客户端或者黑客攻击，先来聊一下爱丽丝、鲍伯和马洛里。如果这已不是你第一次接触密码学理论，你应该会认识这些名字，因为他们经常在各种密码学文献中被提及。 一个简单的通信方式如果爱丽丝想给鲍伯发个消息，她会把消息绑在信鸽的腿上寄给鲍伯。然后鲍伯收到了消息，并阅读了它。这一切都是美好的。 但如果马洛里拦截了爱丽丝飞翔中的信鸽并且修改消息内容呢？鲍伯将无法知道爱丽丝发来的消息已经在传输过程中被修改了。 这就是 HTTP 的工作方式，很可怕吧？我绝不会通过 HTTP 发送我的银行凭证，希望你也不会。 隐蔽的密码那么如果爱丽丝和鲍勃都非常的机智。他们一致认同使用一种隐蔽的密码来书写他们的信息。他们会将信息中的每个字母按照字母表中的顺序前移三位。比如，D→A，E→B，F→C。如此一来，原文为 “secret message” 的信息就变成了 “pbzobq jbppxdb” 。 那现在如果马洛里再截获了信鸽，她既不能做出有意义的修改同时也不会知道信息的内容，因为她不知道隐蔽的密码到底是什么。然而鲍勃却可以很容易反转密码，依靠 A → D, B → E, C → F 之类的规则破译信息的内容。加密后的信息 “pbzobq jbppxdb” 会被破解还原为 “secret message” 。 搞定！ 这就是对称密匙加密，因为如果你知道如何加密一段信息那么你同样可以解密这段信息。 上述的密码通常被称为凯撒码。在现实生活中，我们会使用更为奇特和复杂的密码，但原理相同。 我们如何决定密匙？如果除了发信者和收信者之外没有人知道使用的是什么密匙，对称密匙加密是非常安全的。在凯撒加密中，密匙就是每个字母变到加密字母需要移动多少位的偏移量。我之前的距离中，使用的偏移量是 3 ，但是也可以用 4 或者 12 。 问题是如果爱丽丝和鲍勃在开始用信鸽传信之前没有碰过头，他们没有一个安全的方式来确立密匙。如果他们自己来在信中传递密匙，马洛里就会截获信息并发现密匙。这就使得马洛里可以在爱丽丝和鲍勃开始加密他们的信息之前或之后，阅读到他们信息的内容并按照她的意愿来篡改信息。 这是一个中间人攻击的典型例子，避免这个问题的唯一方法就是收发信的两方一起修改他们的编码系统。通过信鸽传递盒子 所以爱丽丝和鲍勃就想出了一个更好的系统。当鲍勃想要给爱丽丝发送信息时，他会按照如下的步骤来进行： 鲍勃向爱丽丝送一只没有携带任何信息的鸽子。 爱丽丝给鲍勃送回鸽子，并且这只鸽子带有一个有开着的锁的盒子，爱丽丝保管着锁的钥匙。 鲍勃把信放进盒子中，把锁锁上然后把盒子送给爱丽丝。 爱丽丝收到盒子，用钥匙打开然后阅读信息。 这样马洛里就不能通过截获鸽子来篡改信息了，因为她没有打开盒子的钥匙。当爱丽丝要给鲍勃发送消息的时候同样按照上述的流程。 爱丽丝和鲍勃所使用的流程通常被称为非对称密钥加密。之所以称之为非对称，是因为即使是你把信息编码（锁上盒子）也不能破译信息（打开锁住的盒子）。 在术语中，盒子被称为公匙而用来打开盒子的钥匙被称为私匙。 如何信任盒子如果你稍加注意你就会发现还是存在问题。当鲍勃收到盒子时他如何能确定这个盒子来自爱丽丝而不是马洛里截获了鸽子然后换了一个她有钥匙能打开的盒子呢？ 爱丽丝决定签名标记一下盒子，这样鲍勃收到盒子的时候就可以检查签名来确定是爱丽丝送出的盒子了。 那么你们之中的一些人可能就会想了，鲍勃如何打一开始就能识别出爱丽丝的签名呢？这是个好问题。爱丽丝和鲍勃也确实有这个问题，所以他们决定让泰德代替爱丽丝来标记这个盒子。 那么谁是泰德呢？泰德很有名的，是一个值得信任的家伙。他会给任何人签名并且所有人都信任他只会给合法的人签名标记盒子。 如果泰德可以确认索要签名的人是爱丽丝，他就会在爱丽丝的盒子上签名。因此马洛里就不可能搞到一个有着泰德代表爱丽丝签了名的盒子，因为鲍勃知道泰德只会给他确认过的人签名，从而识破马洛里的诡计。 泰德的角色在术语中被称为认证机构。而你阅读此文时所用的浏览器打包存有许多认证机构的签名。 所以当你首次接入一个网站的时候你可以信任来自这个站点的盒子因为你信任泰德而泰德会告诉你盒子是合法的。 沉重的盒子现在爱丽丝和鲍勃有了一个可靠的系统来进行交流，然他们也意识到让鸽子携带盒子比原本只携带信件要慢一些。 因此他们决定只有在选择用对称加密来给信息编码（还记得凯撒加密法吧？）的密匙时，使用传递盒子的方法（非对称加密）。 这样就可以二者的优点兼具了，非对称加密的可靠性和对称加密的高效性。 现实世界中我们不会用信鸽这样慢的送信手段，但用非对称加密来编码信息仍要慢于使用对称加密技术，所以我们只有在交换编码密匙的时候会使用非对称加密技术。 现在你已经了解了HTTPS是如何工作的了，你的咖啡也应该准备好了。好好享用吧你受之无愧。","categories":[{"name":"转载","slug":"转载","permalink":"https://fifth-patient.github.io/categories/转载/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://fifth-patient.github.io/tags/转载/"}]},{"title":"JavaScript ES2019 中的 8 个新功能","slug":"ES2019","date":"2019-01-08T16:00:00.000Z","updated":"2020-01-24T15:57:36.244Z","comments":true,"path":"/post/ES2019/","link":"","permalink":"https://fifth-patient.github.io/post/ES2019/","excerpt":"JavaScript 一直在不断改进和添加更多新功能。TC39 已经完成，并批准了 ES2019 的 8 项新功能。这个过程包含了 5 个阶段： 第 0 阶段：稻草人 第 1 阶段：提案 第 2 阶段：草案 第 3 阶段：候选 第 4 阶段：已完成 / 已批准 第 0 阶段的提案：https://github.com/tc39/proposals/blob/master/stage-0-proposals.md 第 1 至 3 阶段的提案：https://github.com/tc39/proposals 第 4 阶段的提案：https://github.com/tc39/proposals/blob/master/finished-proposals.md 废话不多说，接下来让我们来逐一介绍这些功能。","text":"JavaScript 一直在不断改进和添加更多新功能。TC39 已经完成，并批准了 ES2019 的 8 项新功能。这个过程包含了 5 个阶段： 第 0 阶段：稻草人 第 1 阶段：提案 第 2 阶段：草案 第 3 阶段：候选 第 4 阶段：已完成 / 已批准 第 0 阶段的提案：https://github.com/tc39/proposals/blob/master/stage-0-proposals.md 第 1 至 3 阶段的提案：https://github.com/tc39/proposals 第 4 阶段的提案：https://github.com/tc39/proposals/blob/master/finished-proposals.md 废话不多说，接下来让我们来逐一介绍这些功能。 1.可选的 catch 绑定可选的 catch 绑定提案是为了能够选择性地移除使用不到的 catch 绑定。 1234567891011try &#123; // trying to use a new ES2019 feature // which may not be implemented in other browsers &#125; catch (unused) &#123; // revert back to old way &#125; 现在可以删除使用不到的绑定。 123456789try &#123; ... &#125; catch &#123; ... &#125; 2.JSON 超集这个提案的目的是让 JSON 字符串可以包含未转义的 U+2028 LINE SEPARATOR 和 U+2029 PARAGRAPH SEPARATOR 字符，而 ECMAScript 字符串是不能包含这些字符的。在 ES2019 生效之前，这样做会出现“SyntaxError: Invalid or unexpected token”错误。 123const LS = eval(&apos;&quot;\\u2028&quot;&apos;); const PS = eval(&quot;&apos;\\u2029&apos;&quot;); 3. 符号描述符号是在 ES2015 中引入的，具有非常独特的功能。在 ES2019 中可以提供给定的描述，目的是避免间接从 Symbol.prototype.toString 获取描述。 1234567const mySymbol = Symbol(&apos;myDescription&apos;); console.log(mySymbol); // Symbol(myDescription) console.log(mySymbol.toString()); // Symbol(myDescription) console.log(mySymbol.description); // myDescription 4. 修订版的 Function.prototype.toString之前的函数原型已经有 toString 方法，但是在 ES2019 中，它经过了修订，可以包含函数内的注释，不过不适应于箭头函数。 1234567891011121314151617181920212223function /* comment */ foo /* another comment */ ()&#123;&#125; // Before console.log(foo.toString()); // function foo()&#123;&#125; // Now ES2019 console.log(foo.toString()); // function /* comment */ foo /* another comment */ ()&#123;&#125; // Arrow Syntax const bar /* comment */ = /* another comment */ () =&gt; &#123;&#125; console.log(bar.toString()); // () =&gt; &#123;&#125; 5.Object.fromEntries它是 Object.entries 方法的反向操作，可用于克隆对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const obj = &#123; prop1: 1, prop2: 2, &#125;; const entries = Object.entries(obj); console.log(entries); // [ [ &apos;prop1&apos;, 1 ], [ &apos;prop2&apos;, 2 ] ] const fromEntries = Object.fromEntries(entries); console.log(fromEntries); // Object &#123; prop1: 1, prop2: 2 &#125; console.log(obj === fromEntries); // false不过需要注意的是，嵌入式对象 / 数组都只是引用。 const obj = &#123; prop1: 1, prop2: 2, deepCopy: &#123; mutateMe: true &#125; &#125;; const entries = Object.entries(obj); const fromEntries = Object.fromEntries(entries); fromEntries.deepCopy.mutateMe = false; console.log(obj.deepCopy.mutateMe); // false 6. 格式化的 JSON.stringify这个提案是由同一个人提出来的，与 JSON 超集有关。ES2019 将使用 JSON 转义序列表示输出结果，而不是返回 UTF-16 代码单元。 12345678910111213141516171819202122232425262728293031323334353637// Before console.log(JSON.stringify(&apos;\\uD800&apos;)); // &quot;?&quot; // Now ES2019 console.log(JSON.stringify(&apos;\\uD800&apos;)); // &quot;\\ud800&quot;7.String.prototype 的 trimStart 和 trimEndString 原型已经有了 trim 方法，用来移除字符串开头和结尾的空格。而 ES2019 引入了 trimStart 和 trimEnd。 // Trim const name = &quot; Codedam &quot;; console.log(name.trim()); // &quot;Codedam&quot; // Trim Start const description = &quot; Unlocks Secret Codes &quot;; console.log(description.trimStart()); // &quot;Unlocks Secret Codes &quot; // Trim End const category = &quot; JavaScript &quot;; console.log(category.trimEnd()); // &quot; JavaScript&quot; 8.Array.prototype 的 flat 和 flatMapflat 方法通过将所有子数组元素以递归方式连接到指定的深度来创建数组。默认深度为 1，使数组的第一层嵌套展平。 123456789101112131415161718192021222324252627282930313233const arr = [1, 2, [3, 4, [5, 6]]]; arr.flat(); // [1, 2, 3, 4, [5, 6]] arr.flat(2); // [1, 2, 3, 4, 5, 6] // You can use Infinity to flatten all the nested arrays no matter how deep the array is const arrExtreme = [1, [2, [3, [4, [5, 6, 7, [8, 9]]]]]]; arrExtreme.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9]flatMap 方法类似于 flat，并且还与 map 相关，它会先映射数组然后将其展平。 const arr = [&apos;Codedam&apos;, &apos;is Awsome&apos;, &apos;!&apos;]; const mapResult = arr.map(item =&gt; item.split(&apos; &apos;)); console.log(mapResult); // [ [ &apos;Codedam&apos; ], [ &apos;is&apos;, &apos;Awsome&apos; ], [ &apos;!&apos; ] ] const flatMapResult = arr.flatMap(chunk =&gt; chunk.split(&apos; &apos;)); console.log(flatMapResult); // [&apos;Codedam&apos;, &apos;is&apos;, &apos;Awsome&apos;, &apos;!&apos;]; 其他 我还想强调一下现在处在第 3 阶段的一些有用的特性。 globalThis； BigInt； import()； 遗留的 RegEx； 私有的实例方法； String.prototype.matchAll。 英文原文：https://codedam.com/8-new-features-javascript-es2019/ 更多内容，请关注前端之巅。","categories":[{"name":"转载","slug":"转载","permalink":"https://fifth-patient.github.io/categories/转载/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://fifth-patient.github.io/tags/转载/"}]},{"title":"不再性感，不再赚钱，数据科学的时代变了","slug":"database","date":"2019-01-08T16:00:00.000Z","updated":"2020-01-24T15:57:36.276Z","comments":true,"path":"/post/database/","link":"","permalink":"https://fifth-patient.github.io/post/database/","excerpt":"作者：Vicki Boykis | 译者：阿拉丁 阅读数：678 2019 年 3 月 2 日 | 话题：大数据 AI 最佳实践 当你看到“数据科学”这个词时，会想到什么？你可能会觉得它是统计学、机器学习、深度学习和“21 世纪最性感的工作”等关键词的组合，或者你的脑海里会浮现出一个数据科学家的形象，她坐在电脑旁，将 AB 测试得到的结果拼接在一起，又或者你听很多人说过干这行有赚不完的钱（根据权威部门统计：入门级数据科学家的平均年薪约人民币 744253 元）。无论是哪一种，它都是迷人、聪明和复杂的。 从本文作者 Vicki Boykis 十年前进入这一领域以来，数据科学一直给人这样的印象，但现在，数据科学已经不再是当初的样子了。以下内容由 AI 前线编译，原文来自 Vicki Boykis 发表于个人博客的文章《Data science is different now》。 我最初是一名数据分析师。 我是否曾经提到过我有多讨厌 Excel 默认的数字字符串格式？ ——Vicki Boykis（@vboykis）2012 年 5 月 18 日 我经常是一边苦等 SQL 的运行结果、整理乱糟糟的 Excel 文件，一边看着 Hacker News 上有关海量数据挖掘的文章、Facebook 数据科学团队的新闻和谷歌首席经济学家 Hal Varian 写的文章，然后一边做着白日梦。 2012 年，我很幸运地被分配到了一个数据分析工程团队，他们正在将一些 ETL 作业从 Oracle 迁移到 Hadoop 上，以便满足不断增长的数据吞吐量要求。","text":"作者：Vicki Boykis | 译者：阿拉丁 阅读数：678 2019 年 3 月 2 日 | 话题：大数据 AI 最佳实践 当你看到“数据科学”这个词时，会想到什么？你可能会觉得它是统计学、机器学习、深度学习和“21 世纪最性感的工作”等关键词的组合，或者你的脑海里会浮现出一个数据科学家的形象，她坐在电脑旁，将 AB 测试得到的结果拼接在一起，又或者你听很多人说过干这行有赚不完的钱（根据权威部门统计：入门级数据科学家的平均年薪约人民币 744253 元）。无论是哪一种，它都是迷人、聪明和复杂的。 从本文作者 Vicki Boykis 十年前进入这一领域以来，数据科学一直给人这样的印象，但现在，数据科学已经不再是当初的样子了。以下内容由 AI 前线编译，原文来自 Vicki Boykis 发表于个人博客的文章《Data science is different now》。 我最初是一名数据分析师。 我是否曾经提到过我有多讨厌 Excel 默认的数字字符串格式？ ——Vicki Boykis（@vboykis）2012 年 5 月 18 日 我经常是一边苦等 SQL 的运行结果、整理乱糟糟的 Excel 文件，一边看着 Hacker News 上有关海量数据挖掘的文章、Facebook 数据科学团队的新闻和谷歌首席经济学家 Hal Varian 写的文章，然后一边做着白日梦。 2012 年，我很幸运地被分配到了一个数据分析工程团队，他们正在将一些 ETL 作业从 Oracle 迁移到 Hadoop 上，以便满足不断增长的数据吞吐量要求。 有没有“给白痴用的 Hadoop”？ 给小白用的 Hadoop 并不适合我。 ——Vicki Boykis（@vboykis）2012 年 8 月 16 日 我自愿成为第一个使用 Pig 和 Hive 的分析师，主要是因为我不想等到工程工作完成后才能访问我的数据。而且，我沉迷于数据科学家的光环——这些人开展很酷的实验，提出很酷的分析想法，并可以使用 MacBook。 我也想成为这样的人！所以，我在线学习了 Python，重温了我在大学学习过的统计学。在早期，并没有真正形式化的方法来学习“数据科学”，最多只能看看其他人在做什么、去参加聚会或者试着从人力资源招聘的职位描述中读出点什么。 在独自摸索了很长一段时间之后，我在过去的六年时间里已经在“数据科学”领域站稳了脚跟。并且，作为一名导师（但我之前并没有导师），我一直在回复电子邮件，和那些希望进入数据科学领域的人喝咖啡会面。 自 2012 年以来，数据科学行业发展极其迅速。它几乎经历了甘特炒作周期的每个阶段。 我们已经经历了早期采用阶段、有关人工智能和偏见的负面新闻、Facebook 等公司的第二轮和第三轮风险投资，现在正处于高采用增长阶段：银行、医疗保健公司和其他财富 100 强企业（这些公司已经落后市场五年）也在为机器学习招聘数据科学家。 很多东西都变了。大数据（记得 Hadoop 和 Pig 吗？）已经出局了，R 语言的采用率急剧上升，Python 成为经济学家的宠儿，而云计算再次改变了一切。 然而，媒体针对数据科学领域的炒作却没有变，一直在鼓吹数据科学家是“21 世纪最性感的职业”。但我现在认为这是一个很严重的问题，需要引起社区的注意。希望进入这个行业的初级数据科学家供过于求，而一旦他们获得了梦寐以求的“数据科学家”头衔，他们能够得到的东西与他们的期望其实是不匹配的。新数据科学家的供过于求 首先，我们来谈谈初级数据科学家的供过于求。针对数据科学的持续媒体炒作导致过去五年中市场上的初级人才数量激增。 这纯粹是道听途说的东西，所以不要太当真。但是，基于我自己作为简历筛选者、数据科学家导师、面试官、面试者，以及与从事类似职业的朋友和同事的对话，我有一种直觉，每个给定的数据科学职位（特别是入门级的科学职位）的候选人数量从 20 个增加到 100 个或更多。我最近了解到，我的一位朋友在招聘一个职位时收到了不止 500 份简历。 这都很正常，类似的情况还有很多。机器学习教父吴恩达的 AI 创业公司每周要求工作 70 到 80 个小时，但仍然收到了大量申请，甚至有人愿意免费做志愿者。在写这篇文章时，他们的办公室已经容不下更多的人。 要评估市场需求与供应之间的真正差距是非常非常困难的，不过我们可以从这里(https://www.wired.com/story/andrew-ngs-new-online-school/)开始着手。 对 4 月份招聘广告的研究发现，美国有超过 10,000 个针对人工智能或机器学习的职位空缺。 [超过 10 万人参加了 Fast.ai](http://xn--10fast-qo7i07amn353ae9cy36wyeg.ai/)（一家专注于推广人工智能的创业公司）的深度学习课程。 假设平均 MOOC 完成率约为 7％，那意味着有 7000 人可以填补这 10,000 个工作岗位。但是，今年是这样，那么明年呢？我们是否在假设数据科学创造的就业率是稳定的？如果实际情况不是这样的，那么数据科学就业市场有可能会萎缩。 LinkedIn 提供的数据表明，市场上有 151,717 个数据科学人才空缺。虽然目前还不清楚它们是不是就是指数据科学家，或者是只拥有部分技能的人，但我们假设是前者。因此，我们可以说美国现在有 150,000 多个数据科学家职位空缺。 我们假设有 100,000 个人已经参加了数据科学课程，并且其中有 7,000 个人会完成课程。 但是，上面这数字并没有考虑到其他的数据科学候选人计划和途径：Fast.ai 之外的 MOOC，比如 Coursera、Metis（超过 10 个全国性训练营）和 General Assembly（每 12 周就有 25 人参加）、来自加州大学洛杉矶分校等地的远程学位、分析和数据科学的本科学位、YouTube，等等。还有很多博士正在从学术界转向数据科学领域，但却无法在竞争极其激烈的就业市场中找到工作。 这篇文章指出，在 2015 年有 4 万个数据科学家职位空缺。总体而言，到 2018 年，分析技能的市场供应将超过市场容量。image 参加数据科学计划的初级人才数量，再加上数百个开设数据科学课程的训练营，你将看到一场完美的风暴。 除了我从工作中了解到的以及与 100 多名同事进行的交谈之外，下面的两条推文让我确信目前存在真正的数据科学供应泡沫。 @Cal 的数据科学入门课程 Data 8 非常受欢迎。它位于有泽勒巴大剧院。2018 年秋季开学。pic.twitter.com/VBhtPnikmw ——Mike Olson（@mikeolson），2018 年 10 月 4 日 UVA（美国弗吉尼亚大学）很自豪地宣布开设数据科学学院的计划，它将满足社会对数据科学不断增长的需求。https://t.co/QlP4OUrTrO ——UVA（@UVA）2019 年 1 月 18 日 由于学术界在跟上新趋势方面通常会滞后，因此，对于所有希望在数据科学领域找到职位的初级数据科学家来说，这确实令人感到担忧。对于一个拥有数据科学新学位的人来说，要找到一个数据科学的职位是非常困难的，因为他们要在市场上与许多新人展开竞争。 但在三、四年前，情况并非如此。而现在，数据科学已经从流行语变成了连硅谷之外的公司都在招聘的职位，职位的准入门槛更高了，而且偏爱具备数据科学经验的人，数据科学面试仍然很难通过。 正如很多文章指出的那样，你不一定会在第一次尝试时就能找到你梦寐以求的工作。市场可能非常残酷，并且对于大量初入者来说非常令人沮丧。数据科学是一个具有误导性的岗位需求 第二个问题是，一旦这些初级人员进入市场，他们会对数据科学工作产生不切实际的期望。每个人都认为他们将从事与机器学习、深度学习和贝叶斯模拟相关的工作。 这不是他们的错，这就是数据科学课程和技术媒体所宣扬的。 但现实的情况却是，“数据科学”大多数时候是关于如何清理和整理数据以及将数据从一个地方移动到另一个地方。 我最近进行的一次非科学调查证实了这一点： 一段时间以来，我一直对此感到好奇，所以决定做一个民意调查。 “作为一个 2019 年被称为’数据科学家’的人，我花了大部分时间（60％以上）：” 也欢迎“其他”选项，请在回复中添加。 ——Vicki Boykis（@vboykis）2019 年 1 月 28 日 还有很多行业专家发来的推文也是如此： 对于我最近的几个 ML 项目，复杂性并不在于建模或训练，而在于输入预处理。我发现在一个项目中耗尽了 CPU（而不是 GPU），我不确定如何进一步优化 Python（我正在考虑使用 C++）。 ——mat kelcey（@mat_kelcey）2019 年 2 月 11 日 我看到初级 ML/CV 工程师对构建数据集完全缺乏兴趣。虽然这是一项无聊的工作，但我认为在整理数据集时需要学到很多东西，毕竟这占了问题的一大半。 ——Katherine Scott（@kscottz）2019 年 2 月 1 日 角色和责任： - 自动化糟糕的商业行为 - 根据需要编写临时 SQL 经验要求： · 15 年使用 Python 进行深度学习的经验 · 写过有关贝叶斯建模的博士论文 · 7 种语言的 NLP 经验 · 10 年从头开始​​创建 Hadoop 集群的经验 ——NickHeitzman（@NickDoesData）2019 年 2 月 12 日 在过去两年中，项目的工作类别所占百分比： - 涉及 ML：15％ - 涉及移动、监控和统计数据：85％ ——Vicki Boykis（@vboykis）2019 年 1 月 15 日 显而易见的是，在炒作周期的后期阶段，数据科学逐渐向工程学靠近，数据科学家需要的技能不再是基于可视化和统计学，而是更接近传统计算机科学课程所提供的那些： 像单元测试和持续集成这样的概念很快就成为数据科学家和从事 ML 工程的数值科学家的行话和常用的工具。 这导致了一些事情的发生。首先是“机器学习工程师”这个头衔的崛起，在过去的 3 到 4 年里，它带来了更多的声望和更高的收入潜力。 其次，它导致数据科学家头衔含金量严重缩水。由于数据科学家头衔的声望，像 Lyft 这样的公司会招聘数据科学，但实际上他们只需要数据分析师的技能，导致“数据科学”职位对技能的要求发生了扭曲，究竟需要多少新进入者也变得不明确。 给新数据科学家的建议因此，本着继续为初学者提供建议的初衷，如果有人问我如何在 2019 年进入数据科学领域，我会给他们发送下面这样的电子邮件。 这是一个两步走的计划： 1. 不要死盯着数据科学的工作岗位。 2. 为大多数数据科学家相关的工作做好准备，但不要成为数据科学家。调整你的技能组合。 这些话可能有点令人沮丧！但请允许我解释一下，希望它们不像听起来的那么悲观。 不要进入数据科学领域因为每个初级职位一般有 50 个（有时 100 个，有时 200 个）人申请，所以不要与这些人去竞争。不要去攻读数学科学学位，不要参加训练营（我见过的大多数训练营的效果都不太好）。 不要做别人正在做的事情，因为这样无法让你脱颖而出。你正处在一个过度饱和的行业中，这样只会给自己增加难度。在我之前提到的那份PWC 报告中，数据科学职位的数量估计为 5 万，数据工程师职位的数量为 50 万，数据分析师职位的数量是 12.5 万。 通过“后门”进入数据科学领域要容易得多，也就是说从初级开发人员开始，可以是 DevOps 工程师、项目管理人员、数据分析师、信息管理员或类似的角色。这可能需要更长的时间，但在你努力完成数据科学工作的同时，你也将学会对职业生涯来说至关重要的 IT 技能。 了解当今数据科学所需的技能以下是你在数据领域需要解决的一些问题： 1）创建 Python 包 2）将 R 语言用在生产环境中 3）优化 Spark 作业，使其更有效地运行 4）对数据进行版本控制 5）让模型和数据可重现 6）对 SQL 进行版本控制 7）在数据湖中建立和维护干净的数据 8）大规模时间序列预测工具 9）共享 Jupyter Notebook 10）寻找可用于清理数据的系统 11）JSON 作为一名数据科学家，优化模型、可视化和分析数据是职责工作的一部分，而数据科学主要是（也一直是）关于在一个地方获得用于插补的干净数据。 你应该如何为解决这些问题做好准备？如何为工作做好准备？你可以考虑学习下面这三种技能，它们都是基础技能，并彼此依赖，从简单到困难。 所有这些技能也是数据科学以外的软件开发的基础和关键，这意味着，如果你无法找到数据科学工作，可以快速转做软件开发或 DevOps。我认为这种灵活性与针对特定数据相关工作的培训同样重要。 1. 学习 SQL 首先，我建议每个人都要学习 SQL，无论他们的目标是成为数据工程师、ML 专家还是 AI 大师。 SQL 并不性感，也不是上述问题的解决方案。但为了访问数据，你很可能需要针对数据库编写一些 SQL 查询，并用它获取答案。 SQL 非常强大且非常流行，甚至有些 NoSQL 和键值存储数据库也在重新实现它。比如 Presto 推出的 Presto 和 Athena、BigQuery、KSQL、Pandas、Spark，等等。如果你发现自己陷入了数据工具海洋之中，很可能可以找到一个适合你的 SQL 工具。而且，一旦你理解了 SQL，你会发现它比其他查询语言更容易理解，从而开辟了一个全新的世界。 在熟悉了 SQL 之后，下一步是了解数据库的工作原理，这样你就可以学会如何优化查询。你不一定要成为数据库开发人员，但很多概念将延续到你的其他编程生活当中。 2. 学好一门编程语言和学习编程概念 SQL 不是一门编程语言吗？它是的，但它是声明性的。你指定所需的输出（即你要从表中获取哪些列），但不指定这些列以怎样的形式返回给你。SQL 抽象了很多数据库底层的细节。 你需要一门过程式语言，你可以自行指定如何以及从哪里获取数据。大多数现代语言都是过程式的：Java、Python、Scala、R 语言、Go 语言，等等。 关于为数据科学应该选择哪种语言存在很多争论，我不会针对任何特定情况规定说要学习哪一种语言，只是在我的职业生涯中，Python 对我来说非常有用。作为一个初学者，它很容易入门，可以说是数据领域最流行的编程语言，并且可以用来完成很多不同的事情，从将模型嵌入 scikit 中，到访问 AWS API，再到构建 Web 应用程序、清理数据，以及创建深度学习模型。 当然，也有一些任务不太适合用 Python 来完成：大型应用程序、打包依赖项和一些特定的与数字相关的任务，特别是时间序列和 R 语言提供的一系列功能。 如果你不选择 Python，也没问题。但你至少要选择一种语言，让你在数据科学领域之外保持灵活性。例如，如果你的第一份工作是数据分析师、QA 分析师、DevOps 初级工程师，或者其他职位，掌握一门语言都有助于你站稳脚跟。 在选择了一门编程语言并弄清楚如何使用它之后，就可以开始学习它背后的范式以及它与计算机科学生态系统的关系。 你是如何使用你的语言实现 OOP 的？OOP 是什么东西？你如何优化你的代码？你的语言的依赖项是如何工作的？如何使用给定语言打包代码，如何进行版本控制、持续集成，如何部署模型工件？你的语言社区在哪里，会在哪里举行聚会？ 了解你的语言，了解它的优缺点，用你的语言开发一些有趣的东西。 然后，当你有足够的信心继续下去时，也只有在这个时候，才能开始学习你的第二门语言。它将把你带入更广泛的语言设计、算法和模式的世界。 3. 了解云端的工作 现在你已经知道如何编程，现在是时候将这些技能和理论带到云端了。 如今，云无处不在，你可能需要在下一个工作中使用云。如果有更多的机器学习范例转移到云端（如 SageMaker、Cloud AI 和 Azure 机器学习），已经有现成的模板可用来实现算法，而且企业的更多数据也开始存储在那里。 你可能会与行业领导者 AWS 合作，但越来越多的公司正在采用 Google Cloud，而很多已经与微软开展业务合作的保守企业在使用 Azure。我建议深入了解这三个云供应商，然后挑选一个你最感兴趣的。云设计范式都是类似的，你必须了解如何将服务粘合在一起，如何区分云端的服务器，以及如何使用 JSON。 有趣的是，这三家供应商现在都提供了他们的产品认证。我一般不会通过认证来衡量一个人对知识的掌握程度与否，但通过认证可以学到云的工作原理，这是工程的另一个组成部分：网络。 了解这三种产品，并在开始下一份工作之前在云端构建一些有趣的东西。 这里缺失的部分当然是“软技能”——知道在什么时候构建什么，知道如何在工作场所进行交流，知道其他人想要什么。软技能与技术技能一样重要，有很多专门讨论它的文章，但为了保持这篇文章不会太长，这里就不作累述了。 最后的步骤现在，请深呼吸，我想你已经做好准备了。 如果上述有任何一点（或者所有）让你感兴趣，那说明你已经准备好在 2019 年成为数据科学家、机器学习工程师、云专家或 AI 大师了。 请记住，你的最终目标是打败那些攻读数据科学学位、参加训练营和学习教程的人。 你想要迈出第一步，获得一个与数据相关的职位，然后朝着你梦想的工作前进，同时尽可能多地了解科技行业的总体情况。 我最后一个一般性的建议是给自己打气： 这对每个人来说都很难，似乎有很多事情你必须知道。不要气馁。 不要因为想太多就望而却步。先从小处开始，做一些小的事情，学习一些小的东西，构建一些小的东西，把你做的事情告诉其他人。请记住，你在数据科学领域的第一份工作可能不是数据科学家。 祝你好运！ 英文原文：https://veekaybee.github.io/2019/02/13/data-science-is-different/","categories":[{"name":"转载","slug":"转载","permalink":"https://fifth-patient.github.io/categories/转载/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://fifth-patient.github.io/tags/转载/"}]}]}