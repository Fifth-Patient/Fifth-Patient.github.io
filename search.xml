<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浏览器下载与上传文件</title>
    <url>//post/file/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>浏览器/服务器如何生成、下载与上传文件，以及js的文件处理。</p>
<a id="more"></a>
<h2 id="浏览器生成文件"><a href="#浏览器生成文件" class="headerlink" title="浏览器生成文件"></a>浏览器生成文件</h2><p><strong>下载一个文件前，要先确定文件是从哪里生成的，一种是由浏览器生成，另一种是服务端生成文件。</strong>生成文件之后，方可供用户下载到本地设备（计算机/移动设备）的存储空间。</p>
<p>实例代码：<a href="https://github.com/Fifth-Patient/demo-fragment/tree/main/001-file" target="_blank" rel="noopener">001-file</a></p>
<p>我们先讨论浏览器的，再来讨论服务端。   </p>
<p>接下来我们会分别用几种方式生成同一个文件——文件名为<code>hello-world.json</code>，内容为<code>{&quot;hello&quot;:&quot;world&quot;}</code>。</p>
<h3 id="new-File"><a href="#new-File" class="headerlink" title="new File"></a>new File</h3><p>使用<code>js</code>的<code>File</code>对象可以创建一个文件 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File/File" target="_blank" rel="noopener">new File</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> file = <span class="keyword">new</span> File([<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">hello</span>: <span class="string">"world"</span> &#125;)], <span class="string">'hello-world.json'</span>, &#123; <span class="attr">type</span>: <span class="string">'application/json'</span> &#125;)</span><br></pre></td></tr></table></figure>
<p><img src="/post/file/image-20210130180021380.png" alt></p>
<p>这是js文件对象最容易使用的一个<code>Web Api</code>了，接下来介绍的都是二进制文件对象，而且这几个对象互相都有继承关系，也可互相转换。</p>
<p><code>application/json</code>——这是Content-Type（内容类型），常用于<code>HTTP</code>协议，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件。</p>
<h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener">Blob</a>对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">hello</span>: <span class="string">"world"</span> &#125;)], &#123; <span class="attr">type</span>: <span class="string">'application/json'</span> &#125;)</span><br></pre></td></tr></table></figure>
<p><img src="/post/file/image-20210130180542826.png" alt></p>
<p>直接打印显示的是一个<code>Blob</code>对象而且没办法直接查看文件的内容，我们可以用<code>Blob.text()</code>查看，该函数返回一个<code>Promise</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">blob.text().then(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x)) <span class="comment">// &#123;"hello":"world"&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="Data-URLs"><a href="#Data-URLs" class="headerlink" title="Data URLs"></a>Data URLs</h3><p><a href="https://developer.mozilla.org/zh-cn/docs/Web/HTTP/data_URIs" target="_blank" rel="noopener">Data URLs</a>，即前缀为 data: 协议的URL，其允许内容创建者向文档中嵌入小文件。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">data:application/json,&#123;"hello":"world"&#125;</span></span><br></pre></td></tr></table></figure>
<p>直接丢到浏览器的地址栏访问，即可。</p>
<p><img src="/post/file/image-20210130214916127.png" alt></p>
<p>Data URLs也可以表达用base64编码后的文件。</p>
<p>使用在线网站将“JSON转换Base64”，编码后可得<code>eyAiaGVsbG8iOiAid29ybGQiIH0=</code>，按照Data URL的格式组合。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">data:application/json;base64,eyAiaGVsbG8iOiAid29ybGQiIH0=</span><br></pre></td></tr></table></figure>
<h3 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h3><p>到目前为止，我们分别用<code>new File</code> ，<code>Blob</code>，<code>Data Url</code>创建了一个<code>JSON</code>文件，那么如果要创建其他格式的文件呢。比如<code>*.txt</code>，<code>*.html</code>。上述的方法都有<code>application/json</code>的字符，也介绍过这是Content-Type，我们只需要更换相应的Content-Type类型即可，比如：用<code>html</code>的格式输出一级标题（<code>h1</code>），内容为<code>{&quot;hello&quot;:&quot;world&quot;}</code>。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">data:text/html,&lt;h1&gt;&#123;"hello":"world"&#125;&lt;/h1&gt;</span></span><br></pre></td></tr></table></figure>
<p>更多文字格式可以自行搜索“Content-Type 手册”。</p>
<h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p>现在来下载文件，通过浏览器生成的文件都可以通过使用<code>a</code>超链接标签下载，可能会疑惑为什么<code>a</code>标签可以下载文件，<code>H5</code>后，<code>a</code>标签多了一个<code>donwload</code>属性，此时浏览器会下载<code>href</code>指定的<code>url</code>表示的文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"data:application/json,&#123; <span class="symbol">&amp;quot;</span>hello<span class="symbol">&amp;quot;</span>: <span class="symbol">&amp;quot;</span>world<span class="symbol">&amp;quot;</span>&#125;"</span> <span class="attr">download</span>=<span class="string">"hello-world.json"</span>&gt;</span>data URL<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em><code>HTML</code>中引号需要转义，即为<code>&amp;quot;</code></em></p>
<p>点击之前先对浏览器进行两个设置，一个是设置<strong>不自动保存文件</strong>，一个是设置对<code>JSON</code>文件的处理方式。</p>
<p><img src="/post/file/image-20210131220417347.png" alt></p>
<p>确保设置生效后点击刚才的超链接，将会出现这个“打开文件”的弹窗提醒，可以选择<strong>打开</strong>也可以选择保存文件。</p>
<p>“打开”会直接通过指定的本地程序打开，此时目录保存在操作系统的缓存目录，比如我的是<code>C:\Users\Chris\AppData\Local\Temp\hello-world.json</code>。</p>
<p>“下载”会使其文件保存在本地存储设备，因为刚设置了“每次都问您要存在哪”，所以会让我们选择保存目录。</p>
<p><img src="/post/file/image-20210131215545123.png" alt></p>
<p>刚还只是<code>Data URL</code>方式创建的文件下载，要知道<code>new File</code>还有<code>Blob</code>并没有直接提供url。此时我们可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL" target="_blank" rel="noopener">URL.createObjectURL()</a>，直接将<code>new File</code>、<code>Blob</code>类型转换成一个<code>URL</code>。这次我们不用纯<code>HTML</code>实现，我们将通过交互动态创建一个<code>a</code>元素挂载到网页上。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"new-file"</span>&gt;</span>new File button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newFileBtn = <span class="built_in">document</span>.querySelector(<span class="string">'#new-file'</span>)</span><br><span class="line">newFileBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建文件</span></span><br><span class="line">  <span class="keyword">const</span> file = <span class="keyword">new</span> File([<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">hello</span>: <span class="string">"world"</span> &#125;)], <span class="string">'hello-world.json'</span>, &#123; <span class="attr">type</span>: <span class="string">'application/json'</span> &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(file)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下载文件</span></span><br><span class="line">  <span class="keyword">const</span> aLink = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">  aLink.setAttribute(<span class="string">'href'</span>, URL.createObjectURL(file))</span><br><span class="line">  aLink.setAttribute(<span class="string">'download'</span>, file.name)</span><br><span class="line">  <span class="built_in">document</span>.body.append(aLink)</span><br><span class="line">  aLink.click()</span><br><span class="line">  <span class="built_in">document</span>.body.removeChild(aLink)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击之后，跟上述的功能是一样的，只是“打开文件”的弹窗显示的“来源”将会是”Blob”，因为本身<code>new File</code>就是继承<code>Blob</code>实现的。写到这里，就顺便封装成一个函数吧。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下载文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadFile</span>(<span class="params">fileName, file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isBlob = file <span class="keyword">instanceof</span> Blob</span><br><span class="line">  <span class="keyword">const</span> href = isBlob ? URL.createObjectURL(file) : file</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> aLink = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">  aLink.setAttribute(<span class="string">'href'</span>, href)</span><br><span class="line">  aLink.setAttribute(<span class="string">'download'</span>, fileName)</span><br><span class="line">  <span class="built_in">document</span>.body.append(aLink)</span><br><span class="line">  aLink.click()</span><br><span class="line">  <span class="built_in">document</span>.body.removeChild(aLink)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务端生成文件"><a href="#服务端生成文件" class="headerlink" title="服务端生成文件"></a>服务端生成文件</h2><p>这一章开始会涉及到服务端，将使用<code>express</code>——一个<code>node</code>的<code>web</code>框架搭建一个<code>api</code>服务，拥有<strong>文件上传与下载</strong>的功能，具体实现不会讲得太详细，因为我们的重心还在放在浏览器。</p>
<p>我们先设计一个上传文件的api——<code>POST</code>方法，使用<code>form-data</code>传递参数，这个接口接收文件后保存在服务器。</p>
<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>api 文档<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POT localhot:3000/api/file/upload 文件上传</span><br><span class="line">form-data - &#123; file: &lt;文件&gt; &#125;</span><br></pre></td></tr></table></figure></p>
<p>接口实现<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... 省略部分express代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置上传功能</span></span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>)</span><br><span class="line"><span class="keyword">const</span> uploadPath = path.join(__dirname, <span class="string">'./uploads/'</span>) <span class="comment">// 上传目录</span></span><br><span class="line"><span class="keyword">const</span> upload = multer(&#123;</span><br><span class="line">  dest: uploadPath,</span><br><span class="line">  storage: multer.diskStorage(&#123;</span><br><span class="line">    destination: <span class="function"><span class="keyword">function</span> (<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">      cb(<span class="literal">null</span>, uploadPath)</span><br><span class="line">    &#125;,</span><br><span class="line">    filename: <span class="function"><span class="keyword">function</span> (<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">      cb(<span class="literal">null</span>, file.originalname)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 uploadPath</span></span><br><span class="line">fs.exists(uploadPath, exists =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!exists) &#123;</span><br><span class="line">    fs.mkdir(uploadPath, e =&gt; &#123;</span><br><span class="line">      e &amp;&amp; <span class="built_in">console</span>.error(e)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传文件</span></span><br><span class="line">app.post(<span class="string">'/api/file/upload'</span>, upload.fields([&#123; <span class="attr">name</span>: <span class="string">'file'</span>, <span class="attr">maxCount</span>: <span class="number">1</span> &#125;]), (req, res) =&gt; &#123;</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    code: <span class="number">1</span>,</span><br><span class="line">    msg: <span class="string">'success'</span>,</span><br><span class="line">    data: <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(port, () =&gt; <span class="built_in">console</span>.log(<span class="string">`Example app listening on port <span class="subst">$&#123;port&#125;</span>!`</span>))</span><br></pre></td></tr></table></figure></p>
<p>前端上传实现<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/api/file/upload"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里提供三个文件，作为测试文件依次上传：</p>
<ol>
<li><a href="/download/file/html">html</a> (事实上这个一个html文件，只是文件名为<code>html</code>而已)</li>
<li><a href="/download/file/logo.png">logo.png</a></li>
<li><a href="/download/file/style.css">style.css</a></li>
</ol>
<p><img src="/post/file/image-20210321223537208.png" alt></p>
<p><code>ls</code>查看上传目录有相应的文件且<code>Length</code>大于0，则表示以上代码能正常运行功能。</p>
<h3 id="下载文件-1"><a href="#下载文件-1" class="headerlink" title="下载文件"></a>下载文件</h3><p>由服务端生成的文件，<code>api</code>可能响应以下三种类型的数据：</p>
<ol>
<li>直接响应文件，供浏览器直接下载</li>
<li>响应文件内容，由浏览器生成匹配的文件格式后方可下载</li>
<li>响应文件路径，由浏览器自行处理（参考1，2）</li>
</ol>
<p>直接响应文件，浏览器可以使用<code>window.open()</code> 或者 <code>&lt;a downlaod href=&quot;&quot;&gt;&lt;/a&gt;</code>直接下载。响应内容稍微比较麻烦，如果是直接响应文件内容（不是base64），浏览器需要转成base64（存在不知道其文件格式转换失败的场景），如果是直接响应base64字符串则可以用<code>URL.createObjectURL</code>处理。响应文件路径一般浏览器直接打开此路径即可下载。</p>
<p>我们还是先设计一个<code>api</code>，让其拥有下载功能，这个api应该接收两个参数，一个是指定的文件，另一个是指定响应的数据类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /api/file/download</span><br><span class="line">query fileName [String] 文件名称</span><br><span class="line">query type     [String] 数据类型 content - 文件内容、base64-base64、path-文件路径、file-返回文件</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下载文件</span></span><br><span class="line">app.get(<span class="string">'/api/file/download'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, fileName &#125; = req.query</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否缺失必填参数</span></span><br><span class="line">  <span class="keyword">if</span> (!type) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      code: <span class="number">-1</span>,</span><br><span class="line">      msg: <span class="string">'query type is must need!'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!fileName) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      code: <span class="number">-1</span>,</span><br><span class="line">      msg: <span class="string">'fileName type is must need!'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'file'</span>) &#123; <span class="comment">// 返回文件</span></span><br><span class="line">    <span class="keyword">let</span> fileURL = path.join(uploadPath, fileName)</span><br><span class="line">    res.download(fileURL)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'content'</span>) &#123; <span class="comment">// 返回文件内容</span></span><br><span class="line">    <span class="keyword">let</span> fileURL = path.join(uploadPath, fileName)</span><br><span class="line">    <span class="keyword">let</span> fileData = fs.readFileSync(fileURL)</span><br><span class="line">    <span class="keyword">let</span> bufferData = Buffer.from(fileData).toString()</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      code: <span class="number">1</span>,</span><br><span class="line">      msg: <span class="string">'success'</span>,</span><br><span class="line">      data: bufferData</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'base64'</span>) &#123; <span class="comment">// 返回base64</span></span><br><span class="line">    <span class="keyword">let</span> fileURL = path.join(uploadPath, fileName)</span><br><span class="line">    <span class="keyword">let</span> fileData = fs.readFileSync(fileURL)</span><br><span class="line">    <span class="keyword">let</span> bufferData = Buffer.from(fileData).toString(<span class="string">'base64'</span>)</span><br><span class="line">    <span class="keyword">let</span> base64 = <span class="string">'data:'</span> + mineType.lookup(fileURL) + <span class="string">';base64,'</span> + bufferData.toString(<span class="string">'base64'</span>)</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      code: <span class="number">1</span>,</span><br><span class="line">      msg: <span class="string">'success'</span>,</span><br><span class="line">      data: base64</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'path'</span>) &#123; <span class="comment">// 返回路径</span></span><br><span class="line">    res.json(&#123;</span><br><span class="line">      code: <span class="number">1</span>,</span><br><span class="line">      msg: <span class="string">'success'</span>,</span><br><span class="line">      data: <span class="string">`/api/uploads/<span class="subst">$&#123;fileName&#125;</span>`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"file-name"</span> <span class="attr">name</span>=<span class="string">"fileName"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"download-type"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"file"</span>&gt;</span>file<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"content"</span>&gt;</span>content<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"base64"</span>&gt;</span>base64<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"path"</span>&gt;</span>path<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"download-api-btn"</span>&gt;</span>下载<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> downloadApiBtn = <span class="built_in">document</span>.querySelector(<span class="string">'#download-api-btn'</span>)</span><br><span class="line">downloadApiBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fileName = <span class="built_in">document</span>.querySelector(<span class="string">'#file-name'</span>).value</span><br><span class="line">  <span class="keyword">const</span> type = <span class="built_in">document</span>.querySelector(<span class="string">'#download-type'</span>).value</span><br><span class="line"></span><br><span class="line">  fetch(<span class="string">`/api/file/download?fileName=<span class="subst">$&#123;fileName&#125;</span>&amp;type=<span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">    .then(<span class="keyword">async</span> response =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (type === <span class="string">'file'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> blob = <span class="keyword">await</span> response.blob()</span><br><span class="line">        downloadFile(fileName, blob)</span><br><span class="line">        <span class="comment">// 也可以使用window.open</span></span><br><span class="line">        <span class="comment">// window.open(`/api/file/download?fileName=$&#123;fileName&#125;&amp;type=$&#123;type&#125;`, '_blank')</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> json = <span class="keyword">await</span> response.json()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (json &amp;&amp; json.code === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = json.data</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">'content'</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([data.toString()])</span><br><span class="line">          downloadFile(fileName, blob)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'base64'</span>) &#123;</span><br><span class="line">          downloadFile(fileName, data)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'path'</span>) &#123;</span><br><span class="line">          <span class="built_in">window</span>.open(data, <span class="string">'_blank'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实当这里type为file的时候直接返回文件，是可以不需要发起http请求，直接<code>window.open()</code>就可以的，这里只是为了演示，实际开发中建议返回文件直接<code>window.open()</code> 或者 <code>&lt;a downlaod href=&quot;&quot;&gt;&lt;/a&gt;</code>。</p>
<p>其次<code>/api/file/download?fileName=logo.png&amp;type=content</code> 可以下载图片，不过无法打开。为什么呢，首先这是一张图片，<code>type=content</code>只是返回了图片文件的内容，浏览器接收到了文件的内容，可是并不知道用什么格式去解析，所以这里导致图片下载下来了，然后并不能预览。所以<strong>服务器返回文件内容需要双端约定好文件格式</strong>。然而就算如此，浏览器也需要将起转成<code>Blob</code>或者是其他文件对象再下载下来。</p>
<p>相对于<code>base64</code>字符串，也是要使用<code>URL.createObjectURL</code>将其转成<code>Data URLs</code>，相对来讲<code>base64</code>浏览器就无需关注文件格式了。</p>
<p>最方便处理的莫过于直接响应文件了。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>这次我们主要介绍了浏览器和服务器的生成、下载、上传文件，还介绍了浏览器中的<code>&lt;a download=&quot;fileName&quot; href=&quot;content&quot;&gt;</code>，以及 <code>new File</code>，<code>Blob</code>和<code>Data URLs</code>三种方式表达一个文件。前此文还有未提及的<code>Array Buffer</code>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseType" target="_blank" rel="noopener">XMLHttpRequest.responseType</a>需要我们后续自行了解。</p>
]]></content>
  </entry>
  <entry>
    <title>浏览器图片机制</title>
    <url>//post/image/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>浏览器中引用图片是一种很常见的情况，使用方式的不同，他们的意义也不同。比如————作为“内容主体”、“背景”、“图标”等，而设计师有时候也会提供不同的格式图片（img/png/svg/）。在不同的场景，我们对同一份图片素材，要根据图片在web界面中的意义合理运用。个人会列举浏览器常用使用图片的方式。</p>
<ul>
<li>img</li>
<li>background-image</li>
<li>icon-font</li>
<li>svg</li>
<li>webpack 与 img</li>
<li>base64</li>
</ul>
<a id="more"></a>
<h2 id="img、background-image"><a href="#img、background-image" class="headerlink" title="img、background-image"></a>img、background-image</h2><p><code>HTML</code>的<code>img</code>标签、<code>css</code>的<code>background-image</code>样式是最原始的使用图片方式，在H5时代前，相当长的一段时间都是用这两方式引用图片资源的。</p>
<p><code>&lt;img&gt;</code>标签，将图片作为<strong>内容主体</strong>引入web页面，故其是<strong>占位</strong>的；而<code>background-image</code>样式，起<strong>修饰</strong>作用，<strong>不占位</strong>。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><strong>img</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://mdn.mozillademos.org/files/7693/catfront.png"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>background-image</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"background"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.background</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">64px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'https://mdn.mozillademos.org/files/7693/catfront.png'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://mdn.mozillademos.org/files/7693/catfront.png"></p>
<div class="background"></div>

<style>
.background {
  width: 30px;
  height: 64px;
  margin: 0 auto;
  background-image: url('https://mdn.mozillademos.org/files/7693/catfront.png');
}
</style>

<p><em>虽然呈现的效果一致，意义却不一样。</em></p>
<!-- - [<img>：图像嵌入元素](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img) -->
<!-- - [background-image](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image) -->
<h3 id="img之尺寸、居中"><a href="#img之尺寸、居中" class="headerlink" title="img之尺寸、居中"></a>img之尺寸、居中</h3><p><code>img</code>标签提供了关于设置尺寸的属性，分别是<code>width</code>和<code>height</code>，单位可以是css像素，也可以是百分比。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://mdn.mozillademos.org/files/7693/catfront.png"</span>  <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><em>然而尺寸的百分比单位并不是相对于图片资源的比例，而是其容器的百分比。</em></p>
<p>所以并不推荐使用img标签的<code>width</code>及<code>height</code>设置属性，推荐使用css的<code>width</code>及<code>height</code>属性编写。</p>
<p>其实很多web开发者设置<code>100%</code>的本意是想让图片<strong>按父容器宽度自动缩放，并保持图片原本的长宽比</strong>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，<code>img</code>的居中方式也是很容易让人误解，因<code>img</code>的<code>display</code>属性为<code>inline-block</code>，其居中方式（水平、垂直都是）更是让人误解。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://mdn.mozillademos.org/files/7693/catfront.png"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">  <span class="comment">/* 垂直居中 */</span></span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="comment">/* 水平居中 */</span></span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">50%</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没想吧？居然是加在img的容器标签上，虽然绝对居中（水平、垂直都同时居中）还有其他的方法，常见的<code>margin auto</code>居中还有绝对定位50%。不过个人觉得这是最值得开发着去记住的。除此之外，也建议给容器设置<code>font-size: 0;</code>，这可以解决两个相邻的img标签之间的空隙问题。</p>
<p>说了那么多的img，现在得回过头来谈论<code>background-image</code>了。</p>
<h3 id="background-image之位置、尺寸及重复"><a href="#background-image之位置、尺寸及重复" class="headerlink" title="background-image之位置、尺寸及重复"></a>background-image之位置、尺寸及重复</h3><p>虽然前面我们说的<code>background-image</code>一直说的是css的样式特性，然而<code>background-image</code>只能指定使用的图片资源（可以是一张、也可以是多张）。背景图片样式（如本节小标题所说的位置、尺寸及重复）的设置，往往还需要结合其他css特性。</p>
<ol>
<li><p><code>background-position</code>可以给背景图片定义位置，设置的是其图片的左上角要在容器的哪个偏移度位置。</p>
</li>
<li><p><code>background-size</code> 可设置背景图片大小。<code>contain</code>理解为等比例缩放图片，高度/宽度其一先与容器尺寸相等，则停止缩放，若图片和容器宽高比例不一致，会出现白边；<code>cover</code>也是等比例缩放，高度/宽度其一先与容器尺寸相等，继续缩放，（此时图片溢出），直到另一方向的尺寸占满容器，停止缩放。</p>
</li>
</ol>
<p><img src="/post/image/background-size_contain.png" alt="background-size:contai"></p>
<p><img src="/post/image/background-size_cover.png" alt="background-size:cover"></p>
<p><strong>更简易的理解： <code>contain</code>为最小化等比例缩放图片，<code>cover</code>则为最大化等比例缩放。</strong></p>
<p>除了这两个关键字，也可以用两个单位值指定背景图片的宽高，对于绝对单位（px、em、rem）没啥好说的，对于相对单位（百分比），是相对于容器的尺寸来计算的，<strong>有意思的是<code>100% 100%</code>，这代表着破坏原比例，把图片拉伸/挤压到容器的尺寸。</strong>（很多css属性的相对单位都是根据容器来计算的，或许有特殊的属性我忘了。;-)</p>
<ol start="3">
<li><code>background-repeat</code> 设置图片重复使用的方式。</li>
</ol>
<p>以上就是关于背景常用的css样式特性，完整的css背景样式如下，并不复杂。</p>
<ul>
<li>background-attachment</li>
<li>background-clip</li>
<li>background-color</li>
<li>background-image</li>
<li>background-origin</li>
<li>background-position</li>
<li>background-position-x</li>
<li>background-position-y</li>
<li>background-repeat</li>
<li>background-size</li>
</ul>
<blockquote>
<p>不建议使用css简写属性<code>background</code>一次性设置背景特性。</p>
</blockquote>
<h3 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h3><p>CSS Sprite(CSS 精灵), 又名雪碧图，是一种图片合并技术，我们可以把一些小图，整合放在一张大图中，每次单独使用小图的时候，裁剪出指定位置，尺寸即可正常显示。</p>
<p><img src="/post/image/CSS-Sprites.gif" alt="CSS-Sprites.gif"></p>
<p>像上图就可以作为雪碧图的素材使用，以实现改方案。</p>
<p>简单分析一下这张图片：</p>
<ol>
<li>尺寸：134 * 44</li>
<li>小图数量：3</li>
<li>规范：固定大小，水平排列</li>
</ol>
<p>那我们可以定义一个通用的<code>class</code>，设置小图的尺寸；再定义一个<code>class</code>，设置图片裁剪位置即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.css-sprite</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">44px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">44px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"./CSS-Sprites.gif"</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hourse</span> &#123;</span><br><span class="line">    <span class="attribute">background-position-x</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left-arrow</span> &#123;</span><br><span class="line">    <span class="attribute">background-position-x</span>: -<span class="number">44px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right-arrow</span> &#123;</span><br><span class="line">    <span class="attribute">background-position-x</span>: -<span class="number">88px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>减少服务器压力：多图合并成一张，只发送一次HTTP请求，并且可以被缓存，有助于提升页面加载性能</li>
<li>维护困难： 后期维护成本较高，添加一张图片需要重新制作。</li>
<li>应用麻烦：每应用一张图片都需要调整位置，误差要求严格。</li>
<li>局限：只能用在背景图片<code>background-image</code>上，不能用<code>&lt;img&gt;</code>标签来使用。</li>
</ol>
<h4 id="不同方式实现-CSS-Sprites"><a href="#不同方式实现-CSS-Sprites" class="headerlink" title="不同方式实现 CSS Sprites"></a>不同方式实现 CSS Sprites</h4><p>如果会使用<code>gulp</code>、<code>webkack</code> 等构建工具，可以借助工具自动生成雪碧图。</p>
<p><a href="https://github.com/twolfson/spritesmith" target="_blank" rel="noopener">spritesmith</a>，是一个node工具，可以将多张图片合成一张图片——雪碧图，也提供了<code>grup</code>和 <code>gulp</code>插件，甚至是命令行工具。</p>
<ul>
<li><code>gulp</code> 结合<a href="https://www.npmjs.com/package/spritesmith" target="_blank" rel="noopener">spritesmith</a>的插件 <a href="https://www.npmjs.com/package/gulp.spritesmith" target="_blank" rel="noopener">gulp.spritesmith</a></li>
<li><code>webpack</code>结合对应的loader <a href="https://www.npmjs.com/package/webpack-spritesmith" target="_blank" rel="noopener">webpack-spritesmith</a> </li>
<li>svg <a href="https://www.npmjs.com/package/svg-sprite-loader" target="_blank" rel="noopener">svg-sprite-loader</a></li>
</ul>
<h2 id="icon-font"><a href="#icon-font" class="headerlink" title="icon-font"></a>icon-font</h2><p><strong>首先我们得明白，icont-font本质上不是图片，而是一种比较特殊字体，这种字体，以图标的方式显示。</strong></p>
<h3 id="web字体"><a href="#web字体" class="headerlink" title="web字体"></a>web字体</h3><p>得益于<code>css3</code>的新特性“web字体”，我们可以为自己的网页定义在线字体，无论用户是否安装了我们指定的字体，我们都可以让网页呈现出我们想要的字体，突破了传统<a href="https://developer.mozilla.org/en-US/Learn/CSS/Styling_text/Fundamentals#Web_safe_fonts" target="_blank" rel="noopener">Web-safe 字体</a>的限制。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义名为“Open Sans”字体  */</span></span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"Open Sans"</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">"/fonts/OpenSans-Regular-webfont.woff2"</span>) <span class="built_in">format</span>(<span class="string">"woff2"</span>),</span><br><span class="line">       <span class="built_in">url</span>(<span class="string">"/fonts/OpenSans-Regular-webfont.woff"</span>) <span class="built_in">format</span>(<span class="string">"woff"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 应用于网页 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"> <span class="attribute">font-family</span>: <span class="string">"Open Sans"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>web字体不是我们这次要重点的谈论范围，了解即可，这里提供了一些相关资料：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/%E4%B8%BA%E6%96%87%E6%9C%AC%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F/Web_%E5%AD%97%E4%BD%93" target="_blank" rel="noopener">Web 字体</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face" target="_blank" rel="noopener">@font-face</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family" target="_blank" rel="noopener">font-family</a></li>
</ul>
</blockquote>
<p>所以icon-font，指的是使用自定义的字体展示图标。运用了上述介绍的web字体技术。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>字体图标技术已经是web主流使用icon的一种方案了，很多UI库都内置提供了一套图标库供开发者使用，当然也可以独立使用开源的图标库，或者使用工具生成自定义的图标库。</p>
<p>这里用常用的UI框架<code>elemment-ui</code>举例，其UI库提供了<a href="https://element.eleme.cn/#/zh-CN/component/icon" target="_blank" rel="noopener">icon</a>组件，内置了图标库，使用方式也很简单。</p>
<p><img src="/post/image/element-ui_icon.png" alt></p>
<p>基本上，正确引用了icon-font，直接设置的类名即可展示对应的UI，那么我们究竟引用了什么东西呢？在<a href="https://element.eleme.cn/#/zh-CN/component/icon" target="_blank" rel="noopener">icon</a>页面上，使用<code>F12</code>打开开发者工具、找到<code>element-ui-*.css</code>源码。</p>
<p><img src="/post/image/element-ui-css.png" alt></p>
<p> 独立的开源图标库有很多，名气比较大的有<a href="https://fontawesome.com/" target="_blank" rel="noopener">Font Awesome</a>。使用方法也是类比UI库，引入相关的css源文件即可。css源文件也是类似<code>element-ui-*.css</code>的格式，引用外部资源、定义web字体、使用web字体，内置定义了<code>class</code>。直接在相关dom中使用class即可。</p>
<p>实际项目中，这种开源的集成图标库往往不能满足需求设计稿，我们需要使用一些自定义图标。我们可以使用一些工具：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a>、<a href="https://fontello.com/" target="_blank" rel="noopener">fontello</a>、<a href="https://icomoon.io/" target="_blank" rel="noopener">icomoon</a>，都是很优秀的在线生成图标库，具体使用方式网站也有介绍，不再累述。教程中引入的<code>css</code>，也是跟<code>element-ui-*.css</code>的格式类似。</p>
<h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><p>icon-font最大的特性就是样式有更多的灵活性。<strong>我们可以像处理文字一样处理图标的样式。</strong>使用<code>font-size</code>控制图标的尺寸，<code>text-align</code>、<code>line-height</code>控制其居中方式，甚至是<code>color</code>为图标设置不同的样式。</p>
<p>一般使用icon-font都是一套一套的使用，而不是一个一个独立使用，所以这对减少网络请求次数也有优势。</p>
<p>矢量图形也意味着我们可以随意调整图标大小而不用担心其失真。</p>
<p>不过icon-font只适用于纯色图标，当然渐变效果也可以使用css样式编写。</p>
<h2 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h2><p><a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics" target="_blank" rel="noopener">svg</a>——可缩放矢量图形(Scalable Vector Graphics)，是一种文件格式， 用XML 的格式定义图像。我们可以使用代码编辑器编辑svg文件，使用浏览器可直接预览。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">version</span>=<span class="string">"1.1"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">baseProfile</span>=<span class="string">"full"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"200"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span> <span class="attr">fill</span>=<span class="string">"red"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"150"</span> <span class="attr">cy</span>=<span class="string">"100"</span> <span class="attr">r</span>=<span class="string">"80"</span> <span class="attr">fill</span>=<span class="string">"green"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">"150"</span> <span class="attr">y</span>=<span class="string">"125"</span> <span class="attr">font-size</span>=<span class="string">"60"</span> <span class="attr">text-anchor</span>=<span class="string">"middle"</span> <span class="attr">fill</span>=<span class="string">"white"</span>&gt;</span>SVG<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以先将其拷贝保存为x.svg，待会用到的 。</p>
</blockquote>
<p>将在浏览器中呈现…</p>
<p><img src="/post/image/svg.png" alt></p>
<h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>有几种使用方式，第一种是直接作为标签嵌入<code>HTML</code>源码中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">svg</span> <span class="attr">version</span>=<span class="string">"1.1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">baseProfile</span>=<span class="string">"full"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"200"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span> <span class="attr">fill</span>=<span class="string">"red"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"150"</span> <span class="attr">cy</span>=<span class="string">"100"</span> <span class="attr">r</span>=<span class="string">"80"</span> <span class="attr">fill</span>=<span class="string">"green"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">"150"</span> <span class="attr">y</span>=<span class="string">"125"</span> <span class="attr">font-size</span>=<span class="string">"60"</span> <span class="attr">text-anchor</span>=<span class="string">"middle"</span> <span class="attr">fill</span>=<span class="string">"white"</span>&gt;</span>SVG<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二种是将svg代码保存为一个单独的文件，如同png，jpg，git等图片资源一样使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>img svg<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"x.svg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>object svg<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">"x.svg"</span> <span class="attr">type</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>iframe svg<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"x.svg"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>背景图片也是可以的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div-svg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#div-svg</span> &#123;</span></span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: url('./x.svg');</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h3><p>svg基于<code>XML</code>语法实现，可以用DOM选择器获取该DOM对象。前提是用第一种方式直接将svg嵌入<code>HTML</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 先给刚才的svg加上id属性 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"dom-svg"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> domSvg = <span class="built_in">document</span>.querySelector(<span class="string">'#dom-svg'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(domSvg) <span class="comment">// &lt;svg id="dom-svg" version="1.1" baseProfile="full" width="300" height="200" xmlns="http://www.w3.org/2000/svg"&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(domSvg.childNodes) <span class="comment">// NodeList(7) [ #text, rect, #text, circle, #text, text, #text ]</span></span><br><span class="line"><span class="keyword">const</span> divSvg = <span class="built_in">document</span>.querySelector(<span class="string">'#div-svg'</span>)</span><br></pre></td></tr></table></figure>
<p>如果有用过<code>icon-font</code>，会知道我们可以用多个svg制作成一套字体图标库。虽然字体图标然比传统的<code>img</code>，<code>background</code>方式有着更好的css样式灵活性，可终究直接使用的时候是纯色的。而svg有着更好的色彩表现能力，同样也是矢量图形，且可以进行DOM操作，这也意味着我们可以<strong>随时动态地改变图片的结构</strong>。<strong>而且svg不仅仅可以制作成字体图标库，也可以转换成png、jpg等传统图片格式甚至是<code>canvas</code>。</strong></p>
<blockquote>
<p> svg文件格式现在已经是主流web开发图片使用方案了，而且是目前最灵活的图片文件格式。</p>
</blockquote>
<h2 id="webpack-与-img"><a href="#webpack-与-img" class="headerlink" title="webpack 与 img"></a>webpack 与 img</h2><p><a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a>是一个前端打包工具，前端项目的每个静态资源都是一个单独的模块，<code>webpack</code>内部会<strong>自动管理这些依赖关系</strong>，编译源码时会自动根据这些依赖关系进行打开，最终生成<em>bundle</em>。其特点是拥有<strong>模块化机制</strong>、<strong>loader</strong>可以对各种类型的模块加载时运动不同的任务、<strong>插件化</strong>更是令其可以跟其他的构建工具（<code>grunt</code>、<code>gulp</code>等）结合使用、<strong>模块热替换**</strong>更是大大加大了开发速度，模块的更新无需重新加载整个页面。</p>
<p><code>webpack</code>功能多样且强大，我们本次将重点放在webpack是如何处理图片资源的。<code>webpack</code>一般是跟<code>vue</code>或者<code>react</code>框架集成使用，当然也可以独立使用。原理都差不多，框架的脚手架会基于<code>webpack</code>进行对框架场景的适合或者说扩展。为了方便，这里以<code>vue</code>为例。</p>
<h3 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h3><p><a href="https://cli.vuejs.org/zh/guide/html-and-static-assets.html#%E5%A4%84%E7%90%86%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90" target="_blank" rel="noopener">vue-cli</a>已有相关介绍，简单来说，就是在<code>template</code>中，还有在js中有不同的使用图片方式。</p>
<p>原生<code>html</code> 跟<code>vue</code>的<code>template</code>语法是一样的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./image.png"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>script</code> 或者叫<code>js</code>中是这样使用的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">imgURL = <span class="built_in">require</span>(<span class="string">'./image.png'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"require('./image.png')"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>background</code>也类同<code>&lt;img&gt;</code>。</p>
<h3 id="裂图-空图"><a href="#裂图-空图" class="headerlink" title="裂图/空图"></a>裂图/空图</h3><p>裂图：指定的图片资源地址不存在，或者加载失败（404），此时界面出现一张小的占位“裂图”；</p>
<p>空图：不指定图片资源地址，如果样式有设置尺寸大小，会根据img/background的原生特性占位。</p>
<p>裂图一般是bug，我们需要根据bug的场景去解决。</p>
<p>空图也有其使用的场景：如，初始img标签，动态加载不同的图片资源地址，默认占位。</p>
<p>实现空图也很简单，<code>src=&quot;&quot;</code> <code>:src=&quot;null&quot;</code> 即可，也可以直接不使用<code>src</code>属性。</p>
<p>有意思的是，当<code>src</code>的属性值为空时，chrome 和 firefox 渲染的DOM略有差异。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- chrome --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>(<span class="attr">unknown</span>)&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- firefox --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="小图自动转成base64"><a href="#小图自动转成base64" class="headerlink" title="小图自动转成base64"></a>小图自动转成base64</h3><p>有时候我们会发现<code>webpack</code>自动把一些小内存的图片自动转换成<code>databas64</code>格式的编码。在<code>vue-cli</code>也有相关的资料介绍 —— <a href="https://cli.vuejs.org/zh/guide/html-and-static-assets.html#%E4%BB%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%AF%BC%E5%85%A5" target="_blank" rel="noopener">从相对路径导入</a>。</p>
<p>我们知道<code>vue-cli</code>是一个集成了<code>webpack</code>常用的功能实现的<code>vue</code>脚手架，为了是配置管理<code>vue</code>项目更加方便快捷，内置静默配置了<code>webpack</code>的常用功能。</p>
<blockquote>
<p> 究其原因还是使用了<code>webpack</code>的<code>file-loader</code>处理资源最终引用的路径。<code>url-loader</code>将小于<strong>指定大小</strong>的资源转成内联（这里包括<code>css</code>、<code>javascript</code>、图片字体等静态资源），<code>css</code> <code>javascript</code> 都拥有html对用的标签，图片资源则是处理成<code>base64</code>格式。为了是节约 HTTP 请求数量。</p>
</blockquote>
<p><code>vue-cli</code>可以使用<code>chainWebpack</code>设置指定大小，如果是单独使用<code>webpack</code>，则应该配置<code>url-loader</code>，以下是参考的<code>url-loader</code>配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">　　loaders: [</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　　　test: <span class="regexp">/\.(png|jpg)$/</span>,</span><br><span class="line">　　　　　　loader: <span class="string">'url-loader?limit=8192'</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">　　]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h2><p><a href="https://zh.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">base64</a>是一种编码的方法，可以用来表示<strong>二进制</strong>数据。所以图片也可以被编码成<code>base64</code>，形成一条字符串。</p>
<p><em>试试将下面的这串字符复制在浏览器地址栏直接访问，看看是本文的出现的哪张图片。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAABACAIAAACC1lByAAAABnRSTlMAAAAAAABupgeRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAOjUlEQVR42iXWS6+t2VXe8WeMMed7W7d9OfvsOuUqW3YZ28GWLIgUJJAQNDBCIEXp5ZOELp8njdCnGymNRIJEGBxju27nfmrf1l57rfcy5xgPjfoK/8ZPf/lvf/t30ZBOMHyp8zKNT/O71+/effmuy/ZHf/0nV88uCDVqzdVgmakmT6IKHceRnq2PnHqNZIlUq3UWBsAkphYuWj2EiS8uP3k6PN7e3lOEGrpISDaZK1VEQPVUFQmAizd9FmgSkwTNOs+LRNQyQ5T0JAAkBUQgSfJq6Dfb9Xq3279/XJ4eHW6yhBpDNESkShhBGAW2zGVZpq5paOhcUD3lpgBmOh2LhglJC6GVfmim/dP9uw9tkr/6L38xbLYlkosaFRqAgwyIgQQB18TNqltthufXl7ltrc2pbbphEFGzULKKuGsok1c/POy9BBemLv35X/1ZzgVQKkTMVavwdDoeR3doqZVVmpR7bWKcoe7V57LMsz8eH8ZlSiKUSKqlgkrxOPm8FGmiJhnSZ9c/ur29/bDfb1e7zWb48PbdzYfb+TheXT9LJldX17Q6lnu3pmRQaNDj8QFaXUtSkUiLEBBErV5lmk95dZaa8fTwtF8d7u7vvvn6A4Hzi+18mp8eRmtTmcfn3/vOetciqpimPrWWl/Ak1q8MVEanFI1Q+KqpKSLGaRpP8/F4nOZlrn775vb1569LyBLFAx//8NPNs1VuxaxR0fCScpKmJxLVQJ3nERTST+NTMlCgtFNQ1FWAZRznaWyHVdO3+6e7ftPOx/nF1bNPPvvBZz/65Hi7H7bb7WZo+46lmmKyYqIaUMQ4L/NUxqd9breJYSKJMrsCzrzaXgzd7vo7Neb5VFbr3dnVdbe26+cvrl9cbjfrH//8J+3Q9+shwQSV4zydDkKlpToe6MWybXdnJppgAbgQVsFkbZfGw1KX07Dph9Ua1xTTH3z/e0lks15Jk37v93+4fzw0bU5iyihdw9MBQuES4iIwiqhUMhE01iJz0pZqNqy71So1lttWRc+252M5RURerzQ3gA+rnlB4FTVIaJNTNopOx3FZFlGCAaBORZWZKsY2VCGiOfWrVW47hW63Z3lourZ/Op1MNSWAAkmiomaKyJLW66HpV/Ay1xESwhDJVBn6PilYASrIaqB7nmpcnq9h/Nd//uU88qMX59vd9i41w6cfNWbui8/z0+Mx5Xx2sUqazne7rx/upuUoESEh0SaURXJygYgZ4OGkOQpctWuuXzz/3//zn375j78+X7c//vlPq/Pq+cXZ2e71q7d//9//x7TwP3z2gz/9yz8209Ph+L/+4f9M09GQPRaBOkMUCSJSoyaqGhcH6DqNx7HU+MV//sV2s/7q81dlnubTXJ0e/vbLr81rM+Oz3/t+bhtV++rl61e/ebWMozTBohSnG9STeRVVEY0IFfUwuh8eD/ubu2fPr/76v/7N5//2u89/9VtNctjvV33z3R9+7+Lqclh3u4tdn5uIuH91iwTA5iIpIlDpDmqKBGEAIqhMWSIUUk7z/u4hNSl3tttu1tt1VJmnSVWurp73Xdf0bdsYhGWa85B/9h9/onQqUaGmCrpEgoRQCYOqUEQtwRZdnh5P55e+TGV//5Capp4eseym47T7eAfxAEkj+Prt+2HVNN99RoEABJQSikYiESkg5vDkacmeqiSTmqF8OhymeSqTG9J4GuvD6bh+4IvrnDv3WnypxW9u3kaeM7NLVWnCZkhuA4AnKCEoqE1YtVBnaq1r8+K1LCFSc2OizbPrnxw/3H60G2qpSxQRBGOap2msSZJkJSC+JGSgqJJoEggXz1VobljR62l/3Fyuu94kQsKgAbFpXEaR/cOodt80mlQg7LuutTRDKa5MakElkAJIUKUWBZnULYMFGWLx/v3d4/4pqj8c97c396fTodb5/GJDWQ77h9N4nGs1a5NhWK1MIKImITQBiEgEAkkjXFxdjGyalSaeWMdvTof7hy8ex3n0p8Nhd3Hxs//0Ixua5X7fdSvrcj+ImJhZt27kG1EWCRAIVEESIBQpmDQ8JDQLM5PkfisfNe3h8Wjd1Nf5ojkfhv7weLy43l4+/yiZ9X3fNX1OirA2DwCERmqYmJsgUykaSd1FRNTNe7XERjft2q2mnCSlae8GfufTjzbrfrvZtKlJpikLEEIV0912m7RdWKssClDt2+5gSiEhkZSqneYcwW/xa0/vl/Lyi+n2prGcfvy9i+cXbc6qpsksJUuAiEKtSZZFWBMpc6U1IlApgaThBECJgKbcrtaDJrU27x9u5PChwyjz6fDF5yZKESSYMiELzNRg3rZJFVIDzioKd7K4AKJKR9TiYcIiwb7rNttNlJif9kIVUVpMh6emaZKaBUhQwgBGrSUipO3WoaFUJIaRoiKqnJUeEZXhlW5i0ACRcsrtKiSUIlG7YQivIgpIQExUoABUKFLbrgGTA+YwUQgDDqgynBDSvXpliVLDq2Vdn1/6sHKGZH3+wx9ECSGCNYFmoMDdw0Mg634QmkSI1IBImIZCkIgF0RBE8XkuzQQzN+ezq/P29/9Aj/vu8nz78QsXEROlJGsJiLiaqalPPmz6ZLa4gn0ojQnhrp6iZlFXNpHrsvg8PwmqZTPl9cfX691PSkyqzEr32qSUkhmgUELpEERuvt0CQsLCICWUgGllcY8aYymT18UDEbVOtY5LJRafzYzOsjAqkzZmCqSgECRImFhOmhwOVtABb1wtQqO6u6OG09wZdaGHKFJOqmTAxOalqlnTNJaEQQ+nOCQACNiY5cYUDlKCEVEUBDXczYUEa6BGKVHDwys96OHz9PR0kBIKNwUEAVdQSaOQhIgohs1aAHoCSEDIYFVElIgIKFPEUotHIQhRpQpEylgqUUsJJ1QEpIqoBhAsEiTj/Oyi789MECEaKeDGTt2DdEjKZhRVhhqookAwmj4TNVjnuYazlqoqphoUMsJLSDFLbdeknAOgzIJKUlC1SKlRVAmhmBBJGFJcu5SpQqSsAiAhOHspQXefvJZvhVAYgJxaU6EGRCkQ0BGqrspk0keohpMlXGhmYov7NI7rzWYYOi/VXasv4aE0iKmpqoopxCxhtVml1DCEDvEsYeoeYYSFipCmtKKRcq5LQFiqNu26zW1WmabJa4AAtMtt02SzLCICUqAi4U4QAKSSoR5BF3VVJAGJUIqqpTYLRLVGnTWr5maajrXGtwcACRETmIYRoUjLUhCEB4OoFkIFoSFQEVOBQcIrUqNNl9uh7ftegGWcWGnITWoASZZFFeFkeITCcmO73aaoRwhDii2kJndQqkuhZYIRVsIFKTdNNgtSm3Z6fETKKTVQNTOVCGcQdEIrIBopDZ2hcUxCiItoVQ+v1S3EmEwahGNepnlU0dS0uU8KLo7pOKmEiAoIKIJeSzDEBa4exUQ8HLCAk1pZtVQPRghVKqW6Yym+jEcGm9S1ab1/PJ3G0RlqbcrJzAQAtCzV3aswogql79ZD16h4EAEnWv3w8iiu6hokRNx9GZd5LF5cDE2Thcvp8QAoJNyreyVQa51Oo5MMhYIAvQa0kgIYoKzar+XpcCjLUrkoQlQr6vG4HI/HiKqJlvrT8RS+SFBVVaGSDscH1yoigiADHvcPD9N4EGcA7hnIenmx06a9edzPU0RkEarEcTyeDsdaKqi505QbYQpAxCAK8dPhKFRBuItXd/L4dCgupAbJCHpJxcfXX950fbPqhiY1mqWKxFyXpSzzFDG0qWdUiJhYo2qmp+mkggRElRAPFxHOU415ISFMlBKAfniz3z88PB5Oh/1+PI0sFJfA8nC3Px3mqGGteVSRUJVQqqTj4RGplSRBeiUZHpWmSzgCoAhUQtPbr1+HGLHcfPOobQ5hMvOIw+P+9DSOc1lvNs1mZ0bLpqJGOU3jqlsFjSji9Aj3Op8mqUKJUBdUCtPs1qih+u3N41I8FtnsGlou8+n29m59vh761bBqKCk3aqYBmqokAyRq8UpA9ofDzZs3dSnRqFUEFCZJDZZzMpnnU7ldVHwpl5tNB9rD3cP6m2F7frbut01KObVNbiRpCERIMujjab49PH35qy/vXn+jjuBS3brVsPv0me3Wz+GEsm1bFT+dxlJF1YDKQNfms7NdahPJzXY39D0Z7z+8b9tOQIC//uLdb3/9BirSZmaTOp+Oy7BedbtevYYos+ZxPs0TLDdPh4ebd3dl5lSfHk/7+/3dZr2uUWqd5mUK4WaziigKPT6V+7vDaqWIZX4c728ef/XbD6WW9fkFZySAdSmLtV58tUHbmFd6nbsht5ZiYSkVdFM8PNyXsrStDW0/jsdI9f7wgKj1cTo9Pr599y7medvky+uraNXn2TbdFZI6Fgpy2yyz1xJN1hBvunaz3mxWfagnS69evhJLSs1tC9H72/svP395+PD+/v7xzcv3eVw+++Tq+sWz4fn54fDU9pZCaUov0rcJ1ZfC3KdTqcdXt6c5rj6+ki6t15u2ax72jw83DwLZnG2mUv/l//7m8Wa/fzoe7u5Sma8vL07TfP1sM0LaVvvGbDN8FEuoEhI1iIhGc6kzi5fjGMKr5xeXz66c9eUXb/Z3p65vk+nLl2++/t2r+/vD/sN9N6eL3dZNR8fmk4/HMl6st9NxSgoJq4ROhT2USSOcNSzlMH39u7f/L7XfvLq7uX+6+eb+O9/9dB6Xz///6y8//8pjPuyfLmxYXwzFQIn1xZlKs+6aw+kYXpKp5Nx5eJ2mmXljic4whFUjqw9ffPH6n3/5b1i0265/+oc/Pd3cffHVa/dQk/PzYdWtLGXxGOnb5xfH+XG7zrfvH7a7jZ2fX8MBImgIR9bV2a7MBWIIkqHWd20DUTE53N9/9du3ZZ5Lmc5WQ9+027MNBhVhNwyXnz57/bt39Hp+tSZzqgWgB0FWUIiy2q0BnMYjAgAjlm4zrJ+fa07Z7Nm2h2q23LfSt7vRZ5HUDd3588vjzen+zf3Z7sWmWz+U+d8BxLQ80KidgBcAAAAASUVORK5CYII=</span><br></pre></td></tr></table></figure>
<p>这条字符串有特定的格式的，这种格式叫<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/data_URIs" target="_blank" rel="noopener"><strong>Data URL scheme</strong></a>，意为data协议（类同http协议）。base64编码不仅仅可以表示图片，也可以表示其他类型的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br></pre></td></tr></table></figure>
<p><strong>再次区别：base64是一种编码方法。Data URL表示一个文件，可以是图片，也可以是其他格式的文件。base64对其来说更是一种可选的编码方法。</strong> </p>
<h3 id="特性-3"><a href="#特性-3" class="headerlink" title="特性"></a>特性</h3><ol>
<li>体积会比原来大1/3</li>
<li>不需要请求服务器资源，减少HTTP请求次数</li>
<li>编码、解码方便，算法可逆，不适用于私密信息通信</li>
<li>无法缓存，不建议使用在改动频繁的地方</li>
</ol>
<p>js创建<code>base64</code>的方法：</p>
<ol>
<li><p><code>canvas</code> 将图片转化为 <code>base64</code> 编码</p>
</li>
<li><p><code>FileReader</code> 将图片转化<code>base64</code>格式 </p>
</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>base64</code>的使用场景比较少，个人之前的工作经历是img url 有token认证机制，直接使用<code>&lt;img src=&quot;https://HOST/xx.jpg&quot;&gt;</code>，接口状态码返回403。而后端整个api系统都是有token认证的机制，不太好改，img标签又不支持添加HTTP请求头。最后用js发起http请求，设置token请求头。</p>
<ol>
<li>使用XHR发送http请求，设置响应类型 <code>xhr.responseType = &#39;blob&#39;</code></li>
<li>构建 <code>new FileReader()</code>实例，实例事件 <code>onloadend</code>获取<code>base64</code></li>
<li>将<code>base64</code>赋值给<code>&lt;img&gt;</code>标签的<code>src</code>属性</li>
</ol>
<p>其他常见的编码格式</p>
<ul>
<li>Unicode</li>
<li>UTF-8</li>
<li>URL12</li>
<li>Unix时间戳</li>
<li>Ascii/Native</li>
<li>Hex</li>
<li>Html</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们介绍了从各个话题介绍了浏览器中使用的图片，现在是时候来一波总结了。</p>
<ol>
<li><code>img</code> / <code>background</code> - 原生<code>html</code>、<code>css</code>实现，分别作为<strong>内容主体</strong>、<strong>样式装饰</strong>功能</li>
<li><code>CSS Sprites</code> （技术方案） - 一种优化图片方案，有不同的实现方式</li>
<li><code>icon-font</code> - 基于<code>h5</code>的<code>web-font</code>特性实现，使用在线工具可生成一套矢量图片库，样式控制灵活</li>
<li><code>svg</code> - 一种很灵活的图片格式，浏览器原生支持，可转换成传统图片格式或者制作成<code>icon-font</code> </li>
<li><code>webpack</code>中使用<code>img</code> - img在工程化中的简单实现</li>
<li><code>base64</code> - 一种编码方式，格式为Data URL scheme， 可表示图片等二进制文件流</li>
</ol>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>此本从开发者拿到一张图片素材开始。以在不同场景在，选择最合适的实现方式。尽管写得比较长，可还是少了一点东西。比如<code>canvas</code>没有讲，不过一般<code>canvas</code>用于脚本绘制渲染可视化数据多一些，当然能渲染成img，场景少，就没在这里讨论。本意也是觉得一张图片在浏览器上有多种使用方式，就整理了一下，写下以上内容，算是个人的知识总结回顾吧。</p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>同步遍历调用异步请求</title>
    <url>//post/async-to-call-async-request-foreach/</url>
    <content><![CDATA[<p>业务场景：一次性发送多个http请求，并且这些请求有<strong>先后顺序</strong>之分。</p>
<a id="more"></a>
<h2 id="异步调用用单个http请求"><a href="#异步调用用单个http请求" class="headerlink" title="异步调用用单个http请求"></a>异步调用用单个http请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mock http 请求，并且服务器响应了请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockRequest</span>(<span class="params">requestBody, delayTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 随意resolve一个json即可</span></span><br><span class="line">      resolve(&#123;</span><br><span class="line">        statusCode: <span class="number">200</span>,</span><br><span class="line">        requestId: <span class="built_in">Math</span>.random().toString().split(<span class="string">'.'</span>).join(<span class="string">''</span>),</span><br><span class="line">        data: requestBody</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, delayTime || <span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的这样调用是不够的，因为是异步请求，我们需要一个回调函数（call back）</span></span><br><span class="line">mockRequest(&#123;</span><br><span class="line">  id: <span class="string">'000'</span>,</span><br><span class="line">  query: <span class="string">'a'</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getSilgleRequestData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> mockRequest(&#123;</span><br><span class="line">    id: <span class="string">'000'</span>,</span><br><span class="line">    query: <span class="string">'a'</span></span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">  <span class="keyword">if</span> (res &amp;&amp; res.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// &#123; statusCode: 200, requestId: '00896521783396853', data: &#123; id: '000', query: 'a' &#125; &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getSilgleRequestData()</span><br></pre></td></tr></table></figure>
<p>实际开发中比较常用的单个调用http请求我们已经实现了，那么也有在项目中一次操作（或者叫事件）触发多个请求，如果接口之间没有依赖关系，一般都是<strong>并发执行</strong>发送请求的。</p>
<h2 id="异步并行调用多个http请求"><a href="#异步并行调用多个http请求" class="headerlink" title="异步并行调用多个http请求"></a>异步并行调用多个http请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仍然保留之前定义的 mockRequest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一条接口</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getRequestA</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> mockRequest(&#123;</span><br><span class="line">    id: <span class="string">'00A'</span>,</span><br><span class="line">    type: <span class="string">'getRequestA'</span></span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">  <span class="keyword">if</span> (res &amp;&amp; res.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二条接口</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getRequestB</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> mockRequest(&#123;</span><br><span class="line">    id: <span class="string">'00B'</span>,</span><br><span class="line">    type: <span class="string">'getRequestB'</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">if</span> (res &amp;&amp; res.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getMutilRequestData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.time()</span><br><span class="line">  <span class="keyword">const</span> resA = <span class="keyword">await</span> getRequestA()</span><br><span class="line">  <span class="keyword">const</span> resB = <span class="keyword">await</span> getRequestB()</span><br><span class="line">  <span class="built_in">console</span>.timeEnd() <span class="comment">// 输出为？？</span></span><br><span class="line">  <span class="keyword">if</span> (resA.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resA)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (resB.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resB)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getMutilRequestData()</span><br></pre></td></tr></table></figure>
<p>因为上述两条api没有依赖关系，所以我们可以这些写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resA = <span class="keyword">await</span> getRequestA()</span><br><span class="line"><span class="keyword">const</span> resB = <span class="keyword">await</span> getRequestB()</span><br></pre></td></tr></table></figure>
<p>如果是有依赖关系的话——<code>getRequestA</code>的<strong>响应数据(response data)</strong>会被<code>getRequestB</code>作为<strong>请求参数(request data)</strong>使用，那么应该这样做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resA = <span class="keyword">await</span> getRequestA()</span><br><span class="line"><span class="keyword">if</span> (resA.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> resB = <span class="keyword">await</span> getRequestB(resA.data.id)</span><br><span class="line">  <span class="keyword">if</span> (resB.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resB)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="同步遍历中发送异步http请求"><a href="#同步遍历中发送异步http请求" class="headerlink" title="同步遍历中发送异步http请求"></a>同步遍历中发送异步http请求</h2><p>所以结合以上所有，我们需要一次性发送多条api，有顺序的要求，那么我们可以定义一个数组，这个数组的每个元素都是请求参数，循环此数组，使用递归函数的方式调用api请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... mockRequest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数，遍历requestList元素，依次发送请求，当前请求响应成功后才会发送下一个请求</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params">requestList, callback, i = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> delayTime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> mockRequest(requestList[i], delayTime+=<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">if</span> (res &amp;&amp; res.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">    callback(res)</span><br><span class="line">    <span class="keyword">if</span> (++i &lt; requestList.length) &#123;</span><br><span class="line">      getData(requestList, callback, i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义请求参数，每一个元素都是一次请求，元素的内容都是请求参数</span></span><br><span class="line"><span class="keyword">const</span> requestList = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'001'</span>,</span><br><span class="line">    query: <span class="string">'x'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'002'</span>,</span><br><span class="line">    query: <span class="string">'y'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'003'</span>,</span><br><span class="line">    query: <span class="string">'z'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">getData(requestList, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>这只是一个比较简陋的实现方案，并非最佳实践。比如此回调是每次请求成功的回调，有些业务场景需要全部请求完成后执再执行回调，还有这是依次发送请求的，也可以实现一个并行请求的方式，更多的扩展功能不再讲述。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>vue生态圈</title>
    <url>//post/vue-ecosystem/</url>
    <content><![CDATA[<p>这是一次资料整理，关于vue的生态圈。包括工具、插件，这里不按照库的类型分类。</p>
<p>思维导图体现的是<strong>这些库由什么原理实现，或者说深入了解库会接触到的一些关键点。</strong></p>
<p>官方也整理了<a href="https://github.com/vuejs/vue#ecosystem" target="_blank" rel="noopener">生态圈</a>，不过<a href="https://github.com/vuejs/vue/commit/4504cafa8dcece12538c8be4ae84fb93afcdafed#diff-04c6e90faac2675aa89e2176d2eec7d8R144-R18://github.com/vuejs/vue/commit/4504cafa8dcece12538c8be4ae84fb93afcdafed#diff-04c6e90faac2675aa89e2176d2eec7d8R144-R182" target="_blank" rel="noopener">修改记录</a>是两年前。</p>
<a id="more"></a>
<p><img src="/post/vue-ecosystem/vue-ecosystem.png" alt="vue生态圈"></p>
<p>mind文件下载地址：<a class="btn" href="/download/vue-ecosystem.xmind">传送门</a></p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue技巧篇：渲染函数 &amp; JSX</title>
    <url>//post/render-JSX/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>官方文档介绍的<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">渲染函数</a>似乎有点太过偏重表现而放轻原因。已经看过这部分好几次，还是有点不知所以然。这也不是第一次看不明白文档的介绍了，还是需要自己整理下知识点。所以，这里的内容是对文档做降级处理，好让这一块知识点更容易理解一点。文档有的东西，这里不会再重复。</p>
<p>建议阅读顺序：先粗略浏览下官方文档；精读这篇文章同时结合文档。</p>
<a id="more"></a>
<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p>先讨论render，再讨论JSX。因为JSX是为了render的编写更加方便。</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><a href="https://cn.vuejs.org/v2/guide/render-function.html#基础" target="_blank" rel="noopener">渲染函数 &amp; JSX - 基础</a> 这一小节官网介绍的是render的使用的场景。还举了个例子，真的不尽人意，起码看完我没能回答自己，render是啥。</p>
<p><a href="https://cn.vuejs.org/v2/api/#render" target="_blank" rel="noopener">render</a>是一个实例方法，跟字符串模板/template选项一样可以创建DOM。比起字符串模板，render的强大之处在于：<strong>字符串模板创建的DOM是静态的；render可以借助js的能力动态创建DOM。</strong>（不要忘了render 本质上是一个被vue框架封装的js函数）</p>
<p>静态/动态DOM如何理解？template不是也可以使用<code>v-if</code> <code>v-show</code> <code>v-for</code>之类的指令吗？<br>虽然template可以使用以上指定，对DOM进行修改，可是其无法改变HTML tag。以上的指令只是切换/移除/新增固定的HTML tag罢了。（举个反例，随机生成HTML tag 试试？）</p>
<p>官网基础这一小节，我们只需知道render是可以使用js能力创建HTML，是template的升级版就够了。</p>
<p>接下来的三个小节都是在讲如何使用render，我们先从<strong>虚拟DOM</strong>这个知识点入手。【基础】小节的例子，也会相应的介绍。</p>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/render-function.html#节点、树以及虚拟 DOM" target="_blank" rel="noopener">节点 树以及虚拟 DOM</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/render-function.html#createElement-参数" target="_blank" rel="noopener">createElement 参数</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/render-function.html#使用-JavaScript-代替模板功能" target="_blank" rel="noopener">使用 JavaScript 代替模板功能</a></li>
</ul>
<h3 id="节点、树以及虚拟-DOM"><a href="#节点、树以及虚拟-DOM" class="headerlink" title="节点、树以及虚拟 DOM"></a>节点、树以及虚拟 DOM</h3><p>HTML DOM 节点的知识点相信基础扎实的你烂熟于心了，也看过文档复习了，这里不重复。</p>
<blockquote>
<p>虚拟节点（virtual node）：描述 DOM 节点的JS对象，该对象保存着节点的相应信息。别名 <strong>VNode</strong>。</p>
</blockquote>
<p>那 DOM 是由节点组成，虚拟DOM的概念也自然很好理解：由Vnode组成的节点树结构。</p>
<p>而<code>render</code>返回的值就是一个虚拟DOM，虚拟DOM最终也会被转换为真实的DOM挂载在页面上。</p>
<h3 id="最简单的使用方式"><a href="#最简单的使用方式" class="headerlink" title="最简单的使用方式"></a>最简单的使用方式</h3><p>我学东西喜欢由简单到复杂，如果文档一开始就写个<code>Hello World</code>该多好。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"skill-render"</span>&gt;</span>skill-render<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们用<code>template</code>，<code>render</code>分别创建以上相同的dom。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// skill-template.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"skill-render"</span>&gt;</span></span><br><span class="line">    &#123;&#123;$options.name&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'skill-render'</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>自行与下面的版本找不同。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// skill-render.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">"skill-render"</span>,</span></span><br><span class="line">  render(createElement) &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> createElement(</span></span><br><span class="line"><span class="actionscript">      <span class="string">"div"</span>,</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="actionscript">        <span class="class"><span class="keyword">class</span>: "<span class="title">skill</span>-<span class="title">render</span>"</span></span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$options.name</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>终于我们知识点足够使用最简单的render，可是这里还是要说明下。<code>render</code>返回的是<code>createElement</code>函数运行后的返回值。所以其实是<strong><code>createElement</code>有能力创建虚拟DOM，而<code>render</code>依赖<code>createElement</code>的能力渲染为HTML</strong>。两者的作用很符合函数名（笑）。</p>
<p>你已经知道<code>createElement</code>可以创建虚拟DOM，现在可以好好看看 <a href="https://cn.vuejs.org/v2/guide/render-function.html#createElement-参数" target="_blank" rel="noopener">createElement 参数</a>了。</p>
<h3 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h3><p>到现在，我们才要开始讲文档的基础示例，说实话，这个示例真的挺基础。<br>文档要解决的问题其实就是要设计一个<code>anchored-heading</code>组件。</p>
<ul>
<li>这个组件里面的HTML tag（<code>h1~h6</code>）可以使用prop动态决定，并且标题内部使用了插槽。</li>
<li>而使用<code>template</code>方案，代码冗长又存在重复问题。</li>
<li>所以使用了<code>render</code>函数<strong>动态创建</strong>HTML tag。</li>
<li>在基础小节的最后还进行了一波劝退：<strong>深入渲染函数之前推荐阅读<a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">实例属性 API</a></strong>。</li>
</ul>
<h3 id="深入使用"><a href="#深入使用" class="headerlink" title="深入使用"></a>深入使用</h3><blockquote>
<p>只要在原生的 JavaScript 中可以轻松完成的操作，Vue 的渲染函数就不会提供专有的替代方法。</p>
</blockquote>
<p>文档也写得很详细了，深入底层的代价可以更好地控制交互细节。</p>
<p>这里略过不重复。</p>
<h3 id="render-h-gt-h-App"><a href="#render-h-gt-h-App" class="headerlink" title="render: h =&gt; h(App)"></a><code>render: h =&gt; h(App)</code></h3><p>当你认认真真把关于渲染函数的资料看完，你也自然理解了<code>main.js</code>中，<code>render</code>为什么这么写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>render函数并不复杂，理解其需要返回虚拟DOM，最后会挂载在页面上就可以了。编写会比较繁琐，具体的体现就是vue提供的某些指令需要自己实现。用途会比较少，不过有助于我们研究vue，如果你想之后阅读vue源码的话。</p>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>vue为了<code>render</code>编写更加方便，<code>createElement</code>可以使用JSX替换之。vue也支持JSX语法，不过需要一个<a href="https://github.com/vuejs/jsx" target="_blank" rel="noopener">Babel 插件</a>支持。</p>
<h3 id="什么是JSX"><a href="#什么是JSX" class="headerlink" title="什么是JSX"></a>什么是JSX</h3><p>JSX的定义，我们引用下<a href="https://github.com/jsx/JSX" target="_blank" rel="noopener">官网</a>的描述。</p>
<blockquote>
<p>JSX - a faster, safer, easier JavaScript</p>
</blockquote>
<p>…<br>…<br>…</p>
<p>好吧，那我按照自己的理解来介绍了。</p>
<p>JSX是JavaScript的语法扩展。类似模版语言，本质上是js语法。</p>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>安装配置也很简单，使用也有介绍。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @vue/babel-preset-jsx @vue/babel-helper-vue-jsx-merge-props</span><br></pre></td></tr></table></figure>
<p>如果是vue-cli 2.x创建的vue项目，需要<code>.babelrc</code>配置，vue-cli 3.x+安装后忽略配置，可直接使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;@vue/babel-preset-jsx&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>新建一个vue文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JSX.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">"skill-jsx-vue"</span>,</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      type: <span class="string">"vue"</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> (</span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span><br><span class="line">        hello</span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">b</span>&gt;</span> &#123;this.type&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后发现，这里甚至可以使用去掉<code>&lt;script&gt;</code>标签，直接用js文件编写，不更方便？于是我们删除<code>&lt;script&gt;</code>标签，另存为<code>JSX.js</code>，相应改变组件名还有type数据就能得到以下文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSX.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'skill-jsx-js'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type: <span class="string">'js'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;this.type&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>美哉美哉。以后可以抛弃<code>*.vue</code>文件直接使用<code>*.js</code>编写组件了，可把自己高兴坏了。我也不喜欢<code>*.vue</code>的格式。</p>
<p><img src="/post/render-JSX/vue-component.png" alt="vue-component.png"></p>
<p>经常要考虑当前行的作用域问题，是vue示例呢，还是原生js的作用域呢。</p>
<p>but！！</p>
<h3 id="vue实现css-in-js"><a href="#vue实现css-in-js" class="headerlink" title="vue实现css-in-js"></a>vue实现css-in-js</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// JSX.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// ..</span></span></span><br><span class="line">  render() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> (</span></span><br><span class="line"><span class="javascript">      &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"skill-jsx-vue"</span>&gt;</span></span><br><span class="line">        hello</span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">b</span>&gt;</span> &#123;this.type&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"stylus"</span>&gt;</span></span></span></span><br><span class="line">.skill-jsx-vue &#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure>
<p>JSX.js是原生js文件，不支持<code>&lt;style lang=&quot;stylus&quot;&gt;</code>的语法解析。那也没关系，css-in-js就是为了解决在js中编写css样式而出现的一种方案。</p>
<p><em>虽然隔壁框架也有成熟的JSX还有css-in-js解决方案，不过这与本文无关，相关内容不会讨论。</em></p>
<p>vue的css-in-js 解决方案是<a href="https://github.com/styled-components/vue-styled-components" target="_blank" rel="noopener">vue-styled-components</a>，当然不止这一个，还有其他的解决方案等待我们去探索。</p>
<p>安装完后，我们需要声明一个组件，这个组件只有样式，内容是使用插槽传入的，插槽自动定义的，这个组件供render使用即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSX.js</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'vue-styled-components'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StyledP = styled.p<span class="string">`</span></span><br><span class="line"><span class="string">  color: wheat;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'skill-jsx-js'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type: <span class="string">'js'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">StyledP</span> <span class="attr">class</span>=<span class="string">"skill-jsx-js"</span>&gt;</span>hello <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;this.type&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">StyledP</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>StyledP</code>也是一个vue组件，而<code>render</code>的<code>&lt;StyledP&gt;&lt;/StyledP&gt;</code> 相当于使用这个vue组件，组件名是js变量，大小写敏感。</p>
<p><em>思考一下，写一个带有样式的DOM，就需要声明一个vue组件，这样情况会不会造成组件滥用？</em></p>
<p>当然你可能会觉得，这是不是违背了<strong>关注点分离</strong>的原则。对于组件化系统的框架，组件是组成项目的基本单位，更加关注的是，以组件为单位，而一个组件又包括HTML、CSS、JS，vue觉得将其所有组合起来比较合理。<br><a href="https://cn.vuejs.org/v2/guide/single-file-components.html#%E6%80%8E%E4%B9%88%E7%9C%8B%E5%BE%85%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%EF%BC%9F" target="_blank" rel="noopener">怎么看待关注点分离？</a></p>
<p>当然我也会提供这一章的源码还有示例给你，还顺便实现了vue-styled-components官网的例子。</p>
<ul>
<li>JSX.vue <a href="https://github.com/Fifth-Patient/stardust/blob/master/src/views/skill/JSX/JSX.vue" target="_blank" rel="noopener">源码</a> <a href="https://fifth-patient.github.io/stardust/#/skill/JSX-vue">示例</a></li>
<li>JSX.js <a href="https://github.com/Fifth-Patient/stardust/blob/master/src/views/skill/JSX/JSX.js" target="_blank" rel="noopener">源码</a> <a href="https://fifth-patient.github.io/stardust/#/skill/JSX-js">示例</a></li>
<li>css-in-js.js<a href="https://github.com/Fifth-Patient/stardust/blob/master/src/views/skill/JSX/css-in-js.js" target="_blank" rel="noopener">源码</a> <a href="https://fifth-patient.github.io/stardust/#/skill/css-in-js">示例</a></li>
</ul>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>今天我们从render出发，知道了虚拟DOM这一很重要的概念。途中认识了JSX，最后还结合了css-in-js实现JSX+css-in-jss。可是这些东西实际作用比较低。render函数示例开发中应用场景并不多，而JSX，css-in-js，vue对其的支持又有点不知道说什么好。不过如果你是抱着<strong>研究vue的精神</strong>而不<strong>是使用vue的想法</strong>看待以上内容，相信还是对你有点帮助的。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-skill</tag>
      </tags>
  </entry>
  <entry>
    <title>git笔记</title>
    <url>//post/git-note/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>部分重要概念。</p>
<ul>
<li>HEAD</li>
<li>Working Directory / Repository / Stage</li>
<li>branch</li>
<li>remote</li>
<li>tag</li>
</ul>
<a id="more"></a>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol>
<li>打开Git Bash，配置用户名字和邮件地址</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>本机创建SSH，Github配置SSH</li>
</ol>
<p>一路回车</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></table></figure>
<p><code>win+r</code>输入<code>%USERPROFILE%/.ssh</code>,成功打开且有以下文件则成功.</p>
<ol>
<li>id_ras：私钥，不能泄露</li>
<li>id_ras.pub：公钥，可以告诉任何人</li>
</ol>
<p><strong>以下操作需要Github账号，若无需注册。</strong></p>
<p>添加SSH密钥 <a href="https://github.com/settings/keys/new" target="_blank" rel="noopener">传送门</a></p>
<p><img src="/post/git-note/github-new-ssh.png" alt="github-new-ssh.png"></p>
<ol start="3">
<li>测试配置</li>
</ol>
<ul>
<li>Github新建仓库，初始化</li>
<li>本地clone下来，修改后提交，查看提交者信息是否正确</li>
<li>推送至远端仓库，输入密码</li>
<li>再次修改后提交，若SHH配置成功，无须输入密码</li>
</ul>
<p>操作省略..</p>
<h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><table>
<thead>
<tr>
<th>简写</th>
<th>英文</th>
<th style="text-align:center">翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td>M</td>
<td>modified</td>
<td style="text-align:center">修改</td>
</tr>
<tr>
<td>R</td>
<td>renamed</td>
<td style="text-align:center">重命名</td>
</tr>
<tr>
<td>C</td>
<td>both modified</td>
<td style="text-align:center">冲突</td>
</tr>
<tr>
<td>R</td>
<td>Untracked</td>
<td style="text-align:center">未跟踪</td>
</tr>
</tbody>
</table>
<h2 id="命令分析"><a href="#命令分析" class="headerlink" title="命令分析"></a>命令分析</h2><p>一些常用的命令分析，我很喜欢命令行，不过<a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">source tree</a>也挺方便的。</p>
<h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a><code>git status</code></h3><p><strong>输出信息</strong></p>
<ul>
<li>当前分支</li>
<li>远端分支状态（是否拉取/更新）</li>
<li>暂存区</li>
<li>工作区</li>
</ul>
<p><strong>实例分析</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   src/main.js</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   src/components/person-filed/index.vue</span><br><span class="line">        modified:   src/router.js</span><br><span class="line">        modified:   src/views/loop-action/index.vue</span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== 翻译分割线 =====</span></span><br><span class="line"></span><br><span class="line">位于master分支</span><br><span class="line">您的分支超前“origin / master”一次提交。</span><br><span class="line">   （使用“git push”发布您的本地提交）</span><br><span class="line"></span><br><span class="line">要提交的更改：</span><br><span class="line">   （使用“git reset HEAD &lt;file&gt; ...”取消暂存）</span><br><span class="line"></span><br><span class="line">         修改：src / main.js</span><br><span class="line"></span><br><span class="line">未提交更改的更改：</span><br><span class="line">   （使用“git add &lt;file&gt; ...”来更新将要提交的内容）</span><br><span class="line">   （使用“git checkout  -  &lt;file&gt; ...”来丢弃工作目录中的更改）</span><br><span class="line"></span><br><span class="line">         修改：src / components / person-filed / index.vue</span><br><span class="line">         修改：src / router.js</span><br><span class="line">         修改：src / views / loop-action / index.vue</span><br></pre></td></tr></table></figure>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a><code>git commit</code></h3><p><strong>输出信息</strong></p>
<ul>
<li>提交分支</li>
<li>commit hash值</li>
<li>修改文件数量</li>
<li>增删行数</li>
</ul>
<p><strong>实例分析</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[master 2918d65] 1</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># ===== 翻译分割线 =====</span></span><br><span class="line"></span><br><span class="line"> [master 2918d65] 1</span><br><span class="line">  1个文件已更改，1行插入（+）</span><br></pre></td></tr></table></figure>
<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a><code>git checkout</code></h3><p>自修改后还没有被放到暂存区–回到版本库的状态；<br>已经添加到暂存区后，又作了修改–就回到添加到暂存区后的状态。</p>
<p>git checkout其实是用版本库里的版本替换工作区的版本，<br>无论工作区是修改还是删除，都可以“一键还原”。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>个人常用命令，整理到一块，以后忘记了就直接复制，省事也方便。</p>
<h3 id="工作区暂存区文件管理"><a href="#工作区暂存区文件管理" class="headerlink" title="工作区暂存区文件管理"></a>工作区暂存区文件管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清除工作区指定路径(&lt;path&gt;)下的所有文件修改（重置文件） / 重置未暂存的文件</span></span><br><span class="line">$ git checkout -- &lt;path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空暂存区指定路径(&lt;path&gt;)文件（不重置修改）/ 取消已暂存文件</span></span><br><span class="line">$ git reset -- &lt;path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空工作和暂存区的所有更改（重置本次提交，不会处理untracked files）</span></span><br><span class="line">$ git reset HEAD --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 untracked files(-f) 包括目录(-d)</span></span><br><span class="line">$ git clean -fd</span><br></pre></td></tr></table></figure>
<h3 id="比对文件"><a href="#比对文件" class="headerlink" title="比对文件"></a>比对文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比对指定路径（&lt;path&gt;）文件和暂存区的区别</span></span><br><span class="line">$ git diff &lt;commit&gt; -- &lt;path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比对已经暂存起来的文件(staged)和上次提交时的快照之间(HEAD)的差异</span></span><br><span class="line">$ git diff --cached</span><br><span class="line">$ git diff --staged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比对指定路径（&lt;path&gt;）两次提交</span></span><br><span class="line">$ git diff &lt;hash1&gt; &lt;hash2&gt; -- &lt;path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比对行改动，不显示具体内容</span></span><br><span class="line">$ git diff --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure>
<h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全部暂存并提交</span></span><br><span class="line">$ git commit -am <span class="string">"commit log"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行插入空行提交</span></span><br><span class="line">$ git commit -m <span class="string">'1.line-1'</span> - m <span class="string">'2.line-2'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行提交</span></span><br><span class="line">$ git commit -m <span class="string">'</span></span><br><span class="line"><span class="string">1. line-1</span></span><br><span class="line"><span class="string">2. line-2</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上一次提交信息</span></span><br><span class="line">$ git commit --amend -m <span class="string">"New commit message"</span></span><br></pre></td></tr></table></figure>
<h3 id="工作日志"><a href="#工作日志" class="headerlink" title="工作日志"></a>工作日志</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简化工作日志</span></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分支合并情况</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分支合并情况，简化提交信息、hash简写</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 美化输出、查看分支合并情况、简化提交信息、hash简写</span></span><br><span class="line">$ git <span class="built_in">log</span> --color --pretty=format:<span class="string">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'</span>  --graph  --abbrev-commit</span><br></pre></td></tr></table></figure>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重命令分支</span></span><br><span class="line">$ git branch -m &lt;old_name&gt; &lt;new_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">$ git checkout &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定提交检出新分支</span></span><br><span class="line">$ git checkout &lt;<span class="built_in">hash</span>&gt; -b &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并分支</span></span><br><span class="line">$ git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="远端"><a href="#远端" class="headerlink" title="远端"></a>远端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 远端版本信息</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加git远端仓库</span></span><br><span class="line">$ git remote add &lt;url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取远端分支提交</span></span><br><span class="line">$ git pull origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送远端分支提交</span></span><br><span class="line">$ git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取远端分支到本地新分支</span></span><br><span class="line">$ git checkout -b &lt;new_branch&gt; &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看全局配置列表</span></span><br><span class="line">$ git config --global --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地仓库配置列表</span></span><br><span class="line">$ git config --<span class="built_in">local</span> --list</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令历史</span></span><br><span class="line">$ git reflog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变基</span></span><br><span class="line">$ git rebase -i</span><br></pre></td></tr></table></figure>
<h2 id="skill"><a href="#skill" class="headerlink" title="skill"></a>skill</h2><p>一些简简单单的小技巧。</p>
<h3 id="忽略文件-目录"><a href="#忽略文件-目录" class="headerlink" title="忽略文件/目录"></a>忽略文件/目录</h3><p>根目录创建.gitignore文件。</p>
<p>windows系统需使用命令行创建，打开cmd，定位。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">type</span> nul &gt; .gitignore</span></span><br></pre></td></tr></table></figure>
<p>.gitignore文件添加需要忽略的文件/目录即可。</p>
<p>一般不需要自己编辑，github官方也提供了不同语言的.gitignore <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">传送门</a></p>
<h3 id="提交空目录"><a href="#提交空目录" class="headerlink" title="提交空目录"></a>提交空目录</h3><p>创建 .gitkeep 文件，内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Ignore everything in this directory </span><br><span class="line">* </span><br><span class="line"># Except this file !.gitkeep</span><br></pre></td></tr></table></figure>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>GIt 支持为命令自定义别名，比如我们希望<strong>全局设置</strong> <code>git br</code> 映射为 <code>git branch</code>，<strong>仓库设置</strong> <code>git st</code> 映射为 <code>git status</code>，我们可以在终端这样配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置别名</span></span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --<span class="built_in">local</span> alias.st status</span><br></pre></td></tr></table></figure>
<p>现在就可以使用<code>git br</code> 、<code>git st</code>了，不过<code>git st</code>是<strong>仓库级别</strong>的设置，切换到其他仓库就无效了。我不需要省敲几个键，这样子的映射对我无效，我需要映射的是一些很长难输入又实用的命令。我们先删除它，再配置我自己偏好的别名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除别名</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> alias.br</span><br><span class="line">git config --<span class="built_in">local</span> --<span class="built_in">unset</span> alias.st</span><br></pre></td></tr></table></figure>
<p>我们本地还有全部的别名都被删除了，当然你也可以直接修改配置文件，但是不推荐。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.logs <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br><span class="line">git config --global alias.detail-log <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br></pre></td></tr></table></figure>
<p>现在<code>git logs</code> 还有<code>git detail-log</code>都可以输出漂亮的git日志 :-)</p>
<h2 id="速查表"><a href="#速查表" class="headerlink" title="速查表"></a>速查表</h2><p><img src="/post/git-note/git-guide.jpg" alt="git-guide.jpg"></p>
<!--
- [Git log 高级用法](https://www.cnblogs.com/zhangjianbin/p/7778625.html)
- [Git config 配置](https://www.cnblogs.com/fireporsche/p/9359130.html)
- [Git diff](https://www.cnblogs.com/qianqiannian/p/6010219.html)
- [Git使用中的一些奇技淫巧](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653194157&idx=2&sn=dca9f9c61f064f508c3c17824e0c6b13&chksm=8c99f577bbee7c61d5eb51d26f007f724197435b80006b05e17381d0a11eb7b5347b58a92a05&mpshare=1)
-->
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>vue技巧篇：生命周期</title>
    <url>//post/lifecycle/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p>
</blockquote>
<p>其实对生命周期而言，我们要搞懂的是。</p>
<ol>
<li>什么阶段初始化数据</li>
<li>什么阶段初始化事件</li>
<li>什么阶段渲染DOM</li>
<li>什么阶段挂载数据</li>
</ol>
<a id="more"></a>
<h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><p><img src="/post/lifecycle/lifecycle.png" alt="lifecycle"></p>
<p>生命周期钩子函数可以分成6个类型，除了一个最少用的子孙组件错误钩子函数。<br>每个类型都有 “beforeXX” “XXed”，总共有11个生命周期钩子函数。</p>
<table>
<thead>
<tr>
<th style="text-align:center">序</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">钩子函数名 - 1</th>
<th style="text-align:center">钩子函数名 - 2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">创建</td>
<td style="text-align:center">beforeCreate</td>
<td style="text-align:center">created</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">挂载</td>
<td style="text-align:center">beforeMount</td>
<td style="text-align:center">mounted</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">更新</td>
<td style="text-align:center">beforeUpdate</td>
<td style="text-align:center">updated</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">销毁</td>
<td style="text-align:center">beforeDestroy</td>
<td style="text-align:center">destroyed</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">激活</td>
<td style="text-align:center">activated</td>
<td style="text-align:center">deactivated</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">错误</td>
<td style="text-align:center">errorCaptured</td>
<td style="text-align:center">\</td>
</tr>
</tbody>
</table>
<p>生命周期钩子官方api <a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">传送门</a></p>
<p>别看有11个钩子函数，看似一时间难以掌握。<br>其实也不是很需要全部掌握，常用的就那么几个。<br>这几个钩子函数会一一介绍，也会先大家演示一遍完整的生命周期。<br>且实际开发中我们更在意的是，这些钩子函数对组件实例数据/事件的影响。</p>
<h2 id="完整的生命周期"><a href="#完整的生命周期" class="headerlink" title="完整的生命周期"></a>完整的生命周期</h2><p>这一章基本是在翻译生命周期图示的内容。<br>不过很多开发者都对完整的生命周期流程一知半解。<br>虽然提供源码，还是<strong>建议每个人按照自己的理解写一下实例。</strong></p>
<p>新建<code>lifecycle</code>目录，定义<code>lifecycle.vue</code>，导入<code>process.vue</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- lifecycle.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lifecycle-process</span>&gt;</span><span class="tag">&lt;/<span class="name">lifecycle-process</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> LifecycleProcess <span class="keyword">from</span> <span class="string">'./process'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    LifecycleProcess</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>我们在process.vue体现完整的生命周期。</strong></p>
<p>虽然官网的示例都是<code>new Vue()</code> 初始化vue实例。<br>单文件组件(*.vue)使用<code>export default</code>也同样是初始化vue实例。</p>
<p>这里有几个概念：</p>
<ol>
<li>数据观测 (data observer) : prop， data， computed</li>
<li>事件机制 (event / watcher)： methods 函数， watch侦听器</li>
</ol>
<p>我们只简单搞清楚每个阶段发生了什么事情。其他还没有开始做的事情不想提及。<br>毕竟未开始也未完成，默认就是还没初始化嘛，有什么好说的呢？</p>
<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>本小节标题是create，是指<strong>vue实例的create阶段</strong>。<br><strong>不是生命周期钩子函数</strong> beforeCreate / created。</p>
<p>我们不打算从生命周期的钩子函数作为切入点。<br>只要搞清楚了vue实例xx阶段做了什么事情，<br>那beforeXX / XXed 的区别自然知晓。</p>
<p>我们也根据官方api的资料来表述，实例阶段做了什么事情。</p>
<blockquote>
<p>实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。</p>
</blockquote>
<p>那我们应该定义 prop， data， computed methods watch，<br>然后使用beforeCreate， created前后对比一下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// process.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// prop， data， computed methods watch</span></span><br><span class="line">  <span class="comment">// 自行定义，这里不浪费篇幅</span></span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'Hey Jude!'</span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">  watch: &#123;&#125;,</span><br><span class="line">  beforeCreate () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:orangeRed"</span>, <span class="string">'beforeCreate--实例创建前状态'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"$props  :"</span> + <span class="keyword">this</span>.$props)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"$data  :"</span> + <span class="keyword">this</span>.$data)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"computed :"</span> + <span class="keyword">this</span>.reverseMsg)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"methods  :"</span> + <span class="keyword">this</span>.reversedMsg)</span><br><span class="line">    <span class="comment">// this.msg = 'msg1'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created ()  &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">'created--实例创建完成状态'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"$props  :"</span> + <span class="keyword">this</span>.$props)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"$data  :"</span> + <span class="keyword">this</span>.$data)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"computed :"</span> + <span class="keyword">this</span>.reverseMsg)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"methods  :"</span> + <span class="keyword">this</span>.reversedMsg())</span><br><span class="line">    <span class="comment">// this.msg = 'msg2'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/post/lifecycle/beforeCreate-created.jpg" alt="beforeCreate-created.jpg"></p>
<p>prop， data， computed， methods， watch。<br>除了watch比较特殊，其他都得到了验证效果。<br>要验证也很简单，取消 beforeCreate， created 对 <code>this.msg</code>赋值的注释。<br><code>watch msg</code> 看看控制台会打印<code>msg1</code>还是<code>msg2</code>，或者两者皆可。<br>聪明的你肯定知道控制台只打印<code>msg2</code>的，所以我就不取消注释了。</p>
<h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><blockquote>
<p> el 被新创建的 vm.$el 替换。 如果根实例挂载到了一个文档内的元素上，当mounted被调用时vm.$el也在文档内。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"skill-lifecycle-process"</span>&gt;</span></span><br><span class="line">    &#123;&#123; msg &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  beforeMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:orangeRed"</span>, <span class="string">'beforeMount--挂载之前的状态'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"$el  :"</span>,<span class="keyword">this</span>.$el)</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:orangeRed"</span>, <span class="string">'mounted--已经挂载的状态'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"$el  :"</span>, <span class="keyword">this</span>.$el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/post/lifecycle/beforeMount-mounted.jpg" alt="beforeMount-mounted.jpg"></p>
<p>mount阶段，由于vue支持多种方式挂载DOM。<br>而vue实例在created之后，beforeMounted之前这一阶段，<br>对挂载DOM的方式有判断机制，这里的流程稍微复杂也比较重要。</p>
<p>多种挂载DOM的方式。</p>
<ul>
<li>el / $mout</li>
<li>template</li>
<li>render</li>
</ul>
<p>这里打算分别使用n个组件对着这几种挂载方式。<br>你可以选择暂时跳过，先走完整个周期流程再回来。</p>
<p><strong>create mount是每个组件都必须经历的生命周期，但接下来的生命周期就比较有选择性了。</strong></p>
<p>下一实例阶段 <a href="#update">update</a></p>
<hr>
<p>这里会按照判断机制的顺序介绍不同的挂载方式。</p>
<h4 id="el-mount"><a href="#el-mount" class="headerlink" title="el / $mount"></a>el / $mount</h4><p>首先会判断有无<a href="https://cn.vuejs.org/v2/api/#el" target="_blank" rel="noopener">el选项</a>声明实例要挂载的DOM。</p>
<blockquote>
<p>el选项：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。</p>
</blockquote>
<blockquote>
<p>如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译。</p>
</blockquote>
<p>el选项需要使用显示使用<code>new</code>创建的实例才生效。<br>为了方便，这里新建了<code>skill-lifecycle-el.html</code>放在public（<a href="https://cli.vuejs.org/zh/guide/html-and-static-assets.html#public-%E6%96%87%E4%BB%B6%E5%A4%B9" target="_blank" rel="noopener">静态资源目录</a>）下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- skill-lifecycle-el.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        props: &#123;&#125;,</span><br><span class="line">        data () &#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">            msg: <span class="string">'Hey Jude!'</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;&#125;,</span><br><span class="line">        methods: &#123;&#125;,</span><br><span class="line">        watch: &#123;&#125;,</span><br><span class="line">        beforeMount () &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:orangeRed"</span>, <span class="string">'beforeMount--挂载之前的状态'</span>)</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"$el  :"</span>,<span class="keyword">this</span>.$el)</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"el  :"</span> + <span class="keyword">this</span>.$el.innerHTML)</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// debugger</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        mounted () &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:orangeRed"</span>, <span class="string">'mounted--已经挂载的状态'</span>)</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"$el  :"</span>, <span class="keyword">this</span>.$el)</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"el  :"</span> + <span class="keyword">this</span>.$el.innerHTML)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"><span class="actionscript">      <span class="comment">// vm.$mount('#app')</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bdoy</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>el 还有 <a href="https://cn.vuejs.org/v2/api/#vm-mount" target="_blank" rel="noopener">vm.$mount</a> 必须要有一个，不然vue的声明周期就停止，beforeMount不触发。</strong></p>
<blockquote>
<p>vm.$mount 手动地挂载一个未挂载的实例。</p>
</blockquote>
<p>两种挂载方式的效果是一样的。</p>
<p><img src="/post/lifecycle/beforeMount-mounted-el.jpg" alt="beforeMount-mounted-el.jpg"></p>
<p><strong>值得注意的是，<code>beforeMount</code>真实的DOM确实是会渲染双花括号还有指令的，<code>mounted</code>之后会被替换成真正的数据。</strong></p>
<h4 id="template"><a href="#template" class="headerlink" title="template"></a>template</h4><p>判断完el选项，接下来会判断有无<a href="https://cn.vuejs.org/v2/api/#template" target="_blank" rel="noopener">template选项</a></p>
<blockquote>
<p>一个字符串模板作为 Vue 实例的标识使用。模板将会替换挂载的元素。</p>
</blockquote>
<p>如此说来，作用跟el选项差不多，都是挂载元素的。</p>
<p>那我们声明template选项，写上html tag string，然后把<code>#app</code> DOM里面的内容注释掉。（DOM保留）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- skill-lifecycle-template.html --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- "#app" DOM --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;p v-text="msg"&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">    &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="handlebars"><span class="xml">      template: '<span class="tag">&lt;<span class="name">b</span>&gt;</span> </span><span class="template-variable">&#123;&#123; msg &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span>', // template 选项</span></span></span><br><span class="line">      beforeMount () &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:orangeRed"</span>, <span class="string">'beforeMount--挂载之前的状态'</span>)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"$el  :"</span>,<span class="keyword">this</span>.$el)</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// debugger</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">      mounted () &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:orangeRed"</span>, <span class="string">'mounted--已经挂载的状态'</span>)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"$el  :"</span>, <span class="keyword">this</span>.$el)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"#app :"</span>, <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>))</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们在挂载后找一下<code>#app</code>还在不在。</p>
<p><img src="/post/lifecycle/beforeMount-mounted-template.jpg" alt="beforeMount-mounted-template.jpg"></p>
<p>从这图，我们可以知道：</p>
<ul>
<li><code>vm.$el</code>在<code>beforeMount</code>反应的是el选项的<code>#app DOM</code>（此时<code>#app DOM</code>还是模板状态）</li>
<li>很明显，<code>template</code>选项把el选择的#app给替换掉了，故<strong><code>template选项</code>的优先级比<code>el选项</code>/<code>vm.$mount()</code>高</strong>。</li>
</ul>
<p>el选项：比较温和，只是霸占人家的屋子自己住在里面。<br>template选项：直接端掉人家的老窝，自己筑新巢。</p>
<h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><p><a href="https://cn.vuejs.org/v2/api/#render" target="_blank" rel="noopener">render选项</a>是一个渲染函数，返回<strong>虚拟节点 (virtual node）</strong>，又名<strong>VNode</strong>。</p>
<p>render函数的用法稍微复杂，又牵扯到虚拟DOM、JSX等技术点，之后会另写一篇详细讲解。</p>
<p>假设我们现在并不明白render的用法，只知道它会返回虚拟节点，就够了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- skill-lifecycle-template.html --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">b</span>&gt;</span> </span><span class="template-variable">&#123;&#123; msg &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span>', // template 选项</span></span></span><br><span class="line"><span class="actionscript">        render: <span class="function"><span class="keyword">function</span> <span class="params">(createElement, context)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> createElement(<span class="string">'b'</span>, <span class="keyword">this</span>.msg + <span class="string">' from render'</span>)</span></span><br><span class="line"><span class="actionscript">        &#125;, <span class="comment">// render函数</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到这里template选项我们不注释，就算我们把注释掉template选项， 输出结果也还是一样。</p>
<p><img src="/post/lifecycle/beforeMount-mounted-render.jpg" alt="beforeMount-mounted-render.jpg"></p>
<p>可以粗暴理解为：render是template的升级版，template字符串模板，render返回的是由函数创建生成的VNode。</p>
<p>所以通过判断机制的流程，我们也很清楚了这几种方式挂载DOM的区别。</p>
<ol>
<li>判断有无挂载DOM：<code>el选项</code>或者 <code>vm.mount()</code>， 无则停止。</li>
<li>判断有无template选项，有则替换掉挂载DOM元素。</li>
<li>判断有无render函数，有则替换掉挂载DOM元素/template选项。</li>
</ol>
<p>这几种挂载方式是有优先级的，不过因为按照顺序分析，也不用特意去记，后面的会覆盖前面的。</p>
<h4 id="vue不同构建版本的区别（编译器、运行时）"><a href="#vue不同构建版本的区别（编译器、运行时）" class="headerlink" title="vue不同构建版本的区别（编译器、运行时）"></a>vue不同构建版本的区别（编译器、运行时）</h4><p>vuejs有不同的<a href="https://cn.vuejs.org/v2/guide/installation.html#%E5%AF%B9%E4%B8%8D%E5%90%8C%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A" target="_blank" rel="noopener">构建版本</a>，他们按照两个维度来分类，<strong>模块化</strong>及<strong>完整性</strong>。</p>
<p>模块化容易理解，这取决于使用环境的模块化机制决定。</p>
<p>完整性的话，引用官网资料。</p>
<blockquote>
<ul>
<li>完整版：同时包含编译器和运行时的版本。</li>
<li>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。</li>
<li>运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。</li>
</ul>
</blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/installation.html#%E8%BF%90%E8%A1%8C%E6%97%B6-%E7%BC%96%E8%AF%91%E5%99%A8-vs-%E5%8F%AA%E5%8C%85%E5%90%AB%E8%BF%90%E8%A1%8C%E6%97%B6" target="_blank" rel="noopener">什么时候必须使用完整版(编译器+运行时)？</a></p>
<p><code>template 选项</code>、挂载DOM（<code>el选项</code>/<code>vm.$mount</code>)，需要依赖编译器编译，这时必须使用完整版。</p>
<blockquote>
<p>当使用 <code>vue-loader</code> 或 <code>vueify</code> 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。</p>
</blockquote>
<p>可以看看三个html文件的源码引用的vue版本。</p>
<ul>
<li><a href="https://github.com/Fifth-Patient/stardust/blob/master/public/skill-lifecycle-el.html" target="_blank" rel="noopener">skill-lifecycle-el.html</a></li>
<li><a href="https://github.com/Fifth-Patient/stardust/blob/master/public/skill-lifecycle-template.html" target="_blank" rel="noopener">skill-lifecycle-template.html</a></li>
<li><a href="https://github.com/Fifth-Patient/stardust/blob/master/public/skill-lifecycle-render.html" target="_blank" rel="noopener">skill-lifecycle-render.html</a></li>
</ul>
<p>如何选择？</p>
<p>推荐运行时，拥有预编功能，性能比完整版的要好，打包资源也小；<br>一个小代价就是不能使用template选项。<br>完整版是在运行的时候编译，性能相对一般，而且也需要把编译器一起打包。</p>
<hr>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><blockquote>
<p>数据更改导致的虚拟 DOM 重新渲染和打补丁。</p>
</blockquote>
<p><strong>实例data属性更新将会触发update阶段，数据的值改变，才会触发，并不是每次赋值都会触发。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"skill-lifecycle-process"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'Hey Jude!'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">      <span class="keyword">this</span>.msg = <span class="string">'Hello World!'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    msg () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeUpdate () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:orangeRed"</span>, <span class="string">'beforeUpdate--数据更新前的状态'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"el  :"</span> + <span class="keyword">this</span>.$el.innerHTML)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"message  :"</span> + <span class="keyword">this</span>.msg)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:green"</span>, <span class="string">"真实的 DOM 结构:"</span> + <span class="built_in">document</span>.querySelector(<span class="string">'.skill-lifecycle-process'</span>).innerHTML)</span><br><span class="line">  &#125;,</span><br><span class="line">  updated () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:orangeRed"</span>, <span class="string">'updated--数据更新完成时状态'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"el  :"</span> + <span class="keyword">this</span>.$el.innerHTML)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:skyblue"</span>, <span class="string">"message  :"</span> + <span class="keyword">this</span>.msg)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:green"</span>, <span class="string">"真实的 DOM 结构:"</span> + <span class="built_in">document</span>.querySelector(<span class="string">'.skill-lifecycle-process'</span>).innerHTML)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/post/lifecycle/beforeUpdate-updated.jpg" alt="beforeUpdate-updated.jpg"></p>
<p>不难看出，vue的响应式机制是先改变实例数据。<br>此时新的实例数据并还没有挂载到DOM，只是存在于虚拟DOM(el);<br>再通过虚拟DOM重新渲染DOM元素。</p>
<p><strong>如果这个更新的数据有侦听器，侦听器会在update阶段前触发。</strong></p>
<h3 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h3><blockquote>
<p>对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</p>
</blockquote>
<p><strong>销毁指的是销毁vue的响应式系统，事件还有子实例。</strong><br>都是针对vue层面的，并非销毁DOM之意。</p>
<p>调用<code>vm.$destroy()</code>触发 <a href="https://cn.vuejs.org/v2/api/#vm-destroy" target="_blank" rel="noopener">传送门</a></p>
<p>调用这个实例方法后，DOM并没有什么变化。<br>vue实例也还是存在的，只是vue的响应式被销毁。<br>DOM与vue切断了联系。</p>
<h3 id="active"><a href="#active" class="headerlink" title="active"></a>active</h3><blockquote>
<p>被 keep-alive 缓存的组件激活/停用时调用</p>
</blockquote>
<p>这里需要在<code>lifecycle.vue</code>引用<code>process.vue</code>的地方包裹一层<code>keepa-alive</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- lifecycle.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>toggle show<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lifecycle-process</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span><span class="tag">&lt;/<span class="name">lifecycle-process</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>v-if</code>指令切换<strong>组件挂载/移除触发</strong>；<br><code>v-show</code>指令切换<strong>组件显示/隐藏不触发</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lifecycle-process.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  activated () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'activated'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  deactivated () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'deactivated'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有意思的是，<strong>页面初始化的时候，activated会在mounted之后触发。</strong></p>
<p>单纯的切换组件的挂载/移除状态，activated / deactivated 会触发；<br>组件不会重新实例化走一遍生命周期，尽管这里用是的<code>v-if</code>。</p>
<p><strong>而当我们destroy组件，之后的每一次切换挂载/移除，组件都会重新实例化，我们只是第一次destroy而已。</strong></p>
<h3 id="errorCapture"><a href="#errorCapture" class="headerlink" title="errorCapture*"></a>errorCapture*</h3><blockquote>
<p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</p>
</blockquote>
<p>这个钩子函数是用来捕获错误的，而且只应用于子孙组件，实际开发中并不常用。 <a href="https://cn.vuejs.org/v2/api/#errorCaptured" target="_blank" rel="noopener">传送门</a></p>
<p>那么整个周期流程已经介绍完毕了，同样的提供了process.vue<a href="https://github.com/Fifth-Patient/stardust/blob/master/src/views/skill/lifecycle/process.vue" target="_blank" rel="noopener">源码</a>。也可以选择重新回头深入了解<a href="#mount">mount机制</a>了。 </p>
<h2 id="常用生命周期函数"><a href="#常用生命周期函数" class="headerlink" title="常用生命周期函数"></a>常用生命周期函数</h2><p>11个钩子函数就这样介绍完了，常用的钩子函数并不多。</p>
<h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><p>此时数据/事件可用，可以在此<strong>动态创建数据或者定义自定义事件。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">this</span>.$data.staticString = <span class="string">'static'</span> <span class="comment">// 定义变量</span></span><br><span class="line">    <span class="keyword">this</span>.$on(<span class="string">'on-created'</span>, () =&gt; &#123; <span class="comment">// 定义自定义事件</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data.staticString)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>created创建的变量，更新不会被vue所监听。</strong> 在此处定义变量数据，是为了提升性能，如果这个变量更新与view层无关的话。</p>
<h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>DOM渲染完毕，可以执行页面的初始化操作（移除遮罩），获取DOM（如果有必要的话）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;  </span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">this</span>.init()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.controlPanel.$options.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>vue 并不推荐直接操作DOM，不过还是提供了<code>$ref</code>作为应急解决方案。</strong></p>
<p><a href="https://github.com/Fifth-Patient/stardust/blob/master/src/views/skill/lifecycle/useful.vue" target="_blank" rel="noopener">useful.vue</a>写的比较简单。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>然而， 本篇的内容仅仅讨论的是<strong>vue组件的生命周期</strong>相关钩子函数。<br>路由守卫，自定义指令，多个组件引用的钩子函数这些并未提及，推荐几篇文章。<br>看完相信能收获得更多。</p>
<ul>
<li><a href="https://juejin.im/entry/5aee8fbb518825671952308c" target="_blank" rel="noopener">vue 生命周期深入</a> 针对多个组件引用情况（父子、兄弟组件）等情况生命周期的执行顺序</li>
<li><a href="https://segmentfault.com/a/1190000008879966" target="_blank" rel="noopener">vue生命周期探究（一）</a> 包括组件、路由、自定义指令等共计28个的生命周期</li>
<li><a href="https://segmentfault.com/a/1190000008923105" target="_blank" rel="noopener">vue生命周期探究（二）</a> 路由导航守卫的钩子函数执行顺序</li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-skill</tag>
      </tags>
  </entry>
  <entry>
    <title>vue技巧篇：组件通讯</title>
    <url>//post/component-communication/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>组件化</strong>也是vue的一大特点之一，组件是组成vue项目的基本单位。<br>一个组件可以做什么？ 这取决于组件的设计，组件一般由以下几点组成：</p>
<ul>
<li>选项</li>
<li>实例属性/方法</li>
<li>生命周期</li>
<li>全局API</li>
<li>指令</li>
<li>导入的其他组件</li>
</ul>
<p><strong>组件是可复用的vue实例，可以复用，导入导出，组成组件化系统。</strong></p>
<p>vue的组件都是保持相对独立的关系，可是又可以进行相互依赖（导入导出机制）；<br>这种规范下，实际开发又难免会出现组件之间<strong>传递数据</strong>、<strong>转发事件</strong>的场景。<br>而vue又对组件间的数据、事件做了一定的限制；<br>正因如此，我们需要好好探讨vue的组件通讯。</p>
<a id="more"></a>
<h2 id="父子组件通讯"><a href="#父子组件通讯" class="headerlink" title="父子组件通讯"></a>父子组件通讯</h2><p>由于组件通讯，有时候是为了<strong>传递数据</strong>，而有时候是为了<strong>转发事件</strong>；<br>这里不对这两种场景做区分，统一要解决的场景为“组件通讯”。</p>
<p>其实vue组件通讯并不复杂，官方文档提供了几个方法。</p>
<ul>
<li>props 向子组件传递数据 <a href="https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87-Prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener">传松门</a></li>
<li>emit 向父组件抛出事件 <a href="https://cn.vuejs.org/v2/guide/components.html#%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener">传送门</a></li>
<li>v-model 父子组件数据同步（带有一定的抛出事件机制） <a href="https://cn.vuejs.org/v2/guide/components.html#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-v-model" target="_blank" rel="noopener">传送门</a></li>
<li>props+sync修饰符 <a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">传松门</a></li>
<li>slot-scope 作用域插槽 <a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD" target="_blank" rel="noopener">传送门</a></li>
</ul>
<p>由于官方文档介绍得很详细，也提供了<strong>传送门</strong>，具体实现并不详细介绍。<br>不过vue组件有一个设计概念还是有大家了解下的——单向数据流 <a href="https://cn.vuejs.org/v2/guide/components-props.html#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81" target="_blank" rel="noopener">传送门</a></p>
<h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><blockquote>
<p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p>
</blockquote>
<p><strong>而如果需要改变父组件的数据，则子组件抛出事件；父组件定义自定义事件，在自定义事件中改变自己的数据。</strong></p>
<hr>
<p>这些方法有所缺点，不同的业务场景需要开发者自行衡量；<br>不过适应的业务场景都<strong>局限于父子组件的通讯</strong>。</p>
<p><strong>其实父子组件通讯的是最好解决的，毕竟有直接联系。</strong></p>
<h2 id="非父子组件通讯"><a href="#非父子组件通讯" class="headerlink" title="非父子组件通讯"></a>非父子组件通讯</h2><p><strong>由于非父子组件没有直接联系，只能使用间接联系。<br>两个组件使用相同的“代理“，由”代理“转发数据或者事件的交互。</strong></p>
<p>”代理“各式各样，也有不同的实现方式。</p>
<p><em>备注：这里的“代理”是中转站的意思，为了方便理解，表述为：“代理”。</em></p>
<p>官方也提供几种解决方案：</p>
<ul>
<li><code>$root.data</code> <a href="https://cn.vuejs.org/v2/guide/state-management.html#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">传送门</a></li>
<li>vuex <a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">传送门</a></li>
<li>vue-router <a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">传送门</a></li>
</ul>
<h3 id="root-data"><a href="#root-data" class="headerlink" title="$root.data"></a><code>$root.data</code></h3><p>我们知晓：一个vue项目由组件为单位组成。<br>但是，一个vue项目只有一个根组件。<br>且所有组件实例均可访问根组件实例<code>this.$root</code>。<br>官方文档也提供了相应的实现方式<a href="https://cn.vuejs.org/v2/guide/state-management.html#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">传送门</a>。</p>
<p>实际开发中，并不使用这种方式进行组件通讯。<br>我们并不希望<code>$root.data</code> 挂载庞大的数据变量。<br>我们仅希望他只负责渲染HTML DOM元素。</p>
<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>vuex专用于vue项目，作为<strong>状态管理模式</strong>插件。（理解为集中存储全局变量的地方就好了。）</p>
<p>前面说到“单向数据流”理念，并不适用<strong>多个组件共享状态</strong>场景。</p>
<blockquote>
<p>因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！<br>通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。</p>
</blockquote>
<p>vuex的核心是store（仓库），”store”是一个容器，包含应用中大部分的状态(state)，与单纯的全局对象有两点不同：</p>
<ul>
<li>Vuex 的状态存储是响应式的。</li>
<li>不能直接改变 store 中的状态，若想改变，唯一途径就是显式地提交 (commit) mutation。</li>
</ul>
<p>一个store可以包含<br>state：储存状态   单一状态树<br>action： 提交mutation方法，可执行异步操作<br>mutation：更改store状态，必须是同步操作<br>getter：从state派生状态，返回值会根据依赖缓存<br>modules：将store分割成模块</p>
<p><img src="/post/component-communication/vuex-Flux.png" alt="vuex-Flux"></p>
<p>简单分析下这张图：</p>
<ol>
<li>State 直接渲染在vue组件</li>
<li>组件可以可以通过Dispatch触发 Actions</li>
<li>Actions可以Commit触发Mutations</li>
<li>Mutations可以Mutate更改State</li>
<li>vue组件计算属性更新State的值</li>
</ol>
<p>还有几个注意点：</p>
<ul>
<li>vuex的范围：组件外部的 State =&gt; Actions =&gt; Mutations =&gt; State</li>
<li>Actions、Mutations： Actions可以执行异步（一般用于后端Api交互）、Commit Mutations；Mutations必须是同步，（一般用于更改State状态）</li>
<li>执行顺序：组件也可以跳过Actions 直接 Commit Mutations， 不过执行顺序是不可逆的。</li>
<li>Actions是可以Dispatch 其他Actions的，同理一个Actions也可以Commit 多个Mutations</li>
</ul>
<h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><p>vue-router也可以拥有组件通讯的能力，不过这些组件针对的是直接挂载在路由的<strong>页面组件</strong>。</p>
<ul>
<li>路由元信息 <a href="https://router.vuejs.org/zh/guide/advanced/meta.html" target="_blank" rel="noopener">传送门</a></li>
<li>路由组件参数 <a href="https://router.vuejs.org/zh/guide/essentials/passing-props.html" target="_blank" rel="noopener">传送门</a></li>
<li>导航守卫 <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener">传送门</a></li>
<li><code>$route.query</code> <a href="https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">传送门</a></li>
</ul>
<h3 id="总线模式（bus）"><a href="#总线模式（bus）" class="headerlink" title="总线模式（bus）"></a>总线模式（bus）</h3><p>总线模式需要实例化一个空Vue实例，我们把非父子组件的事件统一集中到这个空Vue实例，让这个实例监听，触发这些自定事件就可以。</p>
<p><code>Vue</code> 其实是一个构造函数，既然是构造函数，那就可以多次实例化。<br>而构造函数又有原型对象<code>prototype</code>，原型就是为了共享。</p>
<p>那第一步我们可以在Vue的原型对象上实例化一个空Vue实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype.bus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure>
<p><em>备注：如果是大规模使用，可以在<code>main.js</code>直接定义原型bus属性。局部使用可以包装成一个js模块，需要时引入即可。</em></p>
<p>再看实例事件</p>
<ul>
<li><a href="https://cn.vuejs.org/v2/api/#vm-on" target="_blank" rel="noopener">vm.$on</a> </li>
<li><a href="https://cn.vuejs.org/v2/api/#vm-emit" target="_blank" rel="noopener">vm.$emit</a></li>
</ul>
<p>我们可以知晓：$emit 会触发 $on 就可以了。</p>
<p>准备一个文件夹 bus，定义三个组件:</p>
<ul>
<li><code>bus.vue</code></li>
<li><code>bus-child1.vue</code></li>
<li><code>bus-child2.vue</code></li>
</ul>
<p>我们要做的是让child1触发child2事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bus.vue 引入 child1, child2· --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bus-child1</span> <span class="attr">content</span>=<span class="string">"skill-bus-child1"</span>&gt;</span><span class="tag">&lt;/<span class="name">bus-child1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bus-child2</span> <span class="attr">content</span>=<span class="string">"skill-bus-child2"</span>&gt;</span><span class="tag">&lt;/<span class="name">bus-child2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bus-child1.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">      <span class="keyword">this</span>.bus.$emit(<span class="string">'on-change'</span>, <span class="keyword">this</span>.selfContent)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bus-child2.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleChange ($event) &#123;</span><br><span class="line">      <span class="keyword">this</span>.selfContent = $event</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">this</span>.bus.$on(<span class="string">'on-change'</span>, <span class="keyword">this</span>.handleChange)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bus.vue <a href="https://github.com/Fifth-Patient/stardust/blob/master/src/views/skill/bus/bus.vue" target="_blank" rel="noopener">源码</a></p>
<p>然而总线模式还是有带来一定的作用域问题，由于非父子组件的事件统一集中到空Vue实例，这导致了这些被空vue实例监听的自定义事件，在所有的组件是共享的，这种情况下，很容易产生副作用。</p>
<p>若再增加一个<code>bus-child3.vue</code>，它也监听了<code>this.bus.$on(&#39;on-change&#39;, this.handleChange)</code>。<br>而其实我们并不想<code>bus-child3.vue</code>响应 <code>bus-child1.vue</code>事件。</p>
<p>说白了就是作用域太广，bus是全局作用域；<br>又或者说没有命令空间，相同的事件名不能在两个组件定义。</p>
<p><strong>其实这种解决方案之于<code>$root.dat</code>是换汤不换药的，都是把不同组件的数据/事件集中到一个vue实例。</strong></p>
<h3 id="emitter-dispatch-broadcast"><a href="#emitter-dispatch-broadcast" class="headerlink" title="emitter (dispatch / broadcast)"></a>emitter (dispatch / broadcast)</h3><p>如果两个组件，有相同的父组件，可以使用<strong>事件派发与广播机制</strong>处理非父子组件通讯。<br>其实都会有相同的父组件的，再不济最顶层就是vue的根实例了，不过一般不需要到根实例。</p>
<p> 派发/广播机制很依赖组件层级关系。<br>派发(dispatch):由本组件向上派发事件，供上层组件监听处理。<br>广播(broadcast)：由本组件向下广播事件，供下层组件监听处理。</p>
<p><strong>Element UI 框架源码的<a href="https://github.com/ElemeFE/element/blob/dev/src/mixins/emitter.js" target="_blank" rel="noopener">emitter.js</a>就是基于派发广播机制处理非父子组件的通讯。<br>源码的emitter.js把其机制封装成了一个独立的mixin，以便在各个组件方便使用。</strong><br>这里就以emitter.js为例子，简单讲解是如何实现的，还有如何使用这个mixin。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简化emitter.js, 只提取出结构</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span> (<span class="params">componentName, eventName, params</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准mixins结构</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">      <span class="comment">// 定义dispatch方法，需要三个参数</span></span><br><span class="line">      <span class="comment">// @params componentName 派发给哪个上层组件</span></span><br><span class="line">      <span class="comment">// @params eventName        派发的事件名</span></span><br><span class="line">      <span class="comment">// @params params             事件携带参数</span></span><br><span class="line">      dispatch (componentName, eventName, params) &#123;&#125;,</span><br><span class="line">      <span class="comment">// 定义broadcast方法，需要三个参数</span></span><br><span class="line">      <span class="comment">// @params broadcast           广播给哪个下层组件</span></span><br><span class="line">      <span class="comment">// @params eventName        广播的事件名</span></span><br><span class="line">      <span class="comment">// @params params             事件携带参数</span></span><br><span class="line">      broadcast (componentName, eventName, params) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>componentName</code> 指的是定义组件时，组件的选项name <a href="https://cn.vuejs.org/v2/api/#name" target="_blank" rel="noopener">传送门</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'component-name'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟总线模式一样，我们也要定义一个文件夹——<code>emitter</code>，三个组件</p>
<ol>
<li><code>emitter.vue</code></li>
<li><code>child1.vue</code></li>
<li><code>child2.vue</code></li>
</ol>
<p>同样让child1触发child2事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- emitter.vue 引入 child1 child2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">emitter-child1</span> <span class="attr">content</span>=<span class="string">"emitter-child1"</span>&gt;</span><span class="tag">&lt;/<span class="name">emitter-child1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">emitter-child2</span> <span class="attr">content</span>=<span class="string">"emitter-child2"</span>&gt;</span><span class="tag">&lt;/<span class="name">emitter-child2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里<code>child1</code>,<code>child2</code>是兄弟组件，他们共同拥有父组件<code>emitter.vue</code>。<br>所以<code>child1</code>要触发<code>child2</code>事件，需要<code>emitter.vue</code>的帮助。</p>
<ol>
<li>child1派发事件到emitter.vue</li>
<li>emitter定义监听事件，广播到child2</li>
<li>child2定义监听，接收emitter的广播事件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// child1.vue 派发事件到 emitter.vue</span></span><br><span class="line"><span class="keyword">import</span> Emitter <span class="keyword">from</span> <span class="string">'@/mixins/Emitter'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mixins: [ Emitter ],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">      <span class="keyword">this</span>.dispatch(<span class="string">'skill-emitter'</span>, <span class="string">'on-child1-change'</span>, <span class="keyword">this</span>.selfContent)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// emitter.vue 定义监听事件，广播到 child2.vue</span></span><br><span class="line"><span class="keyword">import</span> Emitter <span class="keyword">from</span> <span class="string">'@/mixins/emitter'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mixins: [ Emitter ],</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="comment">// 代理child1派发的on-child1-change事件</span></span><br><span class="line">    <span class="comment">// 该事件不在此组件处理</span></span><br><span class="line">    <span class="comment">// 广播给child2的on-change事件处理</span></span><br><span class="line">    <span class="keyword">this</span>.$on(<span class="string">'on-child1-change'</span>, e =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.broadcast(<span class="string">'skill-emitter-child2'</span>, <span class="string">'on-change'</span>, e)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// child2.vue 定义监听，接收 emitter.vue 的广播事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleChange ($event) &#123;</span><br><span class="line">      <span class="keyword">this</span>.selfContent = $event</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">this</span>.$on(<span class="string">'on-change'</span>, <span class="keyword">this</span>.handleChange)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emitter.vue <a href="https://github.com/Fifth-Patient/stardust/blob/master/src/views/skill/emitter/emitter.vue" target="_blank" rel="noopener">源码</a></p>
<p>派发/广播机制对比总线模式，限制了事件必须是具体的某个组件的，使得事件的传递更加精确可控。</p>
<p>emitter.vue 是兄弟组件实例，如果是上下层的组件。<br>不需要经过如emitter.vue的代理，直接在目标组件监听自定义事件。</p>
<p>不管是dispatch还是broadcast方法，都很依赖<code>componentName</code>，还有<code>eventName</code>，<br>所以<strong>良好的命名规范是非常重要的</strong>，dispatch/broadcast到指定的组件的xx事件。<br>该指定的组件<code>this.$on</code>监听自定义事件就可以触发。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天我们从组件通讯的解决方式出发，介绍到了多种组件通讯的解决方案。<br>以前觉得组件通讯无非就是这几种。</p>
<ol>
<li>prop &lt;=&gt; emit</li>
<li>vuex</li>
<li>bus</li>
<li>dispatch / broadcast</li>
</ol>
<p>好好的梳理出来才发现其实在很多场景我们都需要用到组件通讯。<br>只是我们太过习以为常，反而有点忽略了也是其解决方案之一。</p>
<p>在实例开发中，我们也需要结合实际场景思考，是否以上的解决方案是否适用。</p>
<p>一般情况下，我是支持使用dispatch/broadcast模式去处理大多数的非父子组件通讯的。<br>可有时候要一个组件触发各自触发n个组件的事件，这种模式可能编写起来比较繁琐。<br>这个时候可以考虑总线模式，又或者，为了一处比较特殊的处理，是否考虑要引入一个mixins。<br>这些问题都是需要开发者是在实际开发的时候好好去估量利弊的，并没有一种万能的解决方案。<br>（对我来讲，dispatch/broadcast 就已经很万能了。）</p>
<p>还有这里想吐槽一下。</p>
<blockquote>
<p>Flux 架构就像眼镜：您自会知道什么时候需要它 。–Dan Abramov (Redux 的作者)</p>
</blockquote>
<p>说真的，直到现在我完全不能理解这句充满诗意的话，以及为什么偏偏是像眼镜而不是心灵的窗户？！</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-skill</tag>
      </tags>
  </entry>
  <entry>
    <title>vue技巧篇：自定义双向绑定</title>
    <url>//post/two-way-binding/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>双向绑定</strong> 是 <code>vue</code> 的一大特点之一，使用也非常方便。<br>在需要双向绑定的<strong>表单控件元素</strong>使用指令 <code>v-model</code>即可。</p>
<p>官方文档教程 —— 表单输入绑定（<a href="https://cn.vuejs.org/v2/guide/forms.html" target="_blank" rel="noopener">传送门</a>）<br>官方文档api —— v-model 指令（<a href="https://cn.vuejs.org/v2/api/#v-model" target="_blank" rel="noopener">传送门</a>）</p>
<p>注意了：到目前为止，<strong>双向绑定只是针对表单控件元素，并没有说明其他DOM元素，或者是自定义组件。</strong></p>
<p>那我们要如何实现在组件（或者说其他DOM元素）的双向绑定呢？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-components</span> <span class="attr">v-model</span>=<span class="string">"fieldValue"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-components</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="v-model-浅析"><a href="#v-model-浅析" class="headerlink" title="v-model 浅析"></a><code>v-model</code> 浅析</h2><blockquote>
<p>v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。<br>v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。<br>v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件；</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件；  </li>
<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>
</ul>
</blockquote>
<p>节选几段官方文档的资料，不难察觉<code>v-model</code> 会<strong>占用一个 <code>prop</code> 属性和一个 <code>$emit</code> 事件</strong>。<br>如果有冲突，也是可以更改的。</p>
<p>如果还是好奇 <code>v-model</code>的实现原理，我可以告诉你大概是这样。</p>
<blockquote>
<p><strong>双向绑定基于getter/setter 结合观察者模式实现</strong><br>getter/setter指<code>Object.defineProperty</code>遍历vue实例的<code>data</code>选项<br>观察者模式是js的一种设计模型，可以实现发布订阅功能</p>
</blockquote>
<h2 id="组件使用双向绑定（基本类型版）"><a href="#组件使用双向绑定（基本类型版）" class="headerlink" title="组件使用双向绑定（基本类型版）"></a>组件使用双向绑定（基本类型版）</h2><!-- 组件使用双向绑定并不罕见，很多vue的ui框架包装的组件都支持直接使用`v-model`指令。 -->
<p>有了相应的资料，我们可以开工了。准备一个组件 <code>base-input.vue</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'base-input'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      fieldValue: <span class="keyword">this</span>.value <span class="comment">// 初始化赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    value (newVal) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fieldValue = newVal <span class="comment">// 监听props（外部）更新，赋值给data（内部）</span></span><br><span class="line">    &#125;,</span><br><span class="line">    fieldValue () &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="keyword">this</span>.fieldValue) <span class="comment">// data（内部）更新，抛出到外部</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"fieldValue"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有几个注意点要说明下：</p>
<ol>
<li><code>fieldValue</code>  必须初始化赋值为 <code>props</code> 的 <code>value</code></li>
<li>初始化页面时 <code>watch</code> 并不执行</li>
<li>内部更新，触发 <code>fieldValue</code> 监听函数</li>
<li>外部更新，触发 <code>value</code>监听函数</li>
</ol>
<ul>
<li>base-input 源码 <a href="https://github.com/Fifth-Patient/stardust/blob/master/src/views/skill/two-way-binding-base-type/base-input/base-input.vue" target="_blank" rel="noopener">传送门</a></li>
<li>示例 <a href="https://fifth-patient.github.io/stardust/#/skill/two-way-binding-base-type">传送门</a></li>
</ul>
<h3 id="value-与v-model"><a href="#value-与v-model" class="headerlink" title=":value 与v-model"></a><strong><code>:value</code> 与<code>v-model</code></strong></h3><p>因为之前被这两个搞混过，不明白之间的联系和区别，这里单独拿出来讲一下。</p>
<ul>
<li><code>:value</code> 是绑定一个<code>prop value</code> 给组件，实现外部数据传入内部， <strong>单向绑定</strong></li>
<li><code>v-model</code> 是<strong>双向绑定</strong>，默认占用<code>prop value</code> 属性和一个 <code>$emit input  事件</code>;<br>在<code>:value</code> 的基础上<code>$emit input</code>实现内部数据抛出外部，从而外部、内部数据达成同步且外内均可更改。</li>
</ul>
<p>把 <code>base-input v-model=&quot;inputValue&quot;&gt;&lt;/base-input&gt;</code> 换成 <code>:value=&quot;inputValue&quot;</code>试试？</p>
<p><em>我们也将在下一节更改指令默认使用的<code>prop</code> 属性 和<code>$emit</code> 事件</em></p>
<p><strong>可其实这种方式只支持js的基本类型，像对象或者数组的引用类型，这样处理是不够的，所以我们需要对现有的双向绑定方式进行升级。</strong></p>
<h2 id="组件使用双向绑定（引用类型版）"><a href="#组件使用双向绑定（引用类型版）" class="headerlink" title="组件使用双向绑定（引用类型版）"></a>组件使用双向绑定（引用类型版）</h2><p>准备另一个组件：<code>base-div.vue</code></p>
<p>把<code>base-input.vue</code> 的代码复制过来，组件名，类名什么的这些标识信息该改的就改一改。</p>
<p>然后可能有的朋友到这里会把 <code>prop value</code> 的 <code>type</code> 改成 <code>Object</code>，这只是第一步而已。</p>
<p>因为引用类型的特性，我们手动给内部变量赋值，会更改其引用地址，故相当于重新初始化了一个变量。<br>这里会触发另一个watch函数，而另一个watch也具备给内部变量赋值的能力；</p>
<p>如果不特殊处理，这两个watch 函数触发其中一个，就会不断调用另一条，造曾死循环。<br>所以我们需要判断当内外部变量相等的时候，就不赋值了。嗯，<strong>判断两个对象相等</strong>。</p>
<p><strong>判断两个对象相等可能有点尴尬， 那我们把两个对象序列化为JSON 字符串就可以了。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(obj1) === <span class="built_in">JSON</span>.stringify(obj2);</span><br></pre></td></tr></table></figure>
<p>技术点已经准备够了，我们足够实现用<code>v-model</code>绑定一个对象了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: [ <span class="built_in">Object</span>, <span class="built_in">Array</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      fieldValue: <span class="keyword">this</span>.value,</span><br><span class="line">      fieldValueStringify: <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.value) <span class="comment">// 保存外部传入的变量快照，将在监听器中做比较使用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      deep: <span class="literal">true</span>, <span class="comment">// 深度监听</span></span><br><span class="line">      handler (newVal) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentValue = <span class="built_in">JSON</span>.stringify(newVal)</span><br><span class="line">        <span class="comment">// 外部传入的变量与内部变量比较</span></span><br><span class="line">        <span class="comment">// 不相等，内部变量方可赋值为this.value</span></span><br><span class="line">        <span class="comment">// * 内部变量赋值，将会触发fieldValue监听函数</span></span><br><span class="line">        <span class="comment">// 且此时应更新fieldValue 对象字符串快照</span></span><br><span class="line">        <span class="keyword">if</span> (currentValue !== <span class="keyword">this</span>.fieldValue) &#123;</span><br><span class="line">          <span class="keyword">this</span>.fieldValue = <span class="built_in">JSON</span>.parse(currentValue)</span><br><span class="line">          <span class="keyword">this</span>.fieldValueStringify = currentValue</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fieldValue: &#123;</span><br><span class="line">      deep: <span class="literal">true</span>, <span class="comment">// 为什么要使用深度监听呢？</span></span><br><span class="line">      handler (newVal) &#123;</span><br><span class="line">        <span class="comment">// 自己改变内部变量，或者因外部变量更新手动赋值内部变量</span></span><br><span class="line">        <span class="comment">// 这个函数都会被触发</span></span><br><span class="line">        <span class="comment">// 要实现的是内部与外部变量同步，所以快照才是保存外部变量</span></span><br><span class="line">        <span class="comment">// 1.当外部变量改动，会先调用 watch value，此时内外部变量同步</span></span><br><span class="line">        <span class="comment">//   这时不需要抛出事件，否则出现死循环</span></span><br><span class="line">        <span class="comment">// 2.当内部变量改动，会先调用 watch fieldValue</span></span><br><span class="line">        <span class="comment">//   抛出事件，外部的v-model又会自动更新内部的value</span></span><br><span class="line">        <span class="comment">//   从而触发 watch value</span></span><br><span class="line">        <span class="comment">//  （这里触发watch value了，可以回去看看1）</span></span><br><span class="line">        <span class="comment">//   如果你不会兜兜转，那我想你应该feel到了整个更新流程</span></span><br><span class="line">        <span class="comment">// **如果被兜住了，先理解外部变量的改动，再理解内部变量的改动</span></span><br><span class="line">        <span class="keyword">const</span> currentValue = <span class="built_in">JSON</span>.stringify(newVal)</span><br><span class="line">        <span class="keyword">if</span> (currentValue !== <span class="keyword">this</span>.fieldValueStringify) &#123;</span><br><span class="line">          <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="built_in">JSON</span>.parse(currentValue))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>base-div 源码 <a href="https://github.com/Fifth-Patient/stardust/blob/master/src/views/skill/two-way-binding-reference-type/base-div/base-div.vue" target="_blank" rel="noopener">传送门</a></li>
<li>示例 <a href="https://fifth-patient.github.io/stardust/#/skill/two-way-binding-reference-type">传送门</a></li>
</ul>
<p>接下来我们不使用 <code>prop value</code> <code>$emit input</code>了，我们使用 <code>prop insert</code> <code>$emit output</code>。</p>
<p>直接在<code>base-div</code> 改动吧，其实也不复杂。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;  </span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">'insert'</span>,</span><br><span class="line">    event: <span class="string">'output'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    insert: &#123;</span><br><span class="line">      type: [<span class="built_in">Object</span>, <span class="built_in">Array</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      fieldValue: <span class="keyword">this</span>.insert,</span><br><span class="line">      fieldValueStringify: <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.insert) <span class="comment">// 保存外部传入的变量快照，将在监听器中做比较使用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    insert: &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,  </span><br><span class="line">    fieldValue: &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'output'</span>, <span class="built_in">JSON</span>.parse(currentValue))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在外部使用 <code>@output</code> 的时候，会发现外部更新不触发 <code>output</code> 事件。<br>刚开始以为组件实现还是有问题，后面想想不对，外部更新没必要抛出事件。<br>外部更新，可以在外部使用 watch 函数，这里确实不管内部组件的事情了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-div</span> <span class="attr">v-model</span>=<span class="string">"formValue"</span> @<span class="attr">output</span>=<span class="string">"handleOutput"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>今天我们重新了解了 <code>v-model</code> 只针对于表单控件数据的双向绑定，并且会默认占用一个属性和一个事事件。<br><strong>也通过v-model，我们得以在自己的组件实现双向绑定，基本类型和引用类型的处理机制也不太一样。</strong></p>
<p>工作中也经常用到这种需要自定义双向绑定的场景，有时候写得次数太多，就想着能不能抽象出来复用。<br><strong>想想 <code>mixins</code> ， <code>extend</code> 都不太适合，因为会固定占用prop data 事件， 容易起冲突。</strong><br>目前觉得指令可以一试，不过还需要好好研究一下，希望下次的更新能定义一条全局指令——<code>base-model</code>。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-skill</tag>
      </tags>
  </entry>
  <entry>
    <title>vue技巧篇：我的浏览器也是“控制台”</title>
    <url>//post/control-pane/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写代码少不了，调试最简单方便的方法是控制台输出信息，如js的 <code>control.log</code>。<br>可有时候我们要监听的变量是改动频繁，可能要多次使用<code>control.log</code>，控制台信息太多看得也容易乱。<br>有一次查阅资料的时候，看到其他开发者使用<code>pre</code>标签直接在页面上打印变量，突然受到了一点感悟。</p>
<h2 id="pre-和-data"><a href="#pre-和-data" class="headerlink" title="pre 和 $data"></a>pre 和 $data</h2><p>html的<code>pre</code>标签并不常用，它可以保留原格式（空格和换行符），常用于表示源代码。<br>有了<code>pre</code>我们很容易在页面上输出源码。此外，还需要vue的声明式渲染 —— <code>｛｛ x ｝｝</code> 或者是 <code>v-text</code> 指令。<br>以及 vue 的 <code>$data</code> 实例属性，其实引用的是<code>data</code>对象属性的访问。</p>
<p><em>附：博客系统，不支持双括号，这里用 <code>v-text</code>代替，大部分情况下两者可以互换</em></p>
<p>说了那么多，其实只需要<code>&lt;pre v-text=&quot;$data&quot;&gt;&lt;/pre&gt;</code>,这一行就够了。好的，今天就到这里，大家再见。</p>
<p>…</p>
<a id="more"></a>
<h2 id="编写样式"><a href="#编写样式" class="headerlink" title="编写样式"></a>编写样式</h2><p>如果只是简单的方便调试，确实只需要上面一行代码就够了。<br>只是本着折腾的命，觉得可以设计成一个组件，进行复用。<br>就算设计成一个组件，实用性的不大，趣味性要多过实用性吧。</p>
<p>如果在实际开发中，直接单纯只写一行，调试使用的<code>pre</code>可能会被其他DOM元素的样式所铺盖。<br>所以在编写组件前可以给这个<code>pre</code>写一点样式，先开头说的代码吧。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span> <span class="attr">v-text</span>=<span class="string">"$data"</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Package  <span class="keyword">from</span> <span class="string">'@/../package.json'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'views-skill-control-panel'</span>,</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      strong: '<span class="tag">&lt;<span class="name">strong</span>&gt;</span>I \'m strong<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>',</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">debugger</span>: <span class="literal">true</span>,</span></span><br><span class="line">      arr: [1,2,3,4,5],</span><br><span class="line"><span class="actionscript">      <span class="class"><span class="keyword">package</span>: <span class="title">Package</span></span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可能比官网入门实例还要简单，唯一有疑问的可能也就是 <code>import</code> 一个 <code>json</code> 文件进来， 这在<code>es6 Modules</code>中是允许的，相关资料请自行查阅。</p>
<p><img src="/post/control-pane/pre-$data.jpg" alt="pre-$data"></p>
<p>ok，先看html部分，再看css。</p>
<p>html中，把<code>data</code>的属性都渲染到DOM上，并且html实体不会被转义，（<code>v-text</code>的功劳）。<br>数组、对象也全被展开，不像在浏览器控制台是默认闭合的，而且key值也被加上双引号，这是<code>JSON</code>的格式。</p>
<p>内容上看非常友好，样式因为没写，非常朴素，但我们也不追求美感，能看就行，这里有几个因素影响了观看。</p>
<ol>
<li>内容过长，高度容易溢出</li>
<li>默认定位，容易被其他元素遮挡</li>
<li>透明背景，深色背景观看费劲</li>
<li>字体样式会被通用样式影响</li>
</ol>
<p>其实以上问题都是其他DOM元素影响<code>pre</code>的阅读观看，我们要固定，或者说通配一下pre的样式。<br>让其在不同色彩表现、不同布局的页面降低其他DOM元素对自身的影响。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模拟pre真实使用场景 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">v-text</span>=<span class="string">"$data"</span> <span class="attr">class</span>=<span class="string">"pre-panel"</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.pre-panel</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">999999</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">380px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">7</span>); <span class="comment">/* 建议半透明背景 */</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#34ecff</span>;                <span class="comment">/* 亮色的颜色即可 */</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: normal;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">text-indent</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>以上css样式都是在多次实践中一行行增加，现已能适应大多数页面。</strong></p>
<p>模拟pre真实使用场景，完整代码：<a href="https://github.com/Fifth-Patient/stardust/blob/master/src/views/skill/control-panel/control-panel.vue" target="_blank" rel="noopener">传送门</a></p>
<p><img src="/post/control-pane/pre-panel.jpg" alt="pre-panel"></p>
<p>即使在色彩强烈，内容纷乱的布局上，pre-panel仍然不影响阅读。</p>
<h2 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h2><p>这个组件也非常简单，还是把一行代码还有样式抽象成一个组件，就基本完成了。<br>不过考虑到扩展性，我们也可以考虑下给组件一些常用的配置选项。</p>
<p>第一步我们就是新建一个 <code>control-panel.vue</code> 文件，然后把刚才写的代码先复制过去。<br>接下来复用就会发现 <code>v-text=&quot;$data&quot;</code> 使得每次复用绑定的都是自身组件的变量。<br>我们这里应该使用插槽slot，然而每次插槽每次都要复用都要传值，我们更喜欢默认显示<code>$data</code>。<br>然后再给指定插槽内容；当然这个 <code>$data</code> 是 <code>control-panel</code> 的父组件（<strong>引用<code>control-panel</code>的那个组件</strong>）而不是自己。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span> <span class="attr">class</span>=<span class="string">"control-panel"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">      &#123;&#123; defaultProps &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    defaultProps () &#123;</span><br><span class="line">      <span class="keyword">const</span> parent = <span class="keyword">this</span>.$parent</span><br><span class="line">      <span class="keyword">if</span> (parent &amp;&amp; parent.$data) &#123;</span><br><span class="line">        <span class="keyword">return</span> parent.$data</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$data</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是最小化的可配置使用组件，然后这样还不够。<br>虽然 <code>control-panel</code> 不会被其他组件遮住了，可是他遮住了其他组件。<br>所以在某些情况，我们希望它“挪一挪”自己的位置，增加几个<code>props</code>即可解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    width: &#123;</span><br><span class="line">      type: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'380px'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    position: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      validator: <span class="function">(<span class="params">val</span>) =&gt;</span> [<span class="string">'left'</span>, <span class="string">'right'</span>].indexOf(val) !== <span class="number">-1</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'left'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    currentWidth () &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.width === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.width</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.width&#125;</span>px`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 记得删除.control-panel的 left 属性！！ */</span></span><br><span class="line"><span class="selector-class">.position-left</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.position-right</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"control-panel"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:style</span>=<span class="string">"&#123; width: currentWidth &#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:class</span>=<span class="string">"[</span></span></span><br><span class="line"><span class="tag"><span class="string">      &#123; 'position-left': position === 'left' &#125;,</span></span></span><br><span class="line"><span class="tag"><span class="string">      &#123; 'position-right': position === 'right' &#125;</span></span></span><br><span class="line"><span class="tag"><span class="string">    ]"</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span>&gt;</span>&#123;&#123; defaultProps &#125;&#125;<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里不换行是为了消除首行缩进 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>props</code>只定义了3个，也有插槽，可以自定义，使用起来也不繁琐，方便了很多，不是吗？</p>
<ul>
<li>组件源码：<a href="https://github.com/Fifth-Patient/stardust/blob/master/src/components/control-panel/control-panel.vue" target="_blank" rel="noopener">传送门</a></li>
<li>复用-1：<a href="hhttps://fifth-patient.github.io/stardust/#/skill/multi-index-1">传送门</a></li>
<li>复用-2：<a href="https://fifth-patient.github.io/stardust/#/skill/multi-index-2">传送门</a></li>
</ul>
<p>当然还可以再进行扩展，只是没什么必要，如：随机color，交互设置样式和插槽内容；<br><del>最好可以跟程序窗口一样可以最小化最大化关闭拖曳改变宽高..</del></p>
<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>设计一个组件，还要在实际项目中使用，可能因为各种现实因素影响，如果不喜欢组件的方式。<br>（不想写，或者是嫌弃麻烦的）这里可以提供一个代码片段，需要的使用的直接复制粘贴即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">style</span>=<span class="string">"position: fixed; top: 20px; left: 20px; bottom: 20px; width: 200px; overflow: auto; z-index: 9999; font-size: 16px; line-height: 20px; color: skyblue; background: rgba(0, 0, 0, .7)"</span>&gt;</span></span><br><span class="line">  &#123;&#123; formData &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>什么？不想每次都复制一遍？想编辑器<strong>代码提示</strong>的功能一样打几个单词就帮你打一整段？<br>好伐，我也是一个嫌弃麻烦的人，如果你跟我一样是用vs code 的话，那我们可以用 vs code 增加用户自定义的代码提示。</p>
<p><strong>vs code 菜单： 文件 =&gt; 首选项 =&gt; 用户代码片段 =&gt; vue-html.json</strong></p>
<p><img src="/post/control-pane/user_snippets.jpg" alt="user_snippets"></p>
<p><img src="/post/control-pane/user_snippets_lang.jpg" alt="user_snippets_lang"></p>
<p>vue-html.json中增加这一段</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"Print to pre dom"</span>: &#123;</span><br><span class="line">  <span class="string">"prefix"</span>: <span class="string">"vuepre"</span>,</span><br><span class="line">  <span class="string">"body"</span>: [</span><br><span class="line">   <span class="string">"&lt;pre style=\"position: fixed; top: 20px; left: 20px; bottom: 20px; width: 300px; overflow: auto; z-index: 9999; font-size: 16px; line-height: 20px; color: skyblue; background: rgba(0, 0, 0, .7)\"&gt;"</span>,</span><br><span class="line">   <span class="string">"  &#123;&#123; $$data$2 &#125;&#125;"</span>,</span><br><span class="line">   <span class="string">"&lt;/pre&gt;"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在<code>*.vue</code>的文件格式中，vs code 就支持对<code>vuepre</code>的代码提示了。</p>
<p><img src="/post/control-pane/vue-pre.jpg" alt="vue-pre"></p>
<p>也直接直接拿我的 vue-html.json（<a href="/download/vue-html.txt">传送门</a>），使用任何文本编辑器打开，另存为：<code>%APPData%\Code\User\snippets\vue-html.json</code></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>此本到这里就结束了，定义了一个可以监测变量的组件，相当于把控制台搬运到了网页，只是这个控制台是简化版的。<br><!-- 当然之后的开发，喜欢`control.log`、`debugger`还有打断点的还是会选择之前喜欢的方式调试。 --><br>只是很多开发者都很讨厌调试，因为只有自己的代码出现问题才会去调试。<br>其实调试本来就是一件苦中作乐的事情，平时写的代码，都是为了满足各种需求，有时候写得并不自由。<br>那么，我们在调试的时候，为何不使用一种更有趣味的方式去调试呢？起码这个时候自由度很高很高..</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-skill</tag>
        <tag>debugger</tag>
      </tags>
  </entry>
  <entry>
    <title>项目部署</title>
    <url>//post/deploy/</url>
    <content><![CDATA[<p>工作中实操过的项目部署记录，使用的是Ubuntu系统，nignx 和 C# 的运行环境均已安装。</p>
<h2 id="前期配置文件准备"><a href="#前期配置文件准备" class="headerlink" title="前期配置文件准备"></a>前期配置文件准备</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以acs.HOST.cn举例 （HOST）为主域名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目路径</span></span><br><span class="line">/home/wwwroot/acs.xxx.cn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从服务器下载文件配置文件（需要本机使用pscp或其他支持ftp协议的程序）</span></span><br><span class="line">pscp USERNAME@IP:/home/wwwroot/acs.HOST.cn/appsettings.json E:\PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># nginx 配置acs 所有项目(HOSTboss.conf)</span></span><br><span class="line">usr/<span class="built_in">local</span>/nginx/conf/HOSTboss.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># nginx 配置路径</span></span><br><span class="line">usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 守护进程</span></span><br><span class="line">/etc/systemd/system/apps.acs.serive</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建项目目录</span></span><br><span class="line">sudo mkdir /home/wwwroot/acs.HOST.cn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置文件夹权限为完全访问</span></span><br><span class="line">sudo chmod 777 acs.HOST.cn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到nginx目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx</span><br><span class="line"><span class="built_in">cd</span> ./conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传项目配置</span></span><br><span class="line"><span class="comment"># C:\Users\Admin\Downloads\pscp.exe</span></span><br><span class="line">.\pscp.exe E:\PATH\HOSTboss.conf USERNAME@acs.HOST.cn:/home/wwwroot/acs.HOST.cn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动文件</span></span><br><span class="line">sudo mv HOSTboss.conf /usr/<span class="built_in">local</span>/nginx/conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查include</span></span><br><span class="line">sudo vim /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查证书 HOST.cn.key  HOST.cn.pem</span></span><br><span class="line">ls /usr/<span class="built_in">local</span>/nginx/conf/cert</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试 重载nginx</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx</span><br><span class="line"><span class="built_in">cd</span> ./sbin</span><br><span class="line">sudo ./nginx -t <span class="comment"># 测试</span></span><br><span class="line">sudo ./nginx -s reload <span class="comment"># 重载</span></span><br></pre></td></tr></table></figure>
<h2 id="项目部署、守护进程"><a href="#项目部署、守护进程" class="headerlink" title="项目部署、守护进程"></a>项目部署、守护进程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上传已打包的项目到服务器</span></span><br><span class="line">.\pscp.exe E:\PATH\acs.HOST.cn\FILENAME.zip USERNAME@acs.HOST.cn:/home/wwwroot/acs.HOST.cn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line"><span class="built_in">cd</span> /home/wwwroot/acs.HOST.cn</span><br><span class="line">sudo unzip -o FILENAME.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查证书 HOST.pfx</span></span><br><span class="line">ls /home/wwwroot/acs.HOST.cn/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动守护进程配置文件到指定目录</span></span><br><span class="line">sudo mv ./apps.acs.service /etc/systemd/system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义守护进程</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> apps.acs.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启进程</span></span><br><span class="line">sudo systemctl start apps.acs.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">sudo systemctl status apps.acs.service</span><br></pre></td></tr></table></figure>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>web服务器只需部署nginx</p>
<ul>
<li>sso</li>
<li>boss</li>
<li>mgt</li>
</ul>
<p>部署成功，对外开放三个地址</p>
<ul>
<li><code>https://sso.HOST.cn</code>  单点登录</li>
<li><code>https://boss.HOST.cn</code> 门户网站</li>
<li><code>https://mgt.HOST.cn</code>  一体化管理中心</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>vue的一些技巧</title>
    <url>//post/vue-skill/</url>
    <content><![CDATA[<h2 id="v-if-获取-refs-问题"><a href="#v-if-获取-refs-问题" class="headerlink" title="v-if 获取 refs 问题"></a><code>v-if</code> 获取 <code>refs</code> 问题</h2><p>先简单介绍下这两个指令：</p>
<ul>
<li><code>v-if</code> 条件渲染</li>
<li><code>ref</code> 返回组件实例或DOM元素</li>
</ul>
<p>有时候我们需要在条件渲染的DOM节点上返回一个DOM对象或组件实例，可<code>this.$refs.child</code> 返回的是<code>undefined</code>。通过查阅文档得知:</p>
<blockquote>
<p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条块。<br>$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。</p>
</blockquote>
<p>如此可得：</p>
<p><strong><code>v-if</code> 条件渲染： 惰性渲染，DOM、事件、组件会被销毁重建</strong></p>
<p><strong><code>ref</code> 返回组件实例或DOM元素，非相应式</strong></p>
<a id="more"></a>
<p>那么可推论得知<code>v-if</code>和<code>ref</code>的实现有冲突，<code>v-show</code>也是条件渲染，而它只是单纯切换元素css display属性值隐藏。<strong>如此可以使用<code>v-show</code>替代<code>v-if</code></strong>。</p>
<p>总结：工作中常用的是<code>v-if</code>，可<code>v-show</code>也有<code>v-if</code>替代不了的时候，比如用于<code>ref</code>的DOM或组件；<br>而<code>v-if</code>又可使用<code>v-else</code>、<code>v-else-if</code>，这两个指令也比较特殊，必须和<code>v-if</code>相邻，阅读代码时逻辑性更强。</p>
<h2 id="event-——-隐藏的函数参数"><a href="#event-——-隐藏的函数参数" class="headerlink" title="$event —— 隐藏的函数参数"></a><code>$event</code> —— 隐藏的函数参数</h2><p>vue的官方api文档，里详细地介绍了实例属性/方法，这些属性和方法都以美元符号<code>$</code>为前缀， <code>$event</code>并没有介绍；<br>但在教程中， <code>$event</code>的定义是获取原生dom事件，实践中有时候其值并非是原生dom对象，<br>而<code>$event</code> 又是可以隐性调用的，这使得<code>$event</code>的机制不那么直观。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>使用<code>v-on</code>或<code>@</code>指令可以为dom元素绑定事件,<br>函数没有参数时，<code>$event</code>被自动当作实参传入;<br>函数带有参数时，最后一个参数必须显式传入<code>$event</code></p>
<p>请自行准备一个组件：<code>dollar-event.vue</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/* dollar-event.vue */</span><br><span class="line">// eg: 无参数</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>$event empty param<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">handleClick ($event) &#123;</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'dom事件：本组件事件'</span>)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log($event) <span class="comment">// 原生dom对象</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// eg：带有参数</span><br><span class="line"><span class="comment">&lt;!-- 调换$event位置，爹妈不疼哦，不信你试试？ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleParamClick('click', $event)"</span>&gt;</span>$event with param<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">handleParamClick (value, $event) &#123;</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(&#123;</span></span><br><span class="line"><span class="actionscript">    value,  <span class="comment">// 'click'</span></span></span><br><span class="line"><span class="actionscript">    $event  <span class="comment">// 原生dom对象</span></span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>非常简单，就是有无参数的区别，可自定义事件(<code>$emit</code>)机制就有两个含义了。</p>
<h3 id="自定义事件-emit"><a href="#自定义事件-emit" class="headerlink" title="自定义事件($emit)"></a>自定义事件($emit)</h3><p><code>$emit</code>实例方法可以触发父组件的自定义事件，<br>同时还可以传递一个参数给自定义事件接受；<br>这个参数也可以是子组件的<code>$event</code></p>
<p>请再准备一个组件：<code>emit-event.vue</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/* emit-event.vue */</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"skill-emit-event"</span> @<span class="attr">click</span>=<span class="string">"handleEmit"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>emit-event<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">handleEmit ($event) &#123;</span><br><span class="line"><span class="actionscript">  <span class="comment">// 这里的$event同"基本使用"的第一段实例一样都是原生dom对象</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">this</span>.$emit(<span class="string">'dispatch'</span>, &#123;</span></span><br><span class="line">    emitParams: $event,</span><br><span class="line"><span class="actionscript">    emitValue: <span class="string">'dispatch emit-event'</span></span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">/* dollar-event.vue */</span><br><span class="line"><span class="tag">&lt;<span class="name">emit-event</span> @<span class="attr">dispatch</span>=<span class="string">"emitClick"</span>&gt;</span>emit click<span class="tag">&lt;/<span class="name">emit-event</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> emitEvent <span class="keyword">from</span> <span class="string">'./emit-event'</span></span></span><br><span class="line"></span><br><span class="line">emitClick (emitEvent, $event) &#123;</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(&#123;</span></span><br><span class="line"><span class="actionscript">    emitEvent,  <span class="comment">// &#123; emitParams: '子组件的$event', emitValue: 'dispatch emit-event' &#125;</span></span></span><br><span class="line"><span class="actionscript">    $event      <span class="comment">// emitEvent才是形参$event, 因此自己没有$event了，这里是undefined</span></span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(emitEvent.emitParams.target) <span class="comment">// &lt;button class="skill-emit-event"&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>父组件的自定义事件有参数时也可结合<code>$event</code>一起使用，机制跟“基本使用”是一样的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/* dollar-event.vue */</span><br><span class="line"><span class="tag">&lt;<span class="name">emit-event</span> @<span class="attr">dispatch</span>=<span class="string">"emitParamClick('val', $event)"</span>&gt;</span>emit param click<span class="tag">&lt;/<span class="name">emit-event</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">emitParamClick (val, $event) &#123;</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(&#123;</span></span><br><span class="line"><span class="actionscript">    val,        <span class="comment">// 'val'</span></span></span><br><span class="line"><span class="actionscript">    $event     <span class="comment">// &#123; emitParams: '子组件的$event', emitValue: 'dispatch emit-event' &#125;</span></span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>示例代码：<a href="https://github.com/Fifth-Patient/vue-skill/tree/master/src/views/skill/dollar-event" target="_blank" rel="noopener">dollar-event</a></p>
<p>总结：</p>
<ul>
<li>基本使用时函数无其他实参，可以不用传<code>$event</code>实参，有其他实参的时候，<code>$event</code>必须作为最后一个参数传入</li>
<li>自定义事件时使用，<code>$event</code>作为<code>$emit</code>的实参，若<code>$emit</code>不带参数，<code>$event</code>的值为<code>undefined</code></li>
</ul>
<h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>vue的静态资源分两种方式处理，区别就是经不经过webpack处理，或者说——是否为webpack模块:</p>
<ul>
<li>webpack模块：js中<code>import</code>进来的，或用相对路径在<code>template/css</code>引入的</li>
<li>非webpack模块：<code>public</code>目录下，或绝对路径引用的，将被直接拷贝</li>
</ul>
<p>官方推荐使用资源作为模块引入，理由如下：</p>
<pre><code>脚本和样式表会被压缩且打包在一起，从而避免额外的网络请求。
文件丢失会直接在编译时报错，而不是到了用户端才产生 404 错误。
最终生成的文件名包含了内容哈希，因此你不必担心浏览器会缓存它们的老版本。
</code></pre><ul>
<li><a href="https://cli.vuejs.org/zh/guide/html-and-static-assets.html#%E5%A4%84%E7%90%86%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90" target="_blank" rel="noopener">处理静态资源</a></li>
<li><a href="https://cli.vuejs.org/zh/guide/css.html#%E5%BC%95%E7%94%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90" target="_blank" rel="noopener">CSS引用静态资源</a></li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-skill</tag>
      </tags>
  </entry>
  <entry>
    <title>原型链是如何贯穿js的</title>
    <url>//post/prototype/</url>
    <content><![CDATA[<blockquote>
<p>原型链是js的大动脉。</p>
</blockquote>
<h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>js的原型链难以避免要牵扯到面向对象，这里我们先简单说说原型还有原型链。之后我们说到面向对象的演变过程，会再次涉及到原型链，还有更多的东西。相信看完的读者会对JavaScript会有更深的认识。</p>
<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>本小节意在介绍js中几位朋友，读者只需要记住有它们的存在就行了，毕竟这几位朋友性格有点隐匿。</p>
<p>首先，我们要明白，声明一个对象，哪怕是空属性，js也生成一些内置的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 两种方法声明对象 */</span></span><br><span class="line"><span class="comment">// 对象直接量</span></span><br><span class="line"><span class="keyword">var</span> obj_1 = &#123;&#125;;</span><br><span class="line"><span class="comment">// new关键字声明对象</span></span><br><span class="line"><span class="keyword">var</span> obj_2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Object的原型对象添加属性</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.attr = <span class="string">'myarr'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj_1); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj_2); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// js中的恒等符号对函数来说只比较引用</span></span><br><span class="line"><span class="comment">// obj_1.valuOf函数来源于Object.valueOf</span></span><br><span class="line"><span class="comment">// 更准确来说是Object.protoype.valueOf</span></span><br><span class="line"><span class="built_in">console</span>.log(obj_1.valueOf === <span class="built_in">Object</span>.valueOf); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj_1并未声明attr属性，通过Object.prototype继承得到attr属性</span></span><br><span class="line"><span class="built_in">console</span>.log(obj_1.attr); <span class="comment">// myarr</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="/post/prototype/obj_attr.jpg" alt="空对象属性的prototype"></p>
<p align="center"><em>firefox控制台中空对象仍然有<code>prototype</code>属性</em></p>

<p>  误区：每个浏览器的控制台输出都不太一样，Chrome和Edge并不显示<code>prototype</code>属性，因为我们并没有给obj_1的<code>prototype</code>属性定义任何属性和方法。<br>  由于历代浏览器的更新和ECMAScript的修正，有时难以体现<code>prototype</code>和<code>__proto__</code>的存在，但我们的js代码能体现出它们的确是真实存在的。</p>
<p><code>prototype</code>在这里称之为<code>obj_1</code>的原型对象，通过对象直接量和<code>new</code>关键字声明的对象都具有原型对象，继承自<code>Object.prototype</code>；几乎每个对象都有其原型对象，null是特例。</p>
<h2 id="双对象实现原型继承"><a href="#双对象实现原型继承" class="headerlink" title="双对象实现原型继承"></a>双对象实现原型继承</h2><p>需要原型对象是为了实现继承，但有了原型对象我们还无法把<code>obj_1</code>与<code>Object.prototype</code>链接起来。<br>我们还需要另一个对象：<code>__proto__</code>，该属性能指向构造函数的原形属性<code>constructor</code>。<br>一些老版本浏览器不识别，有些无法识别其内部信息，但不影响程序的正常运行。</p>
<p><img src="/post/prototype/obj_1__proto__.jpg" alt="obj_1的__proto__"></p>
<p align="center"><em><code>obj_1</code>的<code>__proto__</code>对象, 该属性下又有<code>__proto__</code>和<code>constructor</code>属性</em></p>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj_1.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br><span class="line">obj_1.__proto__.constructor === <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这里有三个概念先行抛出</p>
<ul>
<li>继承：继承使子类（超类）可拥有父类的属性和方法，子类也可添加属性和方法</li>
<li>父类：提供属性和方法被子类继承</li>
<li>子类：被父类继承的对象，可调用父类的属性和方法，也能定义属性和方法（父类无法调用）</li>
</ul>
<p>通过<code>Object.prototype.attr</code>与<code>obj_1.attr</code>，我们可以看出 <code>obj_1</code> (子类) 继承了 <code>Object</code> (父类)的原型对象的<code>attr</code>属性。<br>正是因为<code>obj_1</code>的<code>__proto__</code>指向<code>Object.prototype</code>，obj_1继承了父类原型对象，使之拥有了<code>attr</code>属性。<br>而子类的<code>__proto__.constructor</code>直接指向父类。</p>
<blockquote>
<p><strong>原型继承：每声明一个对象，其本身拥有用两个对象：原型对象(<code>prototype</code>)，与<code>__proto__</code>对象，原型对象即可供自身使用，子类继承后也可调用；自身的<code>__proto__</code>对象指向父类的原型对象，其<code>constructor</code>属性指向父类的构造函数</strong>。通过原型对象的方法实现继承，叫原型继承。</p>
</blockquote>
<h2 id="双对象与原型链"><a href="#双对象与原型链" class="headerlink" title="双对象与原型链"></a>双对象与原型链</h2><p>综合以上，我们知道了使用原型对象<code>prototype</code>和<code>__proto__</code>对象可以实现继承的功能。那么我们是不是可以一直继承下去呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Engineer</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Engineer.prototype = <span class="keyword">new</span> People(<span class="string">'Chris Chen'</span>); <span class="comment">// Engineer (子类)继承 People (父类)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Programmer</span>(<span class="params">skill</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.skill = skill;</span><br><span class="line">  <span class="keyword">this</span>.showMsg = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hi, my name is '</span> + <span class="keyword">this</span>.name + <span class="string">', I am a '</span> + <span class="keyword">this</span>.type + <span class="string">' engineer, I can write '</span> + <span class="keyword">this</span>.skill + <span class="string">' code!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Programmer.prototype = <span class="keyword">new</span> Engineer(<span class="string">'front-end'</span>); <span class="comment">// Programmer (子类) 继承 Engineer (父类)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> Programmer(<span class="string">'js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me); <span class="comment">// Object &#123; skill: "js", showMsg: showMsg() &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(me.showMsg()); <span class="comment">// Hi, my name is Chris Chen, I am a front-end engineer, I can write js code!</span></span><br></pre></td></tr></table></figure>
<p>代码看完，我们从子类开始解释，也就是从下往上的顺序：</p>
<ol>
<li><code>me</code>是<code>Programmer</code>的实例化对象</li>
<li><code>Programmer</code>的原型指向<code>Engineer</code>的实例对象</li>
<li><code>Engineer</code>的原型指向<code>People</code>的实例对象</li>
</ol>
<p>我们再来一张图说明其关系</p>
<p><img src="/post/prototype/proto_egg.jpg" alt="proto_egg"><br><em>这个.. 一盘煎蛋？？</em></p>
<p>好伐，煎蛋就煎蛋，来，我们继续。</p>
<p>请注意重点：<strong><code>Programmer</code>并无定义<code>type</code>, <code>name</code>属性，<code>Programmer</code>的<code>showMsg</code>中能显示<code>this.name</code> <code>this.type</code>分别来源于<code>Engineer</code>和<code>Programmer</code>的原型对象。</strong><br>很巧妙的一种属性搜索机制，<strong>自身的构造函数没有该属性，就从自身的原型对象中找，如果父类的原型对象没有，那么继续往父类的父类原型对象找，找到了就赋值；或直到没有父类，返回<code>undefined</code>；</strong>属性如此，方法也是同样的赋值机制。</p>
<p>说到底属性搜索机制就是原型链的一种具体体现，我们再上一张图。</p>
<p><img src="/post/prototype/proto_link.jpg" alt="proto_link"></p>
<p>所以原型链的关键字是<strong>继承</strong>和<strong>原型对象</strong>！！</p>
<blockquote>
<p><strong>原型链：使用<code>prototype</code>和<code>_proto_</code>两个对象实现继承，由于是基于原型对象实现调用链，又称之为原型链。</strong></p>
</blockquote>
<p>关于原型链的第一步介绍就到这里，接下来我们从头开始，说说面向对象。</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>首先我们先来概述面向过程编程（opp）与面向对象（oop）。这是JS的两种编程范式，也可以理解为编程思想。<br>顾名思义，两者的重心不同。下面我们使用两种方法创建dom并挂载于页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 面向过程 */</span></span><br><span class="line"><span class="comment">// 1. 定义dom</span></span><br><span class="line"><span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="comment">// 2. 设置dom属性</span></span><br><span class="line">dom.innerHTML = <span class="string">'面向过程'</span>;</span><br><span class="line">dom.id = <span class="string">'opp'</span>;</span><br><span class="line">dom.style = <span class="string">'color: skyblue'</span>;</span><br><span class="line"><span class="comment">// 3. 挂载dmo</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line">container.appendChild(dom);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 面向对象 */</span></span><br><span class="line"><span class="comment">// 1. 定义构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateElement</span>(<span class="params">tagName, id, innerText, style</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement(tagName);</span><br><span class="line">  dom.innerHTML = innerText;</span><br><span class="line">  dom.id = id;</span><br><span class="line">  dom.style = style;</span><br><span class="line">  <span class="keyword">this</span>.dom = dom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 定义原型对象上的方法</span></span><br><span class="line">CreateElement.prototype = &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">dom</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(dom);</span><br><span class="line">    container.appendChild(<span class="keyword">this</span>.dom);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">var</span> innerBox = <span class="keyword">new</span> CreateElement(<span class="string">'div'</span>, <span class="string">'oop'</span>, <span class="string">'面向对象'</span>, <span class="string">'color: pink;'</span>);</span><br><span class="line"><span class="comment">// 调用原型方法</span></span><br><span class="line">innerBox.render(<span class="string">'container'</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>面向过程比较流水线，更注重程序的实现过程，面向对象的程序由一个又一个的单位————对象组成，不关心对象的内部属性和方法，只需实例化，调用方法即可使用。</p>
</blockquote>
<p>或许上面的例子，还不是很有力得体现出两者的区别，那么如果现在，需要挂载多个元素呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 面向过程 */</span></span><br><span class="line"><span class="comment">// var dom_1 = document.createElement('div');</span></span><br><span class="line"><span class="comment">// dom_1.innerHTML = '面向过程_1';</span></span><br><span class="line"><span class="comment">// dom_1.id = 'opp-1';</span></span><br><span class="line"><span class="comment">// dom_1.style = 'color: skyblue';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var dom_2 = document.createElement('div');</span></span><br><span class="line"><span class="comment">// dom_2.innerHTML = '面向过程_2';</span></span><br><span class="line"><span class="comment">// dom_2.id = 'opp-2';</span></span><br><span class="line"><span class="comment">// dom_2.style = 'color: skyblue;';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var container = document.getElementById('container');</span></span><br><span class="line"><span class="comment">// container.appendChild(dom_1);</span></span><br><span class="line"><span class="comment">// container.appendChild(dom_2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这种方法傻的可爱，我们包装成函数吧 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName, id, innerText, style</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement(tagName);</span><br><span class="line">  dom.innerHTML = innerText;</span><br><span class="line">  dom.id = id;</span><br><span class="line">  dom.style = style;</span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"><span class="keyword">var</span> box_1 = createElement(<span class="string">'div'</span>, <span class="string">'oop-1'</span>, <span class="string">'面向过程_1'</span>, <span class="string">'color: skyblue;'</span>);</span><br><span class="line"><span class="keyword">var</span> box_2 = createElement(<span class="string">'div'</span>, <span class="string">'oop-2'</span>, <span class="string">'面向过程_2'</span>, <span class="string">'color: skyblue;'</span>);</span><br><span class="line">container.appendChild(box_1);</span><br><span class="line">container.appendChild(box_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 面向对象 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateElement</span>(<span class="params">tagName, id, innerText, style</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement(tagName);</span><br><span class="line">  dom.innerHTML = innerText;</span><br><span class="line">  dom.id = id;</span><br><span class="line">  dom.style = style;</span><br><span class="line">  <span class="keyword">this</span>.dom = dom;</span><br><span class="line">&#125;</span><br><span class="line">CreateElement.prototype = &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">dom</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(dom);</span><br><span class="line">    container.appendChild(<span class="keyword">this</span>.dom);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> innerBox_1 = <span class="keyword">new</span> CreateElement(<span class="string">'div'</span>, <span class="string">'oop-1'</span>, <span class="string">'面向对象_1'</span>, <span class="string">'color: pink;'</span>);</span><br><span class="line">innerBox_1.render(<span class="string">'container'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里只需再实例化一个对象调用render方法即可</span></span><br><span class="line"><span class="keyword">var</span> innerBox_2 = <span class="keyword">new</span> CreateElement(<span class="string">'div'</span>, <span class="string">'oop-2'</span>, <span class="string">'面向对象_2'</span>, <span class="string">'color: pink;'</span>);</span><br><span class="line">innerBox_2.render(<span class="string">'container'</span>);</span><br></pre></td></tr></table></figure>
<p>重复调用同样的方法，面向过程如果不包装一个函数，显得代码很冗余且愚蠢，而面向对象只需再次实例化即可。<br>这里也提醒我们平时写代码的时候要考虑复用性。</p>
<p>好的，那我们现在需要给dom元素添加一些交互功能，又要怎么做？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 面向过程 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName, id, innerText, style, event, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement(tagName);</span><br><span class="line">  dom.innerHTML = innerText;</span><br><span class="line">  dom.id = id;</span><br><span class="line">  dom.style = style;</span><br><span class="line">  <span class="comment">// 直接修改内部函数</span></span><br><span class="line">  dom.addEventListener(event, fn);</span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"><span class="keyword">var</span> box_1 = createElement(<span class="string">'div'</span>, <span class="string">'oop-1'</span>, <span class="string">'面向过程_1'</span>, <span class="string">'color: skyblue;'</span>, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  alert(e.target.innerHTML);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 过于死板，就算没有传参dom.addEventListener也会调用两次</span></span><br><span class="line"><span class="keyword">var</span> box_2 = createElement(<span class="string">'div'</span>, <span class="string">'oop-2'</span>, <span class="string">'面向过程_2'</span>, <span class="string">'color: skyblue;'</span>);</span><br><span class="line">container.appendChild(box_1);</span><br><span class="line">container.appendChild(box_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 面向对象 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateElement</span>(<span class="params">tagName, id, innerText, style</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement(tagName);</span><br><span class="line">  dom.innerHTML = innerText;</span><br><span class="line">  dom.id = id;</span><br><span class="line">  dom.style = style;</span><br><span class="line">  <span class="keyword">this</span>.dom = dom;</span><br><span class="line">&#125;</span><br><span class="line">CreateElement.prototype = &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">dom</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(dom);</span><br><span class="line">    container.appendChild(<span class="keyword">this</span>.dom);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 在原型对象上添加方法</span></span><br><span class="line">  addMethod: <span class="function"><span class="keyword">function</span> (<span class="params">event, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dom.addEventListener(event, fn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> innerBox_1 = <span class="keyword">new</span> CreateElement(<span class="string">'div'</span>, <span class="string">'oop-1'</span>, <span class="string">'面向对象_1'</span>, <span class="string">'color: pink;'</span>, <span class="string">'click'</span>);</span><br><span class="line">innerBox_1.render(<span class="string">'container'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> innerBox_2 = <span class="keyword">new</span> CreateElement(<span class="string">'div'</span>, <span class="string">'oop-2'</span>, <span class="string">'面向对象_2'</span>, <span class="string">'color: pink;'</span>, <span class="string">'click'</span>);</span><br><span class="line">innerBox_2.render(<span class="string">'container'</span>);</span><br><span class="line"><span class="comment">// 根据场景需求决定是否调用addMethod方法</span></span><br><span class="line">innerBox_2.addMethod(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  alert(e.target.innerHTML);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>从这里可以我们看出两者的扩展方法截然不同，面向过程模式需要直接在函数中修改，而面向对像在原型对象上直接追加方法。</p>
<blockquote>
<p>面向对象比面向过程有更高的复用性和扩展性。</p>
</blockquote>
<p>PS：面向过程也并非一无是处，比面向对象更直观化，也更理解。若不需要考虑太多的因素，使用面向过程开发反而效率会更快。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>把大象关进冰箱需要几步在下并不清楚。不过要想进行面向对象开发，第一步是先创建一个对象，js中有6种方法可创建对象：</p>
<ol>
<li>new 操作符</li>
<li>字面量</li>
<li>工厂模式</li>
<li>构造函数</li>
<li>原型模式</li>
<li>混合模式（构造+原型）</li>
</ol>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>前两种方法在开头已使用，这里不再复述。如果要创建多个相同的对象，使用前两种方法，会产生大量重复的代码，而工厂模式解决了这个问题..</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factoryMode</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  obj.name = name;</span><br><span class="line">  obj.age = age;</span><br><span class="line">  obj.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' has '</span> + <span class="keyword">this</span>.age + <span class="string">' years old!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> guest = factoryMode(<span class="string">'Gentleman'</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> Chris = factoryMode(<span class="string">'Chris'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(guest.say()) <span class="comment">// Gentleman has 25 years old!</span></span><br><span class="line"><span class="built_in">console</span>.log(Chris.say()) <span class="comment">// Chris has 20 years old!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(guest <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Chris <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// ture</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>有点赞哦，这样<strong>重复实例化多个对象</strong>也不怕了，<strong>对象识别</strong>问题仍然没解决</p>
<p>PS:<code>new Object()</code>已决定了工厂模式的实例是由<code>Object</code>实例化而来的，其对象类型是<code>Object</code>，<code>Date</code> <code>Array</code>有对应的对象类型，这里读者可以试试<code>new Array instanceof Array</code>等原生数据类型。</p>
<blockquote>
<p>工厂模式是面向对象中常见的一种设计模式，是一个可以重复实例化多个对象的函数，但识别对象无能为力。</p>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>我们可以把工厂模式修改一下，就可以写出一个构造函数..</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConstructorMode</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' has '</span> + <span class="keyword">this</span>.age + <span class="string">' years old!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> guest = <span class="keyword">new</span> ConstructorMode(<span class="string">'Gentleman'</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> Chris = <span class="keyword">new</span> ConstructorMode(<span class="string">'Chris'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(guest.say()) <span class="comment">// Gentleman has 25 years old!</span></span><br><span class="line"><span class="built_in">console</span>.log(Chris.say()) <span class="comment">// Chris has 20 years old!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(guest <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(guest <span class="keyword">instanceof</span> ConstructorMode);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(ConstructorMode <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>有几个地方不太一样：</p>
<ol>
<li>没有显示创建对象</li>
<li>属性/方法赋值给<code>this</code></li>
<li>使用<code>new</code>关键字调用</li>
<li>无<code>return</code></li>
</ol>
<p>可以看出实现了跟工厂模式一样的功能，那么什么是构造函数呢？</p>
<ul>
<li>构造函数也是一个函数，跟工厂模式一样可重复实例化对象。为了跟普通函数区分，函数名首字母一般是大写的。</li>
<li>使用该函数时需要使用<code>new</code>关键字实例化；不使用<code>new</code>实例化，该构造函数表现如同普通的函数。</li>
<li>虽然没有显示创建对象，但在<code>new</code>实例化时，后台执行了<code>new Object()</code></li>
<li>使用<code>this</code>是因为，构造函数的作用域指向实例化对象，即：两次实例化，<code>ConstructorMode</code>中的<code>this</code>分别指向<code>Guest</code>, <code>Chris</code>。</li>
</ul>
<p>通过上面的<code>instanceof</code>判断，我们能识别出<code>guest</code>是由<code>ConstructoreMode</code>实例化的，与此同时 <code>guest</code> 也是 <code>Object</code> 的实例对象。<br>构造函数也有其弊端，声明在构造函数内的属性叫“构造属性”，问题就在于：构造属性若是引用类型（以函数为例），实例化后的函数执行的动作虽然是相同的，但引用地址不同，我们并不需要两份同样的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Chris.say == guest.say); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造函数模式：构造函数是一个需要实例化调用的函数，内部作用域指向实例对象，无须return。构造函数模式，也可实例化大量重复对象，也可识别实例化后的对象是由哪个构造函数实例化而来。其缺点是：若在构造属性中声明函数，实例化后的各个对象引用地址保持独立。</p>
</blockquote>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式靠原型对象发挥作用，<strong>原型对象</strong>开头已有介绍。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrototypeMdoe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接在原型对象声明，直面量形式</span></span><br><span class="line">PrototypeMdoe.prototype.mode = <span class="string">'prototype'</span>;</span><br><span class="line">PrototypeMdoe.prototype.do = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'we do the something same, '</span> + name + <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> guest = <span class="keyword">new</span> PrototypeMdoe();</span><br><span class="line"><span class="keyword">var</span> Chris = <span class="keyword">new</span> PrototypeMdoe();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(guest.do(<span class="string">'guest'</span>)) <span class="comment">// we do the something same, guest.</span></span><br><span class="line"><span class="built_in">console</span>.log(Chris.do(<span class="string">'Chris'</span>)) <span class="comment">// we do the something same, Chris.</span></span><br><span class="line"><span class="built_in">console</span>.log(guest.do === Chris.do) <span class="comment">// true，相同的引用指针</span></span><br><span class="line"><span class="built_in">console</span>.log(guest.do(<span class="string">'guest'</span>) === Chris.do(<span class="string">'Chirs'</span>)) <span class="comment">// false， 返回值不相等</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(guest.prototype === Chris.prototype) <span class="comment">// 指向相同的原型对象</span></span><br></pre></td></tr></table></figure>
<p>实例化对象<code>do</code>方法引用指针是相同的，所以如果是需要给所有实例化对象<strong>共享</strong>的方法，可在原型上直接声明。<code>guest</code>和<code>Chris</code>都由<strong>同一个构造函数的实例化</strong>，<strong>原型对象的指针地址相同</strong>。</p>
<p>也可以使用对象字面量的方法，两者有点的区别：对象字面量声明的原型<code>constructor</code>会指向<code>Object</code>，我们也可以手动设置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrototypeMdoe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象字面量，原型赋值为对象</span></span><br><span class="line">PrototypeMdoe.prototype = &#123;</span><br><span class="line">  <span class="comment">// 手动设置构造函数指针</span></span><br><span class="line">  <span class="comment">// constructor: PrototypeMdoe,</span></span><br><span class="line">  run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'I;m running!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proto = <span class="keyword">new</span> PrototypeMdoe()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开constructor的注释对比运行结果</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  proto.constructor === PrototypeMdoe,</span><br><span class="line">  proto.constructor === <span class="built_in">Object</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原型模式：<strong>共享</strong>是原型对象的特点，所有声明在原型上的属性和方法都会<strong>被所有实例化对象继承</strong>，且指向同一个引用地址。</p>
</blockquote>
<p>原型属性是基本类型的数据，共享很方便；如果是<strong>引用类型</strong>的数据，共享将带来麻烦。由于<strong>引用地址相同</strong>，<strong>更改其中一个</strong>实例的原型属性，其他实例的原型也<strong>随之改变</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrototypeMdoe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">PrototypeMdoe.prototype.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proto_1 = <span class="keyword">new</span> PrototypeMdoe();</span><br><span class="line"><span class="keyword">var</span> proto_2 = <span class="keyword">new</span> PrototypeMdoe();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proto_1.arr)  <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">proto_1.arr.splice(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// [2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(proto_2.arr)  <span class="comment">// [1,5]</span></span><br></pre></td></tr></table></figure>
<p><strong>Object.definedPeroperty</strong>：ES5语法，可定义新属性或修改现有属性并返回改对象；第三个参数为属性描述符，能精确添加或修改对象的属性：枚举性、属性值、可写性、存取设置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Obj = &#123;</span><br><span class="line">  attr: <span class="string">'obj'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Obj.prototype = &#123;</span><br><span class="line">  run: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name + <span class="string">' run!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Object.definedPeroperty设置constructor的特性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Obj.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,     <span class="comment">// 设置为ture下面的设置才能生效</span></span><br><span class="line">  <span class="comment">// enumerable: false,   // 枚举性</span></span><br><span class="line">  <span class="comment">// writable: false,     // 可写性</span></span><br><span class="line">  <span class="comment">// get: undefined,      // 取值器</span></span><br><span class="line">  <span class="comment">// set: undefined,      // 设置器</span></span><br><span class="line">  value: Obj              <span class="comment">// 属性值</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>isPrototypeOf</code>函数可以判断<strong>原型对象</strong>是否为某个<strong>实例</strong>的原型对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  PrototypeMdoe.prototype.isPrototypeOf(proto_1), <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.isPrototypeOf(proto_1)          <span class="comment">// false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><p>混合模式是组合构造函数和原型模式使用，这是最常用的一种设计模式了。</p>
<p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。<br>所以每个实例都会有自己的一份实例属性的副本，但同时共享着对方法的引用。<br>最大限度的节省了内存。同时支持向构造函数传递参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObject</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CreateObject.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' has '</span> + <span class="keyword">this</span>.age + <span class="string">' years old!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> guest = <span class="keyword">new</span> CreateObject(<span class="string">'Gentleman'</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> Chris = <span class="keyword">new</span> CreateObject(<span class="string">'Chris'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(guest.say()) <span class="comment">// Gentleman has 25 years old!</span></span><br><span class="line"><span class="built_in">console</span>.log(Chris.say()) <span class="comment">// Chris has 20 years old!</span></span><br></pre></td></tr></table></figure>
<p><code>hasOwnProperty</code>可检测一个属性是否为实例属性。<br>而<code>in</code>可判断属性是否存在本对象中，包括实例属性或者原型属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(guest.hasOwnProperty(<span class="string">'name'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(guest.hasOwnProperty(<span class="string">'say'</span>))  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> guest)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'say'</span> <span class="keyword">in</span> guest)   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为原型属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isProperty</span>(<span class="params">object, property</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">debugger</span></span><br><span class="line">  <span class="keyword">return</span> !object.hasOwnProperty(property) &amp;&amp;  property <span class="keyword">in</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isProperty(guest, <span class="string">'name'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(isProperty(guest, <span class="string">'say'</span>))</span><br></pre></td></tr></table></figure>
<p>创建对象的六种方法就到这里了，另外还有<strong>动态原型</strong>、<strong>寄生构造</strong>、<strong>稳妥构造函数</strong>。 这三种模式都是基于混合模式的改良，感兴趣的可以随便看看：<a id="create-object" class="btn">点我查看</a></p>
<div id="other-create" style="display:none;"><br>  <strong>动态原型</strong><br>  原型模式中，不管我们是否调用原型的方法，都会初始化原型中的方法，并且声明一个构造函数时，构造函数和原型对象是分开声明的，略显怪异。我们可以使用动态原型模式，把构造函数和原型对象封装到一起。<br><br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObject</span> (<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="comment">// 动态创建原型属性，仅在第一次调用时初始化</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.say !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    CreateObject.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' has '</span> + <span class="keyword">this</span>.age + <span class="string">' years old!'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> guest = <span class="keyword">new</span> CreateObject(<span class="string">'Gentleman'</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> Chris = <span class="keyword">new</span> CreateObject(<span class="string">'Chris'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(guest)</span><br><span class="line"><span class="built_in">console</span>.log(guest.say()) <span class="comment">// Gentleman has 25 years old!</span></span><br><span class="line"><span class="built_in">console</span>.log(Chris.say()) <span class="comment">// Chris has 20 years old!</span></span><br></pre></td></tr></table></figure><br><br>  <h4>寄生构造</h4><br>  <h4>稳妥构造函数</h4><br></div>

<style>
#other-create {
  border: 5px solid #aaa;
}
</style>

<script>
;(function() {
  var showOtherCreate = true;
  var creatObject = document.getElementById('create-object');

  creatObject.addEventListener('click', function() {
    var otherCreate = document.getElementById('other-create');
    if (showOtherCreate) {
      otherCreate.style.display = 'block';
      creatObject.innerText = '不想看了';
    } else {
      otherCreate.style.display = 'none';
      creatObject.innerText = '点我查看';
    }
    showOtherCreate = !showOtherCreate;
  })
})();
</script>


<h3 id="动态原型"><a href="#动态原型" class="headerlink" title="动态原型"></a>动态原型</h3><h3 id="寄生构造"><a href="#寄生构造" class="headerlink" title="寄生构造"></a>寄生构造</h3><p><strong>未完待续</strong></p>
]]></content>
  </entry>
  <entry>
    <title>es6主要特性小结</title>
    <url>//post/es6-main/</url>
    <content><![CDATA[<p>ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。</p>
<p>Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。</p>
<p>let：<code>let</code>实际上为JavaScript新增了块级作用域。用它所声明的变量，只在<code>let</code>命令所在的代码块（花括号）内有效；与<code>var</code>的区别是，<code>var</code>用来做循环的计数变量，会泄露成全局变量，在外部调用的值是循环完成后的值。</p>
<p>const：声明变量，但声明的是<strong>常量</strong>，一旦声明，常量的值不能改变。</p>
<a id="more"></a>
<p>class：定义一个类，可定义构造方法在其中，构造方式<code>this</code>关键字指向实例。<code>constructor</code>内定义的方法和属性是<strong>实例对象</strong>自己的，而<code>constructor</code>外定义的方法和属性则是<strong>所有实例对象可以共享</strong>的。</p>
<p>extends：<code>class</code>之间可用<code>extends</code>关键字实现继承</p>
<p>super：指代父类的实例（即父类的this对象）。子类必须在<code>constructor</code>中调用·方法，否则新建实例就会报错，因为子类没有自己的<code>this</code>对象，而是继承父类的<code>this</code>对象，然后对其进行加工。</p>
<blockquote>
<p>ES6的继承机制，实质是先创造父类的实例对象<code>this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p>
</blockquote>
<p>arrow function：箭头函数 <code>(i)=&gt; i+1</code>;箭头函数体内的this对象指向定义时所在的对象（箭头函数内无自己的<code>this</code>，其<code>this</code>继承外面的作用域）</p>
<p>template string：用反引号（ &#96; ）来标识起始，用<code>${}</code>来引用变量，所有的空格和缩进都会被保留在输出之中</p>
<p>destructuring：从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解构</span></span><br><span class="line"><span class="keyword">let</span> cat = <span class="string">'ken'</span></span><br><span class="line"><span class="keyword">let</span> dog = <span class="string">'lili'</span></span><br><span class="line"><span class="keyword">let</span> zoo = &#123;cat, dog&#125;</span><br><span class="line"><span class="built_in">console</span>.log(zoo)  <span class="comment">//Object &#123;cat: "ken", dog: "lili"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="keyword">let</span> dog = &#123;<span class="attr">type</span>: <span class="string">'animal'</span>, <span class="attr">many</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; type, many&#125; = dog</span><br><span class="line"><span class="built_in">console</span>.log(type, many)  <span class="comment">//animal 2</span></span><br></pre></td></tr></table></figure>
<p>default：变量未赋值时给该变量一个默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animal</span>(<span class="params">type = <span class="string">'cat'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(type)</span><br><span class="line">&#125;</span><br><span class="line">animal()  <span class="comment">//cat</span></span><br></pre></td></tr></table></figure>
<p>rest：过滤变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animals</span>(<span class="params">once, ...types</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(types)</span><br><span class="line">&#125;</span><br><span class="line">animals(<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'fish'</span>)   <span class="comment">//[ "dog", "fish"]</span></span><br></pre></td></tr></table></figure>
<p>import export：es6的模块化机制， import用于导入模块，可以选择性导入模块中的一部戏属性/方法，也可给导入的模块重命名；export用于导出模块，也多次导出，任何数据类型都可导出（变量、函数、类等..）。</p>
<p>基本使用<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> animal <span class="keyword">from</span> <span class="string">'./content'</span></span><br><span class="line"><span class="built_in">console</span>.log(animal) <span class="comment">// A cat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//content.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'A cat'</span></span><br></pre></td></tr></table></figure></p>
<p>多次导出，导入模块时使用 <code>as</code> 重命名 <code>type</code> 为 <code>animalType</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//content.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'A cat'</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello!'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> type = <span class="string">'dog'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> animal, &#123; say, type <span class="keyword">as</span> animalType &#125; <span class="keyword">from</span> <span class="string">'./content'</span></span><br><span class="line"><span class="keyword">let</span> says = say()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`The <span class="subst">$&#123;animalType&#125;</span> says <span class="subst">$&#123;says&#125;</span> to <span class="subst">$&#123;animal&#125;</span>`</span>)</span><br><span class="line"><span class="comment">//The dog says Hello to A cat</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>web安全基础</title>
    <url>//post/web-safe/</url>
    <content><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>通过把SQL命令插入到web表单提交或者页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</p>
<p><strong>防范SQL注入</strong><br>1.校验用户输入的参数，限制其长度或转义单引号或双连字符<br>2.使用参数化SQL或直接使用存储过程进行数据查询存取<br>3.每个应用使用单独的权限有限的数据库连接，不使用管理器权限连接数据库<br>4.机密信息不明文存放，加密或hash掉密码和敏感信息</p>
<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p>跨站脚本攻击(Cross Site Scripting)，缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p>
<a id="more"></a>
<p><strong>原理</strong><br>攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）。<br>诱使受害者打开受到攻击的服务器URL。<br>受害者在Web浏览器中打开URL，恶意脚本执行。</p>
<p><strong>攻击方式</strong></p>
<ol>
<li>反射型：发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS随响应内容一起返回给浏览器，最后浏览器解析执行XSS代码，这个过程就像一次发射，所以叫反射型XSS。</li>
<li>存储型：存储型XSS和反射型的XSS差别就在于，存储型的XSS提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。</li>
</ol>
<p><strong>防御措施</strong></p>
<ul>
<li>编码：对用户输入的HTML实体进行编码</li>
<li>过滤：移除用户上的DOM属性，如onerror等，移除用户上传的style、script、iframe节点</li>
<li>校正：避免直接对HTML实体编码，使用DOM Prase转换，校对不配对的DOM标签</li>
<li>cookie：避免直接在cookie 中泄露用户隐私，例如email、密码等等。<pre><code>通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie 。
</code></pre></li>
</ul>
<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>CSRF跨站点请求伪造(Cross—Site Request Forgery)</p>
<p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。<br>由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。<br>这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p>
<p>完成一次CSRF攻击，受害者必须依次完成以下两个步骤：</p>
<ol>
<li>登录受信任网站A，并在本地生成Cookie。</li>
<li>在不登出A的情况下，访问危险网站B。</li>
</ol>
<p>看到这里，你也许会问：“如果我不满足以上两个条件中的一个，我就不会受到CSRF攻击”。是滴，确实如此，但是你不能保证以下情况不会发生：</p>
<ul>
<li>你不能保证你登录了一个网站之后，不再打开一个tab页面并访问其它的网站（黄网）。</li>
<li>你不能保证你关闭浏览器之后，你本地的Cookie立刻过期，你上次的会话已经结束。</li>
<li>上述中所谓的攻击网站，可能就是一个钓鱼网站或者黄色网站。</li>
</ul>
<p>防御CSRF攻击：</p>
<ul>
<li>通过 referer、token 或者 验证码 来检测用户提交。</li>
<li>尽量不要在页面的链接中暴露用户隐私信息。</li>
<li>对于用户修改删除等操作最好都使用post 操作 。</li>
<li>避免全站通用的cookie，严格设置cookie的域。</li>
</ul>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器结构</title>
    <url>//post/browser/</url>
    <content><![CDATA[<p>简单来说浏览器可以分为两个部分，shell+内核，其中shell的种类比较多，内核的种类则比较少。</p>
<p>Shell是指浏览器外壳：菜单、工具栏等；主要提供给用户操作，参数设置等，调用内核实现各种功能。</p>
<p>内核是浏览器的核心，基于标记语言显示内容的程序或模块。可分两部分，渲染引擎和JS引擎，负责渲染网页内容，计算网页的显示方式，不同内核的渲染效果不同。JS引擎则执行javascript实现网页的动态效果。</p>
<a id="more"></a>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>浏览器一般由以下组件构成：<br>1.用户界面：包括地址栏、前进/后退按钮、书签菜单等。<br>2.浏览器引擎：在用户界面和呈现引擎之间传送指令。<br>3.呈现引擎：负责显示请求的内容，解析html和css内容，显示在屏幕上、<br>4.网络：用于网络调用，比如HTTP请求，其接口与平台无关，并为所有平台提供底层实现。<br>5.用户界面后端：绘制基本的窗口小部件，比如组合框和窗口。 其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。<br>6.JavaScript解析器：解析执行JavaScript代码。<br>7.数据存储：持久层。实现了Cookie，web Stroage、indexDB的功能支持。</p>
<p>Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p>
]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域</title>
    <url>//post/cross-domain/</url>
    <content><![CDATA[<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>源：源由协议，域名和端口号组成，若url地址的协议、域名和端口号均相同则属于同源。</p>
<p>同源策略：浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对象自资源。其阻止的是数据的接受而不是请求的发送</p>
<p>不受同源策略限制：<br>页面中的链接，重定向以及表单提交；<br>可以引入跨域资源，但js不能读写加载内容。 如嵌入到页面中的<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>，<code>&lt;img&gt;</code>，<code>&lt;link&gt;</code>，<code>&lt;iframe&gt;</code>等。</p>
<h3 id="跨域：受同源策略的限制，不同源的脚本不能操作其他源下面的对象，想操作另一个源下面的对象就是跨域。"><a href="#跨域：受同源策略的限制，不同源的脚本不能操作其他源下面的对象，想操作另一个源下面的对象就是跨域。" class="headerlink" title="跨域：受同源策略的限制，不同源的脚本不能操作其他源下面的对象，想操作另一个源下面的对象就是跨域。"></a>跨域：受同源策略的限制，不同源的脚本不能操作其他源下面的对象，想操作另一个源下面的对象就是跨域。</h3><a id="more"></a>
<p>实现方式：</p>
<ul>
<li>document.domain</li>
<li>JSONP</li>
<li>CORS</li>
<li>window.name</li>
<li>postMessage H5</li>
</ul>
<p>需要跨域的场景：</p>
<ol>
<li>上传图片、文件</li>
<li>富文本编辑器</li>
<li>页面请求第三方接口</li>
</ol>
<p><strong>降域 document.domain</strong></p>
<p>将两个不同源的域名document.domain设置为同一个即可；存在安全性问题，一个网站被攻击，另一个也有安全漏洞，只适用于cookie和iframe窗口。</p>
<p><strong>跨域资源共享 CORS</strong></p>
<p>设置服务器响应头 Access-Control-Allow-Origin 指定允许跨域的源，实现浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p>
<p><strong>JSON with Padding JSONP</strong></p>
<p>动态插入script标签，通过script标签引入一个js文件， 在服务端输出JSON数据，客户端执行回调函数，从而解决了跨域的数据请求。 jsonp+padding–将json填充到一个盒子里，（使用回调函数获取json数据）；兼容性好，简单易用，支持浏览器与服务器双向通信。当然也有一些缺点：权限漏洞，只能发送GET请求，需要防止XSS。</p>
<p><strong>window.name</strong></p>
<p>一个窗口的声明周期内，窗口载入的所有页面都是共享一个name属性的，每个页面都对window.name有读写权限，其属性持久存在，不因新页面载入而进行充值。</p>
<p>在原页面中使用一个隐藏的iframe充当中间人角色，由iframe去获取数据，src设为目标页面，再把src设置跟原页面同一个域，否则受到同源策略的限制。原页面再去得到iframe获取到的数据，iframe的window.name。</p>
<p><strong>postMessage</strong></p>
<p>H5提供的一个API</p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>从HTTP到互联网协议，浏览器与服务器之间不得不说的故事</title>
    <url>//post/http/</url>
    <content><![CDATA[<blockquote>
<p>浏览器与服务器之间美好约定</p>
</blockquote>
<h2 id="过桥米线的传说"><a href="#过桥米线的传说" class="headerlink" title="过桥米线的传说"></a>过桥米线的传说</h2><p>相传，清朝时滇南蒙自市城外有一湖心小岛，一个秀才到岛上读书，秀才贤慧勤劳的娘子常常弄了他爱吃的米线送去给他当饭，但等出门到了岛上时，米线已不热了。<br>后来一次偶然送鸡汤的时候，秀才娘子发现鸡汤上覆盖着厚厚的那层鸡油有如锅盖一样，可以让汤保持温度，如果把佐料和米线等吃时再放，还能更加爽口。<br>于是她先把肥鸡、筒子骨等熟好清汤，上覆厚厚鸡油;米线在家烫好，而不少配料切得薄薄的到岛上后用滚油烫熟，之后加入米线，鲜香滑爽。<br>此法一经传开，人们纷纷仿效，因为到岛上要过一座桥，也为纪念这位贤妻，后世就把它叫做”过桥米线”。</p>
<a id="more"></a>
<p>好的，故事就这里。</p>
<h2 id="HTTP-协议？"><a href="#HTTP-协议？" class="headerlink" title="HTTP..协议？"></a>HTTP..协议？</h2><p>首先我们先来简单了解下什么是HTTP协议。</p>
<p>浏览器，大家都不陌生。<br>地址栏输入一个网址，对应的网页就会跳出来，那么，这个网页是怎么来的呢？<br>是浏览器自己弄出来的吗？显然不是，网站的所有资源都源于服务器；<br>浏览器只是拿到服务器的资源，“翻译”一下给呈现给用户。<br>那么，浏览器是通过什么方式告诉服务器我需要这个网页，而服务器又怎么知道浏览器需要的是哪个页面？<br>浏览器与服务器的交互有很多种，最常见的一种是HTTP请求，即—–HTTP协议。</p>
<p>HTTP协议约定了两者之间的沟通方式，才不会牛头马嘴。<br>协议由<strong>请求（requset）</strong>与<strong>响应（reponse）</strong>触发。</p>
<blockquote>
<p>HTTP是因特网上一种常见的数据传输协议</p>
</blockquote>
<p><em>服务器：说起来你可能不信，是它先动手的！</em></p>
<h3 id="事务，URL，报文"><a href="#事务，URL，报文" class="headerlink" title="事务，URL，报文"></a>事务，URL，报文</h3><p>接下来我们来了解下HTTP协议的体现过程。</p>
<p>浏览器的地址栏输入网址，将会发送一个HTTP请求；<br>服务器收到浏览器的请求，响应数据给浏览器；<br>浏览器解析资源渲染到界面。<br>这种通信方式使用<strong>HTTP报文</strong>的格式化数据块进行。<br>至此，一条完整的请求和响应命令，整个过程称之为<strong>HTTP事务</strong>。</p>
<p>浏览器凭借着URL，准确地请求资源，服务器响应并传输回数据。<br>每个web服务器资源都有一个名字——统一资源标识符（url）。<br>有了这个名字，浏览器才能找到对应的资源，url有特定的标准格式。<br>一个url分为3个部分：<br>协议代码，装由所需文件的计算机地址和主机资源的具体位置。<br><code>scheme://host[:post]/path/filename</code></p>
<ul>
<li>scheme - 协议名称</li>
<li>host - IP地址或计算机名称</li>
<li>post - 服务器端口</li>
<li>path - 文件路径</li>
<li>filename - 文件名</li>
</ul>
<p>例：<code>http://www.4399.com/</code></p>
<p>PS：我们说的“网址”、“域名”都属于url的范畴。</p>
<p>以HTTP的角度讲，<br>浏览器（Browser）是客户端（Client），<br>服务器（Server）是服务端（Server）；<br>也就是说浏览器和服务器模式是B/S结构，<br>即：Browser/Server(浏览器/服务器)结构。</p>
<p>客户端发送请求报文，服务器回复响应报文；<br>请求报文和响应报文的格式都由以下三个部分组成</p>
<ul>
<li>起始行：由方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔</li>
<li>首部字段：由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔，关于请求/响应的信息</li>
<li>主体：要发送给服务器的请求数据，或是服务器回复的响应数据</li>
</ul>
<p><img src="/http/image1.jpg" alt="d7c0e5cfe6eb9ced302d14b50422caaf.png"></p>
<p><em>一个简单的HTTP实例 图源于《HTTP权威指南》</em></p>
<h4 id="详解请求报文和响应报文"><a href="#详解请求报文和响应报文" class="headerlink" title="详解请求报文和响应报文"></a>详解请求报文和响应报文</h4><p>请求报文和响应报文的差异不大，可以对比了解。</p>
<table>
<thead>
<tr>
<th></th>
<th>请求报文</th>
<th>响应报文</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>起始行</td>
<td>请求行：请求url、HTTP版本、请求方法</td>
<td>响应行：HTTP版本，状态码， 状态码短语</td>
<td>用空格分隔</td>
</tr>
<tr>
<td>首部字段</td>
<td>请求头：数量不定，关于客户端的请求信息</td>
<td>请求行：关于服务器的响应信息</td>
<td>特定的分类用于请求头或用于响应头</td>
</tr>
<tr>
<td>主体</td>
<td>请求主体：一般是POST方法的请求数据</td>
<td>响应主体：HTTP响应请求的真正数据</td>
<td>HTTP所传输的内容</td>
</tr>
</tbody>
</table>
<h4 id="方法与状态码"><a href="#方法与状态码" class="headerlink" title="方法与状态码"></a>方法与状态码</h4><p>即使是同一个url，如果使用了其他的请求方法，服务器没有为url设置相对应的响应方法，那浏览器也不会拿到正确的资源，可能会出现的是几个数字（状态吗）和一句短语（原因短语）；</p>
<p><img src="/http/image2.jpg" alt></p>
<p><em><a href="https://fifth-patient.github.io/_">https://fifth-patient.github.io/_</a> 404代表了什么？</em></p>
<p>因此最后小节我们有必要学习HTTP的请求方法和状态码。</p>
<p>根据HTTP标准，HTTP请求定义了多种请求方法，在不同场景下执行不同的动作，常见的有…<br><code>GET</code>：向服务器请求资源（最常用的HTTP方法）<br><code>POST</code>：输入数据（一般用于用户登录，付款等）<br><code>PUT</code>：写入文档（更新数据，发表文章，评论等）<br><code>DELETE</code>：删除请求资源（删除资源，但服务器不一定会删除）</p>
<p>为了便于理解，我们拿两个使用频率最高的方法比较一下。</p>
<p><strong>GET与POST的区别</strong></p>
<ul>
<li>便利：浏览器后退对GET请求无影响，浏览器<strong>主动缓存GET请求</strong>，而<strong>POST不缓存</strong>且后退历史再次提交请求</li>
<li>参数：GET请求参数记录在<strong>原url后</strong>且有<strong>长度限制</strong>，而POST中的参数记录在<strong>请求主体</strong>中</li>
<li>安全：GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递<strong>敏感信息</strong></li>
<li>编码：GET请求只能进行url编码，而POST支持多种编码方式</li>
</ul>
<p><strong>状态码</strong>：三位数字组成，第一个数字定义了响应的类别，且有五种可能取值</p>
<ul>
<li>1xx：指示信息–表示请求已接收，继续处理</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求</li>
</ul>
<p><strong>短语</strong>：对状态码的描述，帮助用户理解状态码原因</p>
<p>以下是常见的响应状态码和短语</p>
<ul>
<li>200 OK      //客户端请求成功</li>
<li>304 Not Modified //请求资源的缓存可以使用，响应缓存的文件</li>
<li>400 Bad Request  //客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</li>
<li>403 Forbidden  //服务器收到请求，但是拒绝提供服务</li>
<li>404 Not Found  //请求资源不存在，eg：输入了错误的URL</li>
<li>500 Internal Server Error //服务器发生不可预期的错误</li>
<li>503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
<p>以该url - <a href="https://fifth-patient.github.io/_">https://fifth-patient.github.io/_</a> 为例，这个地址是没有任何资源的，故服务器返回了404提示我们Not Found，原因可能是：之前的资源被删除了，所以这里没有资源了亦或者根本就没有资源。这里我们只是单纯网址最后打多了一个<code>_</code>而已。</p>
<p>唧唧歪歪了那么多，我们再结合开头的故事小结一下。</p>
<ul>
<li>《过桥米线》中，娘子送米线给丈夫，丈夫食用完娘子回家；类似浏览器与服务器之间使用<strong>请求</strong>和<strong>响应</strong>完成一个<strong>HTTP事务</strong></li>
<li>米线是娘子送给丈夫的午餐；而则浏览器使用<strong>HTTP报文</strong>这种格式发送数据供服务器响应，报文只是格式，为的是发送数据</li>
<li>娘子曾尝试赶马车送餐，不过米线还是凉了；正如HTTP有多种请求方法，合理使用<strong>请求方法</strong>服务器方可正确响应资源</li>
</ul>
<p>恭喜读者了解了HTTP协议的一些基本概念，想深入探索的的朋友请往下看…</p>
<h2 id="HTTP背后的组织"><a href="#HTTP背后的组织" class="headerlink" title="HTTP背后的组织"></a>HTTP背后的组织</h2><p>很高兴读者继续下划，那么现在我们已经认识了HTTP这位朋友，（从读者学会网上冲浪的那一刻，它就一直在你身边），接下来我们来认识一下这位朋友所在的组织<strong>互联网协议</strong>。</p>
<p>《名侦探柯南》中的琴酒，黑衣组织（酒厂）的高级成员，可以得到“那位先生”的直接命令。</p>
<p>HTTP也并非单枪作战，背后也犹如琴酒背后的酒厂，那么我们来介绍下“酒厂”。</p>
<h3 id="互联网协议，五层模型"><a href="#互联网协议，五层模型" class="headerlink" title="互联网协议，五层模型"></a>互联网协议，五层模型</h3><p><strong>什么是互联网？</strong></p>
<blockquote>
<p> 互联网（英语：Internet），是21世纪之始网络与网络之间所串连成的庞大网络，这些网络以一组标准的网络TCP/IP协议族相连，连接全世界几十亿个设备，形成逻辑上的单一巨大国际网络。 ——wiki百科</p>
</blockquote>
<p>……这，也太概念化了吧？？</p>
<p><strong>简单一句话：世界上所有的网络组成起来就是互联网。</strong></p>
<p>PS：互联网、因特网、万维网的概念之后再讨论，本篇文章的重要在于HTTP。</p>
<h4 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h4><p>所有的网络环境组成了互联网，所以互联网很庞大，从模型上有3种分层方式：</p>
<ol>
<li>OSI分层 （7层）</li>
<li>TCP/IP分层（4层）</li>
<li>五层协议 （5层）</li>
</ol>
<p>就像“酒厂”一样，一个优秀的<del>暗杀</del>组织，肯定<strong>结构清晰</strong>，<strong>分工明确</strong>；<br>伏特加跟着琴酒清除卧底，然后其他人不是卧底就是渣渣，是的，结构清晰，谁是大反派谁是卧底谁是渣一下子就看出来了；<br>分工明确，琴酒一个人为组织拼死拼活，伏特加给琴酒开车，其他人，其他人.. 不知道琴酒先生会怎么想？</p>
<p><em>琴酒：酒厂都是假酒，这活没法干了!(摔酒瓶)</em></p>
<p>这里我们主要说说五层模型。</p>
<blockquote>
<p>五层模型将互联网分成了5个层，每一个层都定应了很多协议，所有的协议都是互联网协议。</p>
</blockquote>
<p><img src="/http/image3.jpg" alt="f2eedd2ab72134dfe7c5350f9837b39d.png"></p>
<p>应用层(Application Layer): 规定应用程序的数据格式。 应用程序协议<br>传输层(Transport Layer): 建立”端口到端口”的通信      UDP协议    TCP协议<br>网络层(Network Layer)： 建立”主机到主机”的通信      IP协议    ARP协议<br>链接层(Link Layer)：在“实体层”上方，确定了0和1的分组方式    以太网协议<br>实体层(Physical layer)：把电脑连接起来的物理手段。负责传送0和1的电信号</p>
<p>顺序从下到上看，越下面的层，越靠近硬件；越上面的层，越靠近用户。</p>
<!--
**实体层** 实体层使用物理把电脑（两台或以上）连起来，光缆，电缆，无线电波都行，传递0与1的电信号。

**链接层** 定义电信号，确定0和1的分组方式。使用了**以太网协议**，通过识别网卡的MAC地址识别发送者（网卡的MAC地址具有唯一性），以太网并不一对一直接发送数据包给接受方，以**广播**的方法发送给以太网的所有计算机，计算机将自己的MAC地址与数据包的接受者比较，若本机不是接受方，丢弃该包；本机确定接收者的身份，才会进一步处理。 
以太网协议、网卡的MAC地址、广播发送组成链接层，使得计算机之间可以传递数据。

**网络层** 

-->
<h4 id="HTTP连接方式"><a href="#HTTP连接方式" class="headerlink" title="HTTP连接方式"></a>HTTP连接方式</h4><p>HTTP属于应用层的一种互联网协议，基于TCP/IP协议，是两者的一种具体运用。五层模型中的应用层除了HTTP还有其他的协议。<br>  http：超文本传输协议<br>  https：安全超文本传输协议<br>  IP：TCP/IP协议<br>  ftp：文件传输协议<br>  SMTP：邮件传输协议</p>
<blockquote>
<p>HTTP协议位于TCP/IP上层，HTTP使用TCP/IP传输报文数据。</p>
</blockquote>
<p>看到这里，应该理解了浏览器发送HTTP请求，是通过TCP/IP的方式与服务器链接的。</p>
<p><strong>如何建立TCP连接？</strong></p>
<p><img src="/http/image4.jpg" alt="6c4f9604d0f4cc83eb0293c6659d646a.png"></p>
<p><strong>三次握手</strong>：建立一个TCP连接时，需要客户端和服务器总共发送3个包</p>
<ol>
<li>首先，请求新的TCP 连接，客户端向服务器发送一个小的 TCP 分组这个分组中，包含的<strong>SYN</strong>标记说明这是一个连接请求。（a ）。 </li>
<li>接着，如果服务器接受了连接，会向客户端回送一个 TCP 分组，这个分组中的 <strong>SYN</strong> 和 <strong>ACK</strong> 标记都被置位，说明连接请求已被接受（b ）。</li>
<li>最后，客户端向服务器回送一条确认信息，通知它连接已成功建立 （c ）。</li>
</ol>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据；<br>三次握手为了是连接服务器指定端口，建立TCP连接，并同步连接交换TCP信息。</p>
<p>断开TCP连接客户端需要和服务器发送四个包，最终确认断开。因此称为<strong>四次挥手</strong>，这里并不详细说明具体过程。</p>
<p>关于“酒厂”的介绍就到这里，读者到这里能对互联网有一个大概的了解就行了，我们继续探索HTTP。</p>
<h2 id="回到http"><a href="#回到http" class="headerlink" title="回到http"></a>回到http</h2><p>保时捷356-A是琴酒的爱车，黑色风格是他的穿衣风格，不记住死人的名字，每次只执行一次任务，但使命必达（柯南是个例外），必要时穷追不舍。</p>
<p><em>“不好意思啊伏特加，已经杀掉的人的脸和名字，我是从来不去记的。”</em></p>
<p>HTTP在某方面也跟琴酒有点类似，每次连接只能处理一个请求（但可以使用<strong>持久连接</strong>），不关心处理了多少条事务，可以传输多种类型数据：文本，图片，网页，音频等..</p>
<p>PS：事务结束连接后，TCP可使连接保持打开状态，这种技术叫<strong>持久性连接</strong></p>
<p>正式给HTTP一个简介：</p>
<ul>
<li>超文本传输协议 (Hyper Text Transport Protocol, HTTP)最为广泛的一种网络传输协议</li>
<li>基于TCP/IP通信协议来传递数据</li>
<li>连接所有的WWW文件都必须遵守这个标准</li>
<li>无连接：限制每次连接只处理一个请求</li>
<li>任何类型的数据都可以通过HTTP发送</li>
<li>无状态协议：对于事务处理没有记忆能力</li>
</ul>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>虽说浏览器发送请求给服务器，但HTTP传输数据并不是直达目的服务器的。且HTTP是使用明文（不加密）传输数据的。这意味者请求在发送过程中，可能数据会被抓到导致泄露纂改，或经过某个网关/代理被拦截下来自己的身份被冒充，因此<strong>HTTP并不安全</strong>，为了确保请求能准确加密送达服务器，HTTPS出现了。</p>
<!-- 龙舌兰是墨西哥的一种烈酒，它的传统喝法是配上柠檬和盐。 -->
<p><img src="/http/image5.jpg" alt="c04dbca7e19b08519ebf1ad2df2fd090.png"></p>
<p><em>还记得之前一笔带过的TCP/IP分层（4层）吗？</em></p>
<p><strong>如何加密？</strong></p>
<p>HTTPS在安全的传输层上发送HTTP，在这里先加密后发送报文给TCP。同样遵循一层有一个或多个协议，安全层通过SSL或TLS协议实现（SSL采用公开密钥加密），安全层使得即使请求被第三方获取，也无法识别数据内容。</p>
<p>这里涉及到密码学的一些基本知识</p>
<ul>
<li>SSL的加密方式是公开密钥加密</li>
<li>密钥是一套对明文进行编码/转码的算法</li>
<li>公开密钥即公开编码密钥</li>
<li>每个人拥有不同的解码密钥</li>
<li>非对称加密的编码和解码密钥不同</li>
</ul>
<p>密码学上，没有绝对安全的密码，如果暴力破解，是可以破解出来的，只是时间长短问题，有些密码可能需要好几百年才能破解，详情了解MD5加密。</p>
<p><em>“锄头凿得好，没有挖不到的墙角。”</em></p>
<p><strong>签名与证书</strong></p>
<p>服务器远在他乡，有时候网页打不开都得先看下wifi信号是不是不好，再检测下站点的服务器是不是问题；那正常情况下，又有谁能保证请求一定送达服务器？</p>
<p>我们可以考虑给HTTP的报文签名，以备注报文的编写作者。同时，我们需要一个公正的、值得信赖的组织，保证这个连接是安全的。</p>
<p><strong>数字签名</strong>技术使用加密系统给报文签名，说明是谁编写的报文，同时也能证明报文没有被篡改过，这可以保证报文的准确传输。</p>
<p><strong>服务器证书</strong>，SSL数字证书的一种形式，是因特网上的“ID卡”，由官方的“证书颁发机构”签发。记录了服务器名称，过期时间，证书发布者和发布者的数字签名等。</p>
<p>SSL不检测站点服务器的证书，现代浏览器会自行检查，若没有证书，浏览器会警告用户连接并不安全。</p>
<p><img src="/http/image6.jpg" alt><br><img src="/http/image7.jpg" alt></p>
<p><em>浏览器检测证书</em></p>
<p>一个未正确配置SSL的网址，打开看看自己的浏览器有没有对SSL检测？<a href="https://self-signed.badssl.com/" target="_blank" rel="noopener">https://self-signed.badssl.com/</a></p>
<p>相信比我更敏慧的你早已发现：”S”代表safe(安全)，safe是SSL/TLS。</p>
<p>基本概念已经知晓，是时候来一波SSL连接了。</p>
<p><strong>SSL握手</strong></p>
<p>SSL握手发生在HTTP传输加密报文前，它们会完成以下工作：</p>
<ul>
<li>交换协议版本号</li>
<li>选择一个两端都了解的密码（公钥）</li>
<li>对两端身份进行认证</li>
<li>生成临时密钥，加密通道</li>
</ul>
<p>由于多了一次SSL握手过程，相同的网络环境下，HTTPS比HTTP要费时。</p>
<p><strong>兼容HTTP</strong></p>
<p>如果自己的网站从HTTP升级到了HTTPS，那么需要考虑用户可能会按照之前的习惯<a href="http://fifth-patient.github.io/">http://fifth-patient.github.io/</a>，而不是输入<a href="https://fifth-patient.github.io/">https://fifth-patient.github.io/</a>，这导致用户并不能使用该网站的HTTPS协议。所幸，http和https使用的默认端口(port)不同。http的默认端口是80或者8080，https默认端口是443。我们可以在http的默认端口设置代理使之跳转到https的443。</p>
<p><a href="http://fifth-patient.github.io/">http://fifth-patient.github.io/</a> = <a href="http://fifth-patient.github.io:80/">http://fifth-patient.github.io:80/</a></p>
<p><a href="https://fifth-patient.github.io/">https://fifth-patient.github.io/</a> = <a href="https://fifth-patient.github.io:443/">http://fifth-patient.github.io:443/</a></p>
<p>以上四个超链接都可正确打开此博客主页。</p>
<p>PS：上文提及的URL格式中<code>port</code>参数出现了</p>
<p><strong>对比HTTP</strong></p>
<p>按照惯例，接下来是小结的时间。</p>
<ul>
<li>HTTPS：超文本安全传输协议(Hypertext Transfer Protocol Secure)</li>
<li>以安全为目标的HTTP通道，简单讲是HTTP的安全版</li>
<li>在HTTP下加入SSL层，提供加密传输和身份验证功能</li>
<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</li>
<li>HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%</li>
<li>HTTPS是现行架构下最安全的解决方案，并非绝对安全</li>
</ul>
<h3 id="不止浏览器"><a href="#不止浏览器" class="headerlink" title="不止浏览器"></a>不止浏览器</h3><p>再次把话题的范围放大。HTTP也并不是浏览器特有使用的协议，更运行上在其他的客户端(Client)上，如印象笔记，微信，音乐播放器等，甚至自己写的一个网络爬虫程序，也是HTTP客户端。只要可以发送HTTP报文的，都是HTTP的客户端。浏览器是最经典的HTTP客户端，且浏览器支持HTTP协议的同时，更支持ftp， file协议。</p>
<p>C/S结构：客户机/服务器模式，是基于企业内部网络的应用系统。由于Web浏览器的兴起，B/S模式逐步取代了C/S模式，被更广泛地应用。</p>
<blockquote>
<p>B/S结构基于C/S结构，是其本身的一种改良。</p>
</blockquote>
<h3 id="web控件"><a href="#web控件" class="headerlink" title="web控件"></a>web控件</h3><p>而客户端到服务器之间并不是直连的。也就是说，报文在传输的过程，需要经过好几个结构组件，如代理、缓存、网关、隧道、Agent代理。举个例子，我们浏览一个美国的网站，如果网站配置了CDN，而在国内正好有某个节点有缓存；且缓存未过期。这时候我们的请求被国内的节点处理，返回的结果是其缓存，从物理角度看，这远比直接跑到美国拿数据要快得过。</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>这是在下写的第一篇博文，本意是简单写写HTTP协议的。<br>网上冲浪离不开这位老朋友，因此我觉得第一篇博文以HTTP为话题多少有点起点性的意义。<br>技术型的文章如果太多术语，逼格是高了，但是会隐晦难懂。<br>因此在保证文章质量的前提下，插入了两个小故事，使得趣味性高一点。<br>更深层的技术也没怎么提及，所以这篇文章的定位是科普文章。</p>
<h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3><p>那么，关于HTTP就到此为止了吗？不不不，HTTP的话题太过庞大，文章简述了一些比较主要的知识点而已，更衍生出了很多相关的话题。</p>
<ul>
<li>互联网、因特网、万维网是什么？</li>
<li>浏览器访问网页的详细过程？</li>
<li>五层模型中的其他协议</li>
<li>web控件的功能？</li>
<li>https与web安全</li>
<li>如何设置缓存</li>
<li>用户认证机制</li>
</ul>
<p>在这之前也有很多优秀的前辈的写过相关的文章，这些话题以后再慢慢提及。<br>还有HTTP的历史需要读者自行探索，这里介绍两本书：<a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener">《HTTP权威指南》</a>、 <a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">《图解HTTP》</a>。</p>
<p>相信看完整篇文章，读者再去看书也会有更深层次的收获。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>《过桥米线》中，妻子送米线表达对夫君的爱意和仕途的支持；<br>浏览器与服务器之间使用HTTP协议交互；<br>所以我想：HTTP协议应该是浏览器和服务器之间的美好约定吧。</p>
<p>琴酒纵使能力再强，也属于“酒厂”组织的其中一个成员；<br>HTTP固然如此，名气再大，也希望读者不要忘记在背后支持它的互联网协议。</p>
<p>最后，<br>希望朋友吃米粉的时候能想起HTTP；<br>喝酒的时候能想起互联网协议；<br>喝酒吃米粉的时候能想到我。</p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见缓存机制</title>
    <url>//post/web-cache/</url>
    <content><![CDATA[<blockquote>
<p>缓存是捷径，使http抄近道</p>
</blockquote>
<!-- cookie session Web Stroage -->
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>Cookie 是服务器保存在浏览器的一小段文本信息。浏览器每次向服务器发出请求，就会自动附上这段信息，是前端的一种常见而又传统的缓存机制。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>用于保存页面信息：如自动登录，记住用户名</li>
<li>以域名为单位，数量大小有4k-10k，有过期时间</li>
<li>js中通过<code>doucment.cookie</code>调用</li>
<li>cookie的传递<br>从服务器端，发送cookie给客户端，是对应的Set-Cookie头信息。包括了对应的cookie的名称，值，以及各个属性。<br>从客户端发送cookie给服务器，对应Cookie头信息，不发送cookie的各个属性，只发送对应的名称和值。</li>
</ol>
<a id="more"></a>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol>
<li>设置：<code>doucument.cookie=&quot;name=value;max-age=seconds;Path=path;HttpOnly;&quot;</code>等；一次设置一个值，同名参数会进行覆盖</li>
<li>指定过期时间的cookie会存储在本地，没有指定时为session Cookie，会话结束后cookie删除，设置domain和paath可指定cookie的作用域。httponly指定cookie必须用http或https传输，该属性可限制js访问操作此cookie。secure可指定cookie只能使用https传输。</li>
<li>读取：document.cookie会返回cookie的名和值，其他参数不会返回，如：a=1;b=2; 每个cookie的名值通过分号分割。</li>
<li>删除：将max-age设置为-1</li>
</ol>
<h3 id="cookie优点"><a href="#cookie优点" class="headerlink" title="cookie优点"></a>cookie优点</h3><p>可配置性和可扩展性</p>
<ol>
<li>可以在客户端上保存用户数据，起到简单的缓存和用户身份识别等作用</li>
<li>保存用户的偏好，比如网页的字体大小、背景色等等。</li>
<li>记录用户的行为</li>
</ol>
<h3 id="cookie的缺陷"><a href="#cookie的缺陷" class="headerlink" title="cookie的缺陷"></a>cookie的缺陷</h3><p>数据数量：每个cookie的大小限制在4k，不同的浏览器对同一个域下的cookie的数量有限制，IE6 20，IE7+ 50，Firefox 50，Safari ∞，Chrome 53。数量超出时， IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。保险起见cookie的数量应控制在20个，单个cookie大小应小于4KB。</p>
<p>安全性问题：HTTP请求中的cookie是明文传递（HTTPS不是），故敏感信息不能使用cookie存储，如用户密码等。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</p>
<p>网络负担：cookie会被附加在每个HTTP请求中，在请求和响应时都会被传输，所以增加了流量的损失。</p>
<h2 id="seesion"><a href="#seesion" class="headerlink" title="seesion"></a>seesion</h2><p>存储会话机制，保存在服务器上。客户端访问服务器时，服务器把客户端信息以某种形式记录在服务器上。再次访问时只需要从该Session中查找该客户的状态就可以了。</p>
<p>标识用户身份： 用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId，cookie把SessiondId自动带到服务器。</p>
<p>session创建：当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了sessionId，如果已包含则说明以前已经为此客户端创建过session，服务器就按照sessionId把这个session检索出来使用（检索不到，会新建一个）。如果客户端请求不包含sessionId，则为此客户端创建一个session并且生成一个与此session相关联的sessionId，sessionId的值是一个既不会重复，又不容易被找到规律以仿造的字符串，这个sessionId将被在本次响应中返回给客户端保存。</p>
<p>禁用cookie：如果客户端禁用了cookie，通常有两种方法实现session而不依赖cookie。<br>1）URL重写，就是把sessionId直接附加在URL路径的后面。<br>2）表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器</p>
<p>Session共享：对于多网站(同一父域不同子域)单服务器，我们需要解决的就是来自不同网站之间SessionId的共享。由于域名不同(aaa.test.com和bbb.test.com)，而SessionId又分别储存在各自的cookie中，因此服务器会认为对于两个子站的访问,是来自不同的会话。解决的方法是通过修改cookies的域名为父域名达到cookie共享的目的,从而实现SessionId的共享。带来的弊端就是，子站间的cookie信息也同时被共享了。  </p>
<p>cookie与session的区别<br>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。<br>2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。<br>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。<br>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。<br>5、可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。</p>
<h2 id="web-Storage"><a href="#web-Storage" class="headerlink" title="web Storage"></a>web Storage</h2><p>web 本地存储对浏览器来说，使用 Web Storage 存储键值对比存储 Cookie 方式更直观，而且容量更大，它包含两种：localStorage 和 sessionStorage</p>
<p>sessionStorage（临时存储） ：为每一个数据源维持一个存储区域，在浏览器打开期间存在，包括页面重新加载<br>localStorage（长期存储） ： 一直存储在本地，数据存储是永久的，除非用户或程序对其进行删除操作；localStorage 对象存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 </p>
<p>sessionStorage 和 localStorage 的用法基本一致，引用类型的值要转换成JSON</p>
<p>特点：<br>域内安全、永久保存。即客户端或浏览器中来自同一域名的所有页面都可访问localStorage数据且数据除了删除否则永久保存，但客户端或浏览器之间的数据相互独立。<br>数据不会随着Http请求发送到后台服务器；<br>存储数据的大小至少4MB。</p>
<p>存储方式：以键值对(Key-Value)的方式存储字符串。<br>主要应用：购物车、客户登录、游戏存档。。。<br>可储存的数据类型：数组，图片，json，样式，脚本。。。（只要是能序列化成字符串的内容都可以存储）</p>
<p>JS API<br>localStorage.setItem(键名，键值)    在本地客户端存储一个字符串类型的数据<br>localStorage.getItem(键名)   读取已存储在本地的数据<br>localStorage.removeItem(键名)  移除已存储在本地的数据<br>localStorage.clear()   移除本地存储所有数据</p>
<p>sessionStorage中的四个函数与以上localStorage类的函数用法基本一致</p>
<p>cookie与web Storage的区别<br>1、cookie数据始终在同源的http请求中携带<br>2、cookie可设置路径，限制其作用域<br>3、存储大小，cookie不能超过4k，web Storage可达5M<br>4、cookie有数据有效期，web Storage无<br>5、作用域不同，sessionStroage不在不同浏览器窗口共享，<br>      localStorage与cookie在所有同源窗口共享</p>
<p>cookie与webStorage的使用方法<br>1、兼容性：IE9+支持web Storage，cookie作为远古时期产物，无兼容性问题<br>2、交互性：web Storage不与服务器交互，需要与服务器交互时使用cookie<br>3、数据大小：cookie不能超过4k，web Storage可达5M</p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>嗜夜</title>
    <url>//post/killing-night/</url>
    <content><![CDATA[<p>夜晚的钟声慢慢敲起。<br>原始丛林狼群双眸诡异的光芒。<br>无处安放的灵魂也回归平静。</p>
<p>教徒合诵古老冗长的咒语。<br>祭坛的封印一步步被封开。<br>古墓冰尸发出阵阵哀嚎。<br>锁链断裂，癫狂抑制不住。<br>屠杀活动的序幕早已开始。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>用信鸽来解释 HTTPS</title>
    <url>//post/https/</url>
    <content><![CDATA[<p>2019/01/09 | 分类： 基础技术 | 2 条评论 | 标签： https</p>
<blockquote>
<p>译文出处： <a href="https://www.oschina.net/translate/https-explained-with-carrier-pigeons" target="_blank" rel="noopener">oschina</a> |  原文出处：<a href="https://medium.freecodecamp.org/https-explained-with-carrier-pigeons-7029d2193351" target="_blank" rel="noopener">freecodecamp</a></p>
</blockquote>
<p>密码学是一门难以理解的学科，因为它充满了数学定理。但是除非你要实际开发出一套加密算法系统，否则你是没必要强制理解那些深奥的数学定理的。</p>
<p>如果你阅读本文的目的是想设计下一套 HTTPS 协议，那我只能抱歉的说本文的知识还远远不够；如果不是的话，那么就煮杯咖啡，轻松愉悦的阅读本文吧。</p>
<h2 id="爱丽丝、鲍伯和-…-信鸽？"><a href="#爱丽丝、鲍伯和-…-信鸽？" class="headerlink" title="爱丽丝、鲍伯和 … 信鸽？"></a>爱丽丝、鲍伯和 … 信鸽？</h2><p>你在互联网上从事的任何活动（阅读这篇文章、在亚马逊上购物、上传图片等）归结到底都是从某台服务器上发送和接收信息。</p>
<p>这个说起来可能有点抽象，不如让我们假设这些消息都是由信鸽来传递的。我知道这个假设有些太过随意，但相信我 HTTPS 就是这样工作的，尽管它的速度快的多。</p>
<p>我们先不谈服务器、客户端或者黑客攻击，先来聊一下爱丽丝、鲍伯和马洛里。如果这已不是你第一次接触密码学理论，你应该会认识这些名字，因为他们经常在各种密码学文献中被提及。</p>
<h2 id="一个简单的通信方式"><a href="#一个简单的通信方式" class="headerlink" title="一个简单的通信方式"></a>一个简单的通信方式</h2><p>如果爱丽丝想给鲍伯发个消息，她会把消息绑在信鸽的腿上寄给鲍伯。然后鲍伯收到了消息，并阅读了它。这一切都是美好的。</p>
<p>但如果马洛里拦截了爱丽丝飞翔中的信鸽并且修改消息内容呢？鲍伯将无法知道爱丽丝发来的消息已经在传输过程中被修改了。</p>
<p>这就是 HTTP 的工作方式，很可怕吧？我绝不会通过 HTTP 发送我的银行凭证，希望你也不会。</p>
<a id="more"></a>
<h2 id="隐蔽的密码"><a href="#隐蔽的密码" class="headerlink" title="隐蔽的密码"></a>隐蔽的密码</h2><p>那么如果爱丽丝和鲍勃都非常的机智。他们一致认同使用一种隐蔽的密码来书写他们的信息。他们会将信息中的每个字母按照字母表中的顺序前移三位。比如，D→A，E→B，F→C。如此一来，原文为 “secret message” 的信息就变成了 “pbzobq jbppxdb” 。</p>
<p>那现在如果马洛里再截获了信鸽，她既不能做出有意义的修改同时也不会知道信息的内容，因为她不知道隐蔽的密码到底是什么。然而鲍勃却可以很容易反转密码，依靠 A → D, B → E, C → F 之类的规则破译信息的内容。加密后的信息 “pbzobq jbppxdb” 会被破解还原为 “secret message” 。</p>
<p>搞定！</p>
<p>这就是对称密匙加密，因为如果你知道如何加密一段信息那么你同样可以解密这段信息。</p>
<p>上述的密码通常被称为凯撒码。在现实生活中，我们会使用更为奇特和复杂的密码，但原理相同。</p>
<h2 id="我们如何决定密匙？"><a href="#我们如何决定密匙？" class="headerlink" title="我们如何决定密匙？"></a>我们如何决定密匙？</h2><p>如果除了发信者和收信者之外没有人知道使用的是什么密匙，对称密匙加密是非常安全的。在凯撒加密中，密匙就是每个字母变到加密字母需要移动多少位的偏移量。我之前的距离中，使用的偏移量是 3 ，但是也可以用 4 或者 12 。</p>
<p>问题是如果爱丽丝和鲍勃在开始用信鸽传信之前没有碰过头，他们没有一个安全的方式来确立密匙。如果他们自己来在信中传递密匙，马洛里就会截获信息并发现密匙。这就使得马洛里可以在爱丽丝和鲍勃开始加密他们的信息之前或之后，阅读到他们信息的内容并按照她的意愿来篡改信息。</p>
<p>这是一个中间人攻击的典型例子，避免这个问题的唯一方法就是收发信的两方一起修改他们的编码系统。<br>通过信鸽传递盒子</p>
<p>所以爱丽丝和鲍勃就想出了一个更好的系统。当鲍勃想要给爱丽丝发送信息时，他会按照如下的步骤来进行：</p>
<ul>
<li>鲍勃向爱丽丝送一只没有携带任何信息的鸽子。</li>
<li>爱丽丝给鲍勃送回鸽子，并且这只鸽子带有一个有开着的锁的盒子，爱丽丝保管着锁的钥匙。</li>
<li>鲍勃把信放进盒子中，把锁锁上然后把盒子送给爱丽丝。</li>
<li>爱丽丝收到盒子，用钥匙打开然后阅读信息。</li>
</ul>
<p>这样马洛里就不能通过截获鸽子来篡改信息了，因为她没有打开盒子的钥匙。当爱丽丝要给鲍勃发送消息的时候同样按照上述的流程。</p>
<p>爱丽丝和鲍勃所使用的流程通常被称为非对称密钥加密。之所以称之为非对称，是因为即使是你把信息编码（锁上盒子）也不能破译信息（打开锁住的盒子）。</p>
<p>在术语中，盒子被称为公匙而用来打开盒子的钥匙被称为私匙。</p>
<h2 id="如何信任盒子"><a href="#如何信任盒子" class="headerlink" title="如何信任盒子"></a>如何信任盒子</h2><p>如果你稍加注意你就会发现还是存在问题。当鲍勃收到盒子时他如何能确定这个盒子来自爱丽丝而不是马洛里截获了鸽子然后换了一个她有钥匙能打开的盒子呢？</p>
<p>爱丽丝决定签名标记一下盒子，这样鲍勃收到盒子的时候就可以检查签名来确定是爱丽丝送出的盒子了。</p>
<p>那么你们之中的一些人可能就会想了，鲍勃如何打一开始就能识别出爱丽丝的签名呢？这是个好问题。爱丽丝和鲍勃也确实有这个问题，所以他们决定让泰德代替爱丽丝来标记这个盒子。</p>
<p>那么谁是泰德呢？泰德很有名的，是一个值得信任的家伙。他会给任何人签名并且所有人都信任他只会给合法的人签名标记盒子。</p>
<p>如果泰德可以确认索要签名的人是爱丽丝，他就会在爱丽丝的盒子上签名。因此马洛里就不可能搞到一个有着泰德代表爱丽丝签了名的盒子，因为鲍勃知道泰德只会给他确认过的人签名，从而识破马洛里的诡计。</p>
<p>泰德的角色在术语中被称为认证机构。而你阅读此文时所用的浏览器打包存有许多认证机构的签名。</p>
<p>所以当你首次接入一个网站的时候你可以信任来自这个站点的盒子因为你信任泰德而泰德会告诉你盒子是合法的。</p>
<h2 id="沉重的盒子"><a href="#沉重的盒子" class="headerlink" title="沉重的盒子"></a>沉重的盒子</h2><p>现在爱丽丝和鲍勃有了一个可靠的系统来进行交流，然他们也意识到让鸽子携带盒子比原本只携带信件要慢一些。</p>
<p>因此他们决定只有在选择用对称加密来给信息编码（还记得凯撒加密法吧？）的密匙时，使用传递盒子的方法（非对称加密）。</p>
<p>这样就可以二者的优点兼具了，非对称加密的可靠性和对称加密的高效性。</p>
<p>现实世界中我们不会用信鸽这样慢的送信手段，但用非对称加密来编码信息仍要慢于使用对称加密技术，所以我们只有在交换编码密匙的时候会使用非对称加密技术。</p>
<p>现在你已经了解了HTTPS是如何工作的了，你的咖啡也应该准备好了。好好享用吧你受之无愧。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>不再性感，不再赚钱，数据科学的时代变了</title>
    <url>//post/database/</url>
    <content><![CDATA[<blockquote>
<p>作者：Vicki Boykis | 译者：阿拉丁 </p>
</blockquote>
<blockquote>
<p>阅读数：678 2019 年 3 月 2 日 | 话题：大数据  AI 最佳实践</p>
</blockquote>
<pre><code>当你看到“数据科学”这个词时，会想到什么？你可能会觉得它是统计学、机器学习、深度学习和“21 世纪最性感的工作”等关键词的组合，或者你的脑海里会浮现出一个数据科学家的形象，她坐在电脑旁，将 AB 测试得到的结果拼接在一起，又或者你听很多人说过干这行有赚不完的钱（根据权威部门统计：入门级数据科学家的平均年薪约人民币 744253 元）。无论是哪一种，它都是迷人、聪明和复杂的。

从本文作者 Vicki Boykis 十年前进入这一领域以来，数据科学一直给人这样的印象，但现在，数据科学已经不再是当初的样子了。以下内容由 AI 前线编译，原文来自 Vicki Boykis 发表于个人博客的文章《Data science is different now》。
</code></pre><p>我最初是一名数据分析师。</p>
<pre><code>我是否曾经提到过我有多讨厌 Excel 默认的数字字符串格式？
——Vicki Boykis（@vboykis）2012 年 5 月 18 日
</code></pre><p>我经常是一边苦等 SQL 的运行结果、整理乱糟糟的 Excel 文件，一边看着 Hacker News 上有关海量数据挖掘的文章、Facebook 数据科学团队的新闻和谷歌首席经济学家 Hal Varian 写的文章，然后一边做着白日梦。</p>
<p>2012 年，我很幸运地被分配到了一个数据分析工程团队，他们正在将一些 ETL 作业从 Oracle 迁移到 Hadoop 上，以便满足不断增长的数据吞吐量要求。</p>
<a id="more"></a>
<pre><code>有没有“给白痴用的 Hadoop”？ 给小白用的 Hadoop 并不适合我。
——Vicki Boykis（@vboykis）2012 年 8 月 16 日
</code></pre><p>我自愿成为第一个使用 Pig 和 Hive 的分析师，主要是因为我不想等到工程工作完成后才能访问我的数据。而且，我沉迷于数据科学家的光环——这些人开展很酷的实验，提出很酷的分析想法，并可以使用 MacBook。</p>
<p>我也想成为这样的人！所以，我在线学习了 Python，重温了我在大学学习过的统计学。在早期，并没有真正形式化的方法来学习“数据科学”，最多只能看看其他人在做什么、去参加聚会或者试着从人力资源招聘的职位描述中读出点什么。</p>
<p>在独自摸索了很长一段时间之后，我在过去的六年时间里已经在“数据科学”领域站稳了脚跟。并且，作为一名导师（但我之前并没有导师），我一直在回复电子邮件，和那些希望进入数据科学领域的人喝咖啡会面。</p>
<p>自 2012 年以来，数据科学行业发展极其迅速。它几乎经历了甘特炒作周期的每个阶段。</p>
<p>我们已经经历了早期采用阶段、有关人工智能和偏见的负面新闻、Facebook 等公司的第二轮和第三轮风险投资，现在正处于高采用增长阶段：银行、医疗保健公司和其他财富 100 强企业（这些公司已经落后市场五年）也在为机器学习招聘数据科学家。</p>
<p>很多东西都变了。大数据（记得 Hadoop 和 Pig 吗？）已经出局了，R 语言的采用率急剧上升，Python 成为经济学家的宠儿，而云计算再次改变了一切。</p>
<p>然而，媒体针对数据科学领域的炒作却没有变，一直在鼓吹数据科学家是“21 世纪最性感的职业”。但我现在认为这是一个很严重的问题，需要引起社区的注意。希望进入这个行业的初级数据科学家供过于求，而一旦他们获得了梦寐以求的“数据科学家”头衔，他们能够得到的东西与他们的期望其实是不匹配的。<br>新数据科学家的供过于求</p>
<p>首先，我们来谈谈初级数据科学家的供过于求。针对数据科学的持续媒体炒作导致过去五年中市场上的初级人才数量激增。</p>
<p>这纯粹是道听途说的东西，所以不要太当真。但是，基于我自己作为简历筛选者、数据科学家导师、面试官、面试者，以及与从事类似职业的朋友和同事的对话，我有一种直觉，每个给定的数据科学职位（特别是入门级的科学职位）的候选人数量从 20 个增加到 100 个或更多。我最近了解到，我的一位朋友在招聘一个职位时收到了不止 500 份简历。</p>
<p>这都很正常，类似的情况还有很多。机器学习教父吴恩达的 AI 创业公司每周要求工作 70 到 80 个小时，但仍然收到了大量申请，甚至有人愿意免费做志愿者。在写这篇文章时，他们的办公室已经容不下更多的人。</p>
<p>要评估市场需求与供应之间的真正差距是非常非常困难的，不过我们可以从这里(<a href="https://www.wired.com/story/andrew-ngs-new-online-school/)开始着手。" target="_blank" rel="noopener">https://www.wired.com/story/andrew-ngs-new-online-school/)开始着手。</a></p>
<pre><code>对 4 月份招聘广告的研究发现，美国有超过 10,000 个针对人工智能或机器学习的职位空缺。

[超过 10 万人参加了 Fast.ai](http://xn--10fast-qo7i07amn353ae9cy36wyeg.ai/)（一家专注于推广人工智能的创业公司）的深度学习课程。
</code></pre><p>假设平均 MOOC 完成率约为 7％，那意味着有 7000 人可以填补这 10,000 个工作岗位。但是，今年是这样，那么明年呢？我们是否在假设数据科学创造的就业率是稳定的？如果实际情况不是这样的，那么数据科学就业市场有可能会萎缩。</p>
<p>LinkedIn 提供的数据表明，市场上有 151,717 个数据科学人才空缺。虽然目前还不清楚它们是不是就是指数据科学家，或者是只拥有部分技能的人，但我们假设是前者。因此，我们可以说美国现在有 150,000 多个数据科学家职位空缺。</p>
<p>我们假设有 100,000 个人已经参加了数据科学课程，并且其中有 7,000 个人会完成课程。</p>
<p>但是，上面这数字并没有考虑到其他的数据科学候选人计划和途径：Fast.ai 之外的 MOOC，比如 Coursera、Metis（超过 10 个全国性训练营）和 General Assembly（每 12 周就有 25 人参加）、来自加州大学洛杉矶分校等地的远程学位、分析和数据科学的本科学位、YouTube，等等。还有很多博士正在从学术界转向数据科学领域，但却无法在竞争极其激烈的就业市场中找到工作。</p>
<p>这篇文章指出，在 2015 年有 4 万个数据科学家职位空缺。总体而言，到 2018 年，分析技能的市场供应将超过市场容量。<br>image</p>
<p>参加数据科学计划的初级人才数量，再加上数百个开设数据科学课程的训练营，你将看到一场完美的风暴。</p>
<p>除了我从工作中了解到的以及与 100 多名同事进行的交谈之外，下面的两条推文让我确信目前存在真正的数据科学供应泡沫。</p>
<pre><code>@Cal 的数据科学入门课程 Data 8 非常受欢迎。它位于有泽勒巴大剧院。2018 年秋季开学。pic.twitter.com/VBhtPnikmw
——Mike Olson（@mikeolson），2018 年 10 月 4 日

UVA（美国弗吉尼亚大学）很自豪地宣布开设数据科学学院的计划，它将满足社会对数据科学不断增长的需求。https://t.co/QlP4OUrTrO
——UVA（@UVA）2019 年 1 月 18 日
</code></pre><p>由于学术界在跟上新趋势方面通常会滞后，因此，对于所有希望在数据科学领域找到职位的初级数据科学家来说，这确实令人感到担忧。对于一个拥有数据科学新学位的人来说，要找到一个数据科学的职位是非常困难的，因为他们要在市场上与许多新人展开竞争。</p>
<p>但在三、四年前，情况并非如此。而现在，数据科学已经从流行语变成了连硅谷之外的公司都在招聘的职位，职位的准入门槛更高了，而且偏爱具备数据科学经验的人，数据科学面试仍然很难通过。</p>
<p>正如很多文章指出的那样，你不一定会在第一次尝试时就能找到你梦寐以求的工作。市场可能非常残酷，并且对于大量初入者来说非常令人沮丧。<br>数据科学是一个具有误导性的岗位需求</p>
<p>第二个问题是，一旦这些初级人员进入市场，他们会对数据科学工作产生不切实际的期望。每个人都认为他们将从事与机器学习、深度学习和贝叶斯模拟相关的工作。</p>
<p>这不是他们的错，这就是数据科学课程和技术媒体所宣扬的。</p>
<p>但现实的情况却是，“数据科学”大多数时候是关于如何清理和整理数据以及将数据从一个地方移动到另一个地方。</p>
<p>我最近进行的一次非科学调查证实了这一点：</p>
<pre><code>一段时间以来，我一直对此感到好奇，所以决定做一个民意调查。
“作为一个 2019 年被称为’数据科学家’的人，我花了大部分时间（60％以上）：”
也欢迎“其他”选项，请在回复中添加。
——Vicki Boykis（@vboykis）2019 年 1 月 28 日
</code></pre><p>还有很多行业专家发来的推文也是如此：</p>
<pre><code>对于我最近的几个 ML 项目，复杂性并不在于建模或训练，而在于输入预处理。我发现在一个项目中耗尽了 CPU（而不是 GPU），我不确定如何进一步优化 Python（我正在考虑使用 C++）。
——mat kelcey（@mat_kelcey）2019 年 2 月 11 日

我看到初级 ML/CV 工程师对构建数据集完全缺乏兴趣。虽然这是一项无聊的工作，但我认为在整理数据集时需要学到很多东西，毕竟这占了问题的一大半。
——Katherine Scott（@kscottz）2019 年 2 月 1 日

角色和责任：
- 自动化糟糕的商业行为

- 根据需要编写临时 SQL

经验要求：

· 15 年使用 Python 进行深度学习的经验

· 写过有关贝叶斯建模的博士论文

· 7 种语言的 NLP 经验

· 10 年从头开始​​创建 Hadoop 集群的经验

——NickHeitzman（@NickDoesData）2019 年 2 月 12 日

在过去两年中，项目的工作类别所占百分比：
- 涉及 ML：15％

- 涉及移动、监控和统计数据：85％

——Vicki Boykis（@vboykis）2019 年 1 月 15 日
</code></pre><p>显而易见的是，在炒作周期的后期阶段，数据科学逐渐向工程学靠近，数据科学家需要的技能不再是基于可视化和统计学，而是更接近传统计算机科学课程所提供的那些：</p>
<pre><code>像单元测试和持续集成这样的概念很快就成为数据科学家和从事 ML 工程的数值科学家的行话和常用的工具。
</code></pre><p>这导致了一些事情的发生。首先是“机器学习工程师”这个头衔的崛起，在过去的 3 到 4 年里，它带来了更多的声望和更高的收入潜力。</p>
<p>其次，它导致数据科学家头衔含金量严重缩水。由于数据科学家头衔的声望，像 Lyft 这样的公司会招聘数据科学，但实际上他们只需要数据分析师的技能，导致“数据科学”职位对技能的要求发生了扭曲，究竟需要多少新进入者也变得不明确。</p>
<h2 id="给新数据科学家的建议"><a href="#给新数据科学家的建议" class="headerlink" title="给新数据科学家的建议"></a>给新数据科学家的建议</h2><p>因此，本着继续为初学者提供建议的初衷，如果有人问我如何在 2019 年进入数据科学领域，我会给他们发送下面这样的电子邮件。</p>
<p>这是一个两步走的计划：</p>
<pre><code>1. 不要死盯着数据科学的工作岗位。

2. 为大多数数据科学家相关的工作做好准备，但不要成为数据科学家。调整你的技能组合。
</code></pre><p>这些话可能有点令人沮丧！但请允许我解释一下，希望它们不像听起来的那么悲观。</p>
<h2 id="不要进入数据科学领域"><a href="#不要进入数据科学领域" class="headerlink" title="不要进入数据科学领域"></a>不要进入数据科学领域</h2><p>因为每个初级职位一般有 50 个（有时 100 个，有时 200 个）人申请，所以不要与这些人去竞争。不要去攻读数学科学学位，不要参加训练营（我见过的大多数训练营的效果都不太好）。</p>
<p>不要做别人正在做的事情，因为这样无法让你脱颖而出。你正处在一个过度饱和的行业中，这样只会给自己增加难度。在我之前提到的那份PWC 报告中，数据科学职位的数量估计为 5 万，数据工程师职位的数量为 50 万，数据分析师职位的数量是 12.5 万。</p>
<p>通过“后门”进入数据科学领域要容易得多，也就是说从初级开发人员开始，可以是 DevOps 工程师、项目管理人员、数据分析师、信息管理员或类似的角色。这可能需要更长的时间，但在你努力完成数据科学工作的同时，你也将学会对职业生涯来说至关重要的 IT 技能。</p>
<h2 id="了解当今数据科学所需的技能"><a href="#了解当今数据科学所需的技能" class="headerlink" title="了解当今数据科学所需的技能"></a>了解当今数据科学所需的技能</h2><p>以下是你在数据领域需要解决的一些问题：</p>
<p>1）创建 Python 包</p>
<p>2）将 R 语言用在生产环境中</p>
<p>3）优化 Spark 作业，使其更有效地运行</p>
<p>4）对数据进行版本控制</p>
<p>5）让模型和数据可重现</p>
<p>6）对 SQL 进行版本控制</p>
<p>7）在数据湖中建立和维护干净的数据</p>
<p>8）大规模时间序列预测工具</p>
<p>9）共享 Jupyter Notebook</p>
<p>10）寻找可用于清理数据的系统</p>
<p>11）JSON</p>
<p>作为一名数据科学家，优化模型、可视化和分析数据是职责工作的一部分，而数据科学主要是（也一直是）关于在一个地方获得用于插补的干净数据。</p>
<p>你应该如何为解决这些问题做好准备？如何为工作做好准备？你可以考虑学习下面这三种技能，它们都是基础技能，并彼此依赖，从简单到困难。</p>
<p>所有这些技能也是数据科学以外的软件开发的基础和关键，这意味着，如果你无法找到数据科学工作，可以快速转做软件开发或 DevOps。我认为这种灵活性与针对特定数据相关工作的培训同样重要。</p>
<p><strong>1. 学习 SQL</strong></p>
<p>首先，我建议每个人都要学习 SQL，无论他们的目标是成为数据工程师、ML 专家还是 AI 大师。</p>
<p>SQL 并不性感，也不是上述问题的解决方案。但为了访问数据，你很可能需要针对数据库编写一些 SQL 查询，并用它获取答案。</p>
<p>SQL 非常强大且非常流行，甚至有些 NoSQL 和键值存储数据库也在重新实现它。比如 Presto 推出的 Presto 和 Athena、BigQuery、KSQL、Pandas、Spark，等等。如果你发现自己陷入了数据工具海洋之中，很可能可以找到一个适合你的 SQL 工具。而且，一旦你理解了 SQL，你会发现它比其他查询语言更容易理解，从而开辟了一个全新的世界。</p>
<p>在熟悉了 SQL 之后，下一步是了解数据库的工作原理，这样你就可以学会如何优化查询。你不一定要成为数据库开发人员，但很多概念将延续到你的其他编程生活当中。</p>
<p><strong>2. 学好一门编程语言和学习编程概念</strong></p>
<p>SQL 不是一门编程语言吗？它是的，但它是声明性的。你指定所需的输出（即你要从表中获取哪些列），但不指定这些列以怎样的形式返回给你。SQL 抽象了很多数据库底层的细节。</p>
<p>你需要一门过程式语言，你可以自行指定如何以及从哪里获取数据。大多数现代语言都是过程式的：Java、Python、Scala、R 语言、Go 语言，等等。</p>
<p>关于为数据科学应该选择哪种语言存在很多争论，我不会针对任何特定情况规定说要学习哪一种语言，只是在我的职业生涯中，Python 对我来说非常有用。作为一个初学者，它很容易入门，可以说是数据领域最流行的编程语言，并且可以用来完成很多不同的事情，从将模型嵌入 scikit 中，到访问 AWS API，再到构建 Web 应用程序、清理数据，以及创建深度学习模型。</p>
<p>当然，也有一些任务不太适合用 Python 来完成：大型应用程序、打包依赖项和一些特定的与数字相关的任务，特别是时间序列和 R 语言提供的一系列功能。</p>
<p>如果你不选择 Python，也没问题。但你至少要选择一种语言，让你在数据科学领域之外保持灵活性。例如，如果你的第一份工作是数据分析师、QA 分析师、DevOps 初级工程师，或者其他职位，掌握一门语言都有助于你站稳脚跟。</p>
<p>在选择了一门编程语言并弄清楚如何使用它之后，就可以开始学习它背后的范式以及它与计算机科学生态系统的关系。</p>
<p>你是如何使用你的语言实现 OOP 的？OOP 是什么东西？你如何优化你的代码？你的语言的依赖项是如何工作的？如何使用给定语言打包代码，如何进行版本控制、持续集成，如何部署模型工件？你的语言社区在哪里，会在哪里举行聚会？</p>
<p>了解你的语言，了解它的优缺点，用你的语言开发一些有趣的东西。</p>
<p>然后，当你有足够的信心继续下去时，也只有在这个时候，才能开始学习你的第二门语言。它将把你带入更广泛的语言设计、算法和模式的世界。</p>
<p><strong>3. 了解云端的工作</strong></p>
<p>现在你已经知道如何编程，现在是时候将这些技能和理论带到云端了。</p>
<p>如今，云无处不在，你可能需要在下一个工作中使用云。如果有更多的机器学习范例转移到云端（如 SageMaker、Cloud AI 和 Azure 机器学习），已经有现成的模板可用来实现算法，而且企业的更多数据也开始存储在那里。</p>
<p>你可能会与行业领导者 AWS 合作，但越来越多的公司正在采用 Google Cloud，而很多已经与微软开展业务合作的保守企业在使用 Azure。我建议深入了解这三个云供应商，然后挑选一个你最感兴趣的。云设计范式都是类似的，你必须了解如何将服务粘合在一起，如何区分云端的服务器，以及如何使用 JSON。</p>
<p>有趣的是，这三家供应商现在都提供了他们的产品认证。我一般不会通过认证来衡量一个人对知识的掌握程度与否，但通过认证可以学到云的工作原理，这是工程的另一个组成部分：网络。</p>
<p>了解这三种产品，并在开始下一份工作之前在云端构建一些有趣的东西。</p>
<p>这里缺失的部分当然是“软技能”——知道在什么时候构建什么，知道如何在工作场所进行交流，知道其他人想要什么。软技能与技术技能一样重要，有很多专门讨论它的文章，但为了保持这篇文章不会太长，这里就不作累述了。</p>
<h2 id="最后的步骤"><a href="#最后的步骤" class="headerlink" title="最后的步骤"></a>最后的步骤</h2><p>现在，请深呼吸，我想你已经做好准备了。</p>
<p>如果上述有任何一点（或者所有）让你感兴趣，那说明你已经准备好在 2019 年成为数据科学家、机器学习工程师、云专家或 AI 大师了。</p>
<p>请记住，你的最终目标是打败那些攻读数据科学学位、参加训练营和学习教程的人。</p>
<p>你想要迈出第一步，获得一个与数据相关的职位，然后朝着你梦想的工作前进，同时尽可能多地了解科技行业的总体情况。</p>
<p>我最后一个一般性的建议是给自己打气：</p>
<p>这对每个人来说都很难，似乎有很多事情你必须知道。不要气馁。</p>
<p>不要因为想太多就望而却步。先从小处开始，做一些小的事情，学习一些小的东西，构建一些小的东西，把你做的事情告诉其他人。请记住，你在数据科学领域的第一份工作可能不是数据科学家。</p>
<p>祝你好运！</p>
<p>英文原文：<br><a href="https://veekaybee.github.io/2019/02/13/data-science-is-different/" target="_blank" rel="noopener">https://veekaybee.github.io/2019/02/13/data-science-is-different/</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript ES2019 中的 8 个新功能</title>
    <url>//post/ES2019/</url>
    <content><![CDATA[<p>JavaScript 一直在不断改进和添加更多新功能。TC39 已经完成，并批准了 ES2019 的 8 项新功能。这个过程包含了 5 个阶段：</p>
<ul>
<li>第 0 阶段：稻草人</li>
<li>第 1 阶段：提案</li>
<li>第 2 阶段：草案</li>
<li>第 3 阶段：候选</li>
<li>第 4 阶段：已完成 / 已批准</li>
</ul>
<p>第 0 阶段的提案：<br><a href="https://github.com/tc39/proposals/blob/master/stage-0-proposals.md" target="_blank" rel="noopener">https://github.com/tc39/proposals/blob/master/stage-0-proposals.md</a></p>
<p>第 1 至 3 阶段的提案：<br><a href="https://github.com/tc39/proposals" target="_blank" rel="noopener">https://github.com/tc39/proposals</a></p>
<p>第 4 阶段的提案：<br><a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md" target="_blank" rel="noopener">https://github.com/tc39/proposals/blob/master/finished-proposals.md</a></p>
<p>废话不多说，接下来让我们来逐一介绍这些功能。</p>
<a id="more"></a>
<h3 id="1-可选的-catch-绑定"><a href="#1-可选的-catch-绑定" class="headerlink" title="1.可选的 catch 绑定"></a>1.可选的 catch 绑定</h3><p>可选的 catch 绑定提案是为了能够选择性地移除使用不到的 catch 绑定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	</span><br><span class="line">  // trying to use a new ES2019 feature</span><br><span class="line">	</span><br><span class="line">  // which may not be implemented in other browsers</span><br><span class="line">	</span><br><span class="line">&#125; catch (unused) &#123;</span><br><span class="line">	</span><br><span class="line">  // revert back to old way</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以删除使用不到的绑定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	</span><br><span class="line">  ...</span><br><span class="line">	</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">	</span><br><span class="line">  ...</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-JSON-超集"><a href="#2-JSON-超集" class="headerlink" title="2.JSON 超集"></a>2.JSON 超集</h3><p>这个提案的目的是让 JSON 字符串可以包含未转义的 U+2028 LINE SEPARATOR 和 U+2029 PARAGRAPH SEPARATOR 字符，而 ECMAScript 字符串是不能包含这些字符的。在 ES2019 生效之前，这样做会出现“SyntaxError: Invalid or unexpected token”错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const LS = eval(&apos;&quot;\u2028&quot;&apos;);</span><br><span class="line">	</span><br><span class="line">const PS = eval(&quot;&apos;\u2029&apos;&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="3-符号描述"><a href="#3-符号描述" class="headerlink" title="3. 符号描述"></a>3. 符号描述</h3><p>符号是在 ES2015 中引入的，具有非常独特的功能。在 ES2019 中可以提供给定的描述，目的是避免间接从 Symbol.prototype.toString 获取描述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mySymbol = Symbol(&apos;myDescription&apos;);</span><br><span class="line">	</span><br><span class="line">console.log(mySymbol); // Symbol(myDescription)</span><br><span class="line">	</span><br><span class="line">console.log(mySymbol.toString()); // Symbol(myDescription)</span><br><span class="line">	</span><br><span class="line">console.log(mySymbol.description); // myDescription</span><br></pre></td></tr></table></figure>
<h3 id="4-修订版的-Function-prototype-toString"><a href="#4-修订版的-Function-prototype-toString" class="headerlink" title="4. 修订版的 Function.prototype.toString"></a>4. 修订版的 Function.prototype.toString</h3><p>之前的函数原型已经有 toString 方法，但是在 ES2019 中，它经过了修订，可以包含函数内的注释，不过不适应于箭头函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function /* comment */ foo /* another comment */ ()&#123;&#125;</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">// Before</span><br><span class="line">	</span><br><span class="line">console.log(foo.toString()); // function foo()&#123;&#125;</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">// Now ES2019</span><br><span class="line">	</span><br><span class="line">console.log(foo.toString()); // function /* comment */ foo /* another comment */ ()&#123;&#125;</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">// Arrow Syntax</span><br><span class="line">	</span><br><span class="line">const bar /* comment */ = /* another comment */ () =&gt; &#123;&#125;</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">console.log(bar.toString()); // () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-Object-fromEntries"><a href="#5-Object-fromEntries" class="headerlink" title="5.Object.fromEntries"></a>5.Object.fromEntries</h3><p>它是 Object.entries 方法的反向操作，可用于克隆对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">	</span><br><span class="line">    prop1: 1,</span><br><span class="line">	</span><br><span class="line">    prop2: 2,</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">const entries = Object.entries(obj);</span><br><span class="line">	</span><br><span class="line">console.log(entries); // [ [ &apos;prop1&apos;, 1 ], [ &apos;prop2&apos;, 2 ] ]</span><br><span class="line">	</span><br><span class="line">const fromEntries = Object.fromEntries(entries);</span><br><span class="line">	</span><br><span class="line">console.log(fromEntries); // Object &#123; prop1: 1, prop2: 2 &#125;</span><br><span class="line">	</span><br><span class="line">console.log(obj === fromEntries); // false</span><br><span class="line"></span><br><span class="line">不过需要注意的是，嵌入式对象 / 数组都只是引用。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">const obj = &#123;</span><br><span class="line">	</span><br><span class="line">    prop1: 1,</span><br><span class="line">	</span><br><span class="line">    prop2: 2,</span><br><span class="line">	</span><br><span class="line">    deepCopy: &#123;</span><br><span class="line">	</span><br><span class="line">        mutateMe: true</span><br><span class="line">	</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">const entries = Object.entries(obj);</span><br><span class="line">	</span><br><span class="line">const fromEntries = Object.fromEntries(entries);</span><br><span class="line">	</span><br><span class="line">fromEntries.deepCopy.mutateMe = false;</span><br><span class="line">	</span><br><span class="line">console.log(obj.deepCopy.mutateMe); // false</span><br></pre></td></tr></table></figure>
<h3 id="6-格式化的-JSON-stringify"><a href="#6-格式化的-JSON-stringify" class="headerlink" title="6. 格式化的 JSON.stringify"></a>6. 格式化的 JSON.stringify</h3><p>这个提案是由同一个人提出来的，与 JSON 超集有关。ES2019 将使用 JSON 转义序列表示输出结果，而不是返回 UTF-16 代码单元。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Before</span><br><span class="line">	</span><br><span class="line">console.log(JSON.stringify(&apos;\uD800&apos;)); // &quot;?&quot;</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">// Now ES2019</span><br><span class="line">	</span><br><span class="line">console.log(JSON.stringify(&apos;\uD800&apos;)); // &quot;\ud800&quot;</span><br><span class="line"></span><br><span class="line">7.String.prototype 的 trimStart 和 trimEnd</span><br><span class="line"></span><br><span class="line">String 原型已经有了 trim 方法，用来移除字符串开头和结尾的空格。而 ES2019 引入了 trimStart 和 trimEnd。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">// Trim</span><br><span class="line">	</span><br><span class="line">const name = &quot;   Codedam &quot;;</span><br><span class="line">	</span><br><span class="line">console.log(name.trim());   // &quot;Codedam&quot;</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">// Trim Start</span><br><span class="line">	</span><br><span class="line">const description = &quot;   Unlocks Secret Codes &quot;;</span><br><span class="line">	</span><br><span class="line">console.log(description.trimStart());   // &quot;Unlocks Secret Codes &quot;</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">// Trim End</span><br><span class="line">	</span><br><span class="line">const category = &quot;  JavaScript &quot;;</span><br><span class="line">	</span><br><span class="line">console.log(category.trimEnd());    // &quot;  JavaScript&quot;</span><br></pre></td></tr></table></figure>
<h3 id="8-Array-prototype-的-flat-和-flatMap"><a href="#8-Array-prototype-的-flat-和-flatMap" class="headerlink" title="8.Array.prototype 的 flat 和 flatMap"></a>8.Array.prototype 的 flat 和 flatMap</h3><p>flat 方法通过将所有子数组元素以递归方式连接到指定的深度来创建数组。默认深度为 1，使数组的第一层嵌套展平。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, [3, 4, [5, 6]]];</span><br><span class="line">	</span><br><span class="line">arr.flat(); // [1, 2, 3, 4, [5, 6]]</span><br><span class="line">	</span><br><span class="line">arr.flat(2); // [1, 2, 3, 4, 5, 6]</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">// You can use Infinity to flatten all the nested arrays no matter how deep the array is</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">const arrExtreme = [1, [2, [3, [4, [5, 6, 7, [8, 9]]]]]];</span><br><span class="line">	</span><br><span class="line">arrExtreme.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">flatMap 方法类似于 flat，并且还与 map 相关，它会先映射数组然后将其展平。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">const arr = [&apos;Codedam&apos;, &apos;is Awsome&apos;, &apos;!&apos;];</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">const mapResult = arr.map(item =&gt; item.split(&apos; &apos;));</span><br><span class="line">	</span><br><span class="line">console.log(mapResult); // [ [ &apos;Codedam&apos; ], [ &apos;is&apos;, &apos;Awsome&apos; ], [ &apos;!&apos; ] ]</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">const flatMapResult = arr.flatMap(chunk =&gt; chunk.split(&apos; &apos;));</span><br><span class="line">	</span><br><span class="line">console.log(flatMapResult); // [&apos;Codedam&apos;, &apos;is&apos;,  &apos;Awsome&apos;, &apos;!&apos;];</span><br></pre></td></tr></table></figure>
<p>其他</p>
<p>我还想强调一下现在处在第 3 阶段的一些有用的特性。</p>
<ul>
<li><p><a href="https://github.com/tc39/proposal-global" target="_blank" rel="noopener">globalThis</a>；</p>
</li>
<li><p><a href="https://github.com/tc39/proposal-bigint" target="_blank" rel="noopener">BigInt</a>；</p>
</li>
<li><p><a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">import()</a>；</p>
</li>
<li><p><a href="https://github.com/tc39/proposal-regexp-legacy-features" target="_blank" rel="noopener">遗留的 RegEx</a>；</p>
</li>
<li><p><a href="https://github.com/tc39/proposal-private-methods" target="_blank" rel="noopener">私有的实例方法</a>；</p>
</li>
<li><p><a href="https://github.com/tc39/String.prototype.matchAll" target="_blank" rel="noopener">String.prototype.matchAll</a>。</p>
</li>
</ul>
<p>英文原文：<a href="https://codedam.com/8-new-features-javascript-es2019/" target="_blank" rel="noopener">https://codedam.com/8-new-features-javascript-es2019/</a></p>
<p>更多内容，请关注前端之巅。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
</search>
